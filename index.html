<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weapon Ball</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }

        #gameContainer {
            position: relative;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 40px;
        }

        /* Power-up Toolbar - Left Side */
        #powerupToolbar {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 20px 15px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 0%, rgba(30, 30, 50, 0.95) 100%);
            border-radius: 20px;
            border: 2px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.6);
            z-index: 1000;
        }

        #powerupToolbar h3 {
            color: #ffd700;
            font-size: 11px;
            text-align: center;
            margin: 0 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .powerup-btn {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: linear-gradient(180deg, rgba(60, 60, 80, 0.9) 0%, rgba(40, 40, 60, 0.9) 100%);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s ease;
            position: relative;
        }

        .powerup-btn:hover {
            transform: scale(1.1);
            border-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
        }

        .powerup-btn.selected {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            background: linear-gradient(180deg, rgba(100, 80, 0, 0.9) 0%, rgba(60, 50, 0, 0.9) 100%);
        }

        .powerup-btn.heal { color: #00ff00; }
        .powerup-btn.damage { color: #ff4444; }
        .powerup-btn.speed { color: #00bfff; }
        .powerup-btn.shield { color: #ffd700; }
        .powerup-btn.freeze { color: #88ffff; }

        .powerup-btn .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 10px;
            text-align: center;
            border-radius: 0 0 10px 10px;
        }

        .powerup-tooltip {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .powerup-btn:hover .powerup-tooltip {
            opacity: 1;
        }

        #gameCanvas {
            border-radius: 50%;
            box-shadow:
                0 0 60px rgba(0, 0, 0, 0.6),
                0 0 120px rgba(255, 200, 100, 0.1),
                inset 0 0 100px rgba(255, 255, 255, 0.1);
            background: #f5e6c8;
        }

        /* Settings Panel */
        #settingsPanel {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 24px;
            padding: 30px;
            color: white;
            width: 400px;
            max-height: 92vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #settingsPanel::-webkit-scrollbar {
            width: 8px;
        }
        #settingsPanel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        #settingsPanel::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
            border-radius: 4px;
        }

        #settingsPanel h2 {
            text-align: center;
            margin-bottom: 8px;
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 50%, #ff6347 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            letter-spacing: 2px;
        }

        .subtitle {
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 20px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        /* Round and Score Display */
        .round-display {
            text-align: center;
            font-size: 16px;
            color: #fff;
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 140, 0, 0.1) 100%);
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            font-weight: 600;
        }

        .score-display {
            padding: 18px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.2) 100%);
            border-radius: 14px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .score-display h3 {
            color: #ffd700;
            margin-bottom: 12px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .score-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .score-item span:last-child {
            font-weight: bold;
            font-size: 18px;
        }

        .winner-display {
            text-align: center;
            font-size: 26px;
            color: #ffd700;
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 140, 0, 0.1) 100%);
            border-radius: 12px;
            border: 2px solid #ffd700;
            animation: winPulse 1.5s infinite;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        @keyframes winPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
            50% { transform: scale(1.02); box-shadow: 0 0 40px rgba(255, 215, 0, 0.5); }
        }

        /* Settings Sections */
        .settings-section {
            margin-bottom: 24px;
            padding: 20px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.25) 0%, rgba(0, 0, 0, 0.15) 100%);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .settings-section h3 {
            margin-bottom: 16px;
            font-size: 13px;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-section h3::before {
            content: '';
            display: inline-block;
            width: 4px;
            height: 16px;
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
            border-radius: 2px;
        }

        /* Sliders */
        .slider-container {
            margin: 16px 0;
        }

        .slider-container label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        .slider-container label span:last-child {
            color: #ffd700;
            font-weight: 600;
            background: rgba(255, 215, 0, 0.15);
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 13px;
        }

        .slider-container input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.15);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(255, 215, 0, 0.4);
            transition: all 0.2s;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.6);
        }

        /* Team Mode */
        .team-mode-section {
            margin-bottom: 20px;
        }

        .team-mode-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            background: linear-gradient(135deg, rgba(100, 100, 255, 0.15) 0%, rgba(255, 100, 100, 0.15) 100%);
            border-radius: 12px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .team-mode-toggle:hover {
            background: linear-gradient(135deg, rgba(100, 100, 255, 0.25) 0%, rgba(255, 100, 100, 0.25) 100%);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .team-mode-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #ffd700;
        }

        .team-mode-toggle span {
            font-size: 14px;
            font-weight: 500;
        }

        /* Ball Selection */
        .ball-selection {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .ball-option {
            display: flex;
            flex-direction: column;
            padding: 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .ball-option:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.08) 100%);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }

        .ball-option.unchecked {
            opacity: 0.4;
        }

        .ball-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .ball-header input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #ffd700;
        }

        .ball-color-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 15px currentColor, inset 0 0 8px rgba(255, 255, 255, 0.4);
        }

        .ball-name {
            font-size: 16px;
            font-weight: 600;
            flex: 1;
        }

        .ball-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .weapon-select, .team-select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.4);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.15);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .weapon-select:hover, .team-select:hover {
            border-color: rgba(255, 215, 0, 0.5);
            background: rgba(0, 0, 0, 0.5);
        }

        .weapon-select:focus, .team-select:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .weapon-select option, .team-select option {
            background: #1a1a2e;
            color: white;
            padding: 8px;
        }

        /* Ability Description */
        .ability-info {
            margin-top: 10px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid #888;
        }

        .ability-info.legendary {
            border-left-color: #ffd700;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
        }

        .ability-info.mythical {
            border-left-color: #ff00ff;
            background: linear-gradient(90deg, rgba(255, 0, 255, 0.2) 0%, rgba(255, 215, 0, 0.2) 50%, rgba(0, 0, 0, 0.3) 100%);
            animation: mythicalPulse 2s infinite;
        }

        @keyframes mythicalPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

        .ability-info.magic {
            border-left-color: #44aaff;
            background: linear-gradient(90deg, rgba(68, 170, 255, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
        }

        .ability-info.melee {
            border-left-color: #ff6644;
            background: linear-gradient(90deg, rgba(255, 102, 68, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
        }

        .ability-info.special {
            border-left-color: #44ff88;
            background: linear-gradient(90deg, rgba(68, 255, 136, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
        }

        .ability-name {
            font-size: 12px;
            font-weight: 600;
            color: #ffd700;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ability-name .type-badge {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .type-badge.legendary {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #000;
        }

        /* Gacha/Unlock System Styles */
        .currency-display {
            position: fixed;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 10px 20px;
            color: #ffd700;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .currency-display .coin-icon {
            font-size: 24px;
        }

        .gacha-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 30px;
            z-index: 2000;
            min-width: 400px;
            display: none;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
        }

        .gacha-panel.active {
            display: block;
            animation: gachaAppear 0.3s ease-out;
        }

        @keyframes gachaAppear {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .gacha-title {
            text-align: center;
            color: #ffd700;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .gacha-rates {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .gacha-rates h4 {
            color: #fff;
            margin-bottom: 10px;
        }

        .rate-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rate-row.mythical { color: #ff00ff; }
        .rate-row.legendary { color: #ffd700; }
        .rate-row.special { color: #00ffff; }
        .rate-row.magic { color: #9932cc; }
        .rate-row.melee { color: #32cd32; }

        .roll-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .roll-btn {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .roll-btn.single {
            background: linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%);
            color: #fff;
            border: 2px solid #888;
        }

        .roll-btn.multi {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            color: #000;
            border: 2px solid #fff;
        }

        .roll-btn.mega {
            background: linear-gradient(135deg, #ff0080, #ff8c00, #ffd700, #00ff88, #00bfff, #8000ff);
            background-size: 300% 300%;
            animation: megaRainbow 3s ease infinite;
            color: #fff;
            border: 3px solid #fff;
            text-shadow: 1px 1px 2px #000;
            font-size: 16px;
        }

        @keyframes megaRainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .roll-btn.mega:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 128, 0.7), 0 0 60px rgba(0, 255, 136, 0.5);
        }

        .roll-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .roll-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .roll-result {
            text-align: center;
            padding: 20px;
            border-radius: 15px;
            margin-top: 15px;
            display: none;
        }

        .roll-result.active {
            display: block;
            animation: resultReveal 0.5s ease-out;
        }

        .roll-result.godly {
            background: linear-gradient(135deg, rgba(255,0,255,0.5), rgba(0,255,255,0.5), rgba(255,255,0,0.5));
            border: 3px solid #00ffff;
            animation: godlyRollPulse 0.5s infinite, resultReveal 0.5s ease-out;
            box-shadow: 0 0 30px rgba(0,255,255,0.8), 0 0 60px rgba(255,0,255,0.5);
        }
        @keyframes godlyRollPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(0,255,255,0.8), 0 0 60px rgba(255,0,255,0.5); }
            50% { box-shadow: 0 0 50px rgba(255,255,0,0.9), 0 0 80px rgba(0,255,255,0.7); }
        }
        .rate-row.godly {
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
            background-size: 300% 100%;
            animation: godlyRateShift 2s infinite;
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 5px #fff;
        }
        @keyframes godlyRateShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .roll-result.mythical { background: linear-gradient(135deg, rgba(255,0,255,0.3), rgba(255,215,0,0.3)); border: 2px solid #ff00ff; }
        .roll-result.legendary { background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; }
        .roll-result.special { background: rgba(0, 255, 255, 0.2); border: 2px solid #00ffff; }
        .roll-result.magic { background: rgba(153, 50, 204, 0.2); border: 2px solid #9932cc; }
        .roll-result.melee { background: rgba(50, 205, 50, 0.2); border: 2px solid #32cd32; }
        .roll-result.dupe { background: rgba(128, 128, 128, 0.2); border: 2px solid #888; }

        @keyframes resultReveal {
            from { transform: scale(0); }
            50% { transform: scale(1.2); }
            to { transform: scale(1); }
        }

        .result-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .result-type {
            font-size: 14px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        .close-gacha {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            opacity: 0.7;
        }

        .close-gacha:hover {
            opacity: 1;
        }

        .gacha-toggle-btn {
            position: fixed;
            top: 10px;
            right: 200px;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            border: none;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            color: #000;
        }

        .gacha-toggle-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .locked-weapon {
            opacity: 0.4;
            pointer-events: none;
        }

        .unlock-count {
            color: #888;
            font-size: 12px;
            margin-top: 10px;
            text-align: center;
        }

        .achievement-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a0a2a 0%, #1a1a2e 100%);
            border: 3px solid #ff00ff;
            border-radius: 20px;
            padding: 40px;
            z-index: 3000;
            text-align: center;
            display: none;
            animation: achievementPop 0.5s ease-out;
        }

        .achievement-popup.active {
            display: block;
        }

        @keyframes achievementPop {
            from { transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
            50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
            to { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }

        .achievement-title {
            color: #ff00ff;
            font-size: 32px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
        }

        .achievement-desc {
            color: #fff;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .achievement-reward {
            color: #ffd700;
            font-size: 20px;
        }

        /* Betting System Styles */
        .betting-section {
            background: linear-gradient(135deg, rgba(0, 100, 0, 0.3) 0%, rgba(0, 50, 0, 0.3) 100%);
            border: 2px solid #00aa00;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .betting-section h3 {
            color: #00ff00;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .betting-section h3::before {
            content: '$';
            font-size: 20px;
        }

        .bet-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .bet-row label {
            color: #aaa;
            min-width: 70px;
        }

        .bet-select {
            flex: 1;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #00aa00;
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }

        .bet-input {
            width: 100px;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #ffd700;
            border-radius: 5px;
            color: #ffd700;
            font-size: 14px;
            text-align: center;
        }

        .bet-input:focus {
            outline: none;
            border-color: #ffff00;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .bet-odds {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }

        .odds-display {
            display: flex;
            justify-content: space-between;
            color: #aaa;
            font-size: 13px;
            margin-bottom: 5px;
        }

        .potential-win {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-top: 8px;
        }

        .bet-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .bet-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .bet-btn.place {
            background: linear-gradient(135deg, #00aa00 0%, #006600 100%);
            color: white;
        }

        .bet-btn.clear {
            background: linear-gradient(135deg, #aa0000 0%, #660000 100%);
            color: white;
        }

        .bet-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .bet-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .bet-active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 140, 0, 0.2) 100%);
            border-color: #ffd700;
            animation: betPulse 1s infinite;
        }

        @keyframes betPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
        }

        .bet-result {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 30px 50px;
            z-index: 2500;
            text-align: center;
            display: none;
        }

        .bet-result.active {
            display: block;
            animation: resultPop 0.5s ease-out;
        }

        .bet-result.win {
            border-color: #00ff00;
        }

        .bet-result.lose {
            border-color: #ff0000;
        }

        @keyframes resultPop {
            from { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            to { transform: translate(-50%, -50%) scale(1); }
        }

        .bet-result-title {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .bet-result.win .bet-result-title {
            color: #00ff00;
        }

        .bet-result.lose .bet-result-title {
            color: #ff0000;
        }

        .bet-result-amount {
            font-size: 24px;
            color: #ffd700;
            margin-bottom: 20px;
        }

        .type-badge.mythical {
            background: linear-gradient(135deg, #ff00ff 0%, #ffd700 50%, #00ffff 100%);
            color: #000;
            font-weight: bold;
            animation: mythicalBadge 1.5s infinite;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }

        @keyframes mythicalBadge {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* GODLY Tier Styles */
        .ability-info.godly {
            border-left-color: #00ffff;
            background: linear-gradient(90deg,
                rgba(255, 0, 255, 0.2) 0%,
                rgba(0, 255, 255, 0.2) 25%,
                rgba(255, 255, 0, 0.2) 50%,
                rgba(255, 0, 255, 0.2) 75%,
                rgba(0, 0, 0, 0.3) 100%);
            animation: godlyPulse 3s infinite;
        }

        @keyframes godlyPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.5),
                            0 0 30px rgba(255, 0, 255, 0.3);
            }
            33% {
                box-shadow: 0 0 15px rgba(255, 0, 255, 0.5),
                            0 0 30px rgba(255, 255, 0, 0.3);
            }
            66% {
                box-shadow: 0 0 15px rgba(255, 255, 0, 0.5),
                            0 0 30px rgba(0, 255, 255, 0.3);
            }
        }

        .type-badge.godly {
            background: linear-gradient(135deg,
                #ff00ff 0%,
                #00ffff 25%,
                #ffff00 50%,
                #ff00ff 75%,
                #00ffff 100%);
            background-size: 200% 200%;
            animation: godlyBadge 2s ease infinite, godlyShine 1s ease infinite;
            color: #000;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 1);
            border: 1px solid white;
        }

        @keyframes godlyBadge {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes godlyShine {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.15); filter: brightness(1.3); }
        }

        /* SECRET Tier Styles */
        .ability-info.secret {
            border-left-color: #ff0000;
            background: linear-gradient(90deg,
                rgba(139, 0, 0, 0.3) 0%,
                rgba(255, 0, 0, 0.2) 50%,
                rgba(139, 0, 0, 0.3) 100%);
            animation: secretPulse 1.5s infinite;
        }

        @keyframes secretPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.6),
                            0 0 40px rgba(139, 0, 0, 0.4);
                border-left-color: #ff0000;
            }
            50% {
                box-shadow: 0 0 35px rgba(255, 0, 0, 0.9),
                            0 0 60px rgba(139, 0, 0, 0.6);
                border-left-color: #8b0000;
            }
        }

        .type-badge.secret {
            background: linear-gradient(135deg,
                #8b0000 0%,
                #ff0000 25%,
                #8b0000 50%,
                #ff0000 75%,
                #8b0000 100%);
            background-size: 200% 200%;
            animation: secretBadge 1s ease infinite;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 0, 1);
            border: 2px solid #ff0000;
        }

        @keyframes secretBadge {
            0%, 100% { background-position: 0% 50%; filter: brightness(1); }
            50% { background-position: 100% 50%; filter: brightness(1.5); }
        }

        .roll-result.secret {
            background: linear-gradient(135deg, rgba(139,0,0,0.5), rgba(255,0,0,0.3));
            border: 3px solid #ff0000;
            animation: secretRollPulse 0.3s infinite, resultReveal 0.5s ease-out;
            box-shadow: 0 0 40px rgba(255,0,0,0.8);
        }

        @keyframes secretRollPulse {
            0%, 100% { box-shadow: 0 0 40px rgba(255,0,0,0.8); }
            50% { box-shadow: 0 0 60px rgba(139,0,0,1); }
        }

        .rate-row.secret {
            background: linear-gradient(90deg, #8b0000, #ff0000, #8b0000);
            background-size: 200% 100%;
            animation: secretRateShift 1s infinite;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }

        @keyframes secretRateShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes deathFade {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }

        /* Skill Tree Styles */
        .skill-tree-btn {
            position: fixed;
            top: 10px;
            right: 320px;
            background: linear-gradient(135deg, #4a0080 0%, #800080 100%);
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            color: #fff;
            font-size: 14px;
        }

        .skill-tree-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(128, 0, 128, 0.5);
        }

        .skill-tree-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #4a0080;
            border-radius: 15px;
            padding: 25px;
            z-index: 10001;
            min-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            box-shadow: 0 0 50px rgba(128, 0, 128, 0.5);
        }

        .skill-tree-panel.active {
            display: block;
            animation: skillTreeAppear 0.3s ease-out;
        }

        @keyframes skillTreeAppear {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .skill-tree-title {
            text-align: center;
            color: #bf00ff;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(191, 0, 255, 0.5);
        }

        .skill-points-display {
            text-align: center;
            color: #ffd700;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .weapon-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .weapon-tab {
            padding: 8px 15px;
            background: #2a2a4a;
            border: 1px solid #444;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .weapon-tab:hover {
            background: #3a3a5a;
            border-color: #666;
        }

        .weapon-tab.active {
            background: linear-gradient(135deg, #4a0080, #800080);
            border-color: #bf00ff;
        }

        .weapon-tab.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .skill-tree-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .skill-node {
            background: #2a2a4a;
            border: 2px solid #444;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .skill-node:hover:not(.locked) {
            border-color: #bf00ff;
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.3);
        }

        .skill-node.unlocked {
            border-color: #00ff00;
            background: linear-gradient(135deg, #1a3a1a, #2a4a2a);
        }

        .skill-node.maxed {
            border-color: #ffd700;
            background: linear-gradient(135deg, #3a3a1a, #4a4a2a);
        }

        .skill-node.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skill-icon {
            font-size: 30px;
            margin-bottom: 8px;
        }

        .skill-name {
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .skill-desc {
            color: #aaa;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .skill-level {
            color: #ffd700;
            font-size: 12px;
        }

        .skill-cost {
            color: #ff6600;
            font-size: 11px;
            margin-top: 5px;
        }

        .close-skill-tree {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            opacity: 0.7;
        }

        .close-skill-tree:hover {
            opacity: 1;
        }

        .tier-label {
            grid-column: span 3;
            color: #bf00ff;
            font-size: 16px;
            text-align: center;
            padding: 10px 0 5px;
            border-top: 1px solid #333;
            margin-top: 10px;
        }

        .tier-label:first-child {
            border-top: none;
            margin-top: 0;
        }

        /* Fractal effect for Paradoxical */
        .fractal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .fractal-overlay.active {
            opacity: 0.3;
            animation: fractalWarp 2s ease-in-out;
        }

        @keyframes fractalWarp {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(180deg); }
        }

        .type-badge.magic {
            background: linear-gradient(135deg, #44aaff 0%, #6644ff 100%);
            color: #fff;
        }

        .type-badge.melee {
            background: linear-gradient(135deg, #ff6644 0%, #ff4444 100%);
            color: #fff;
        }

        .type-badge.special {
            background: linear-gradient(135deg, #44ff88 0%, #00cc66 100%);
            color: #000;
        }

        .ability-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
        }

        /* Start Button */
        #startButton {
            width: 100%;
            padding: 18px;
            font-size: 22px;
            font-weight: 700;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 50%, #3d8b40 100%);
            color: white;
            border: none;
            border-radius: 14px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.4);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        #startButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        #startButton:hover::before {
            left: 100%;
        }

        #startButton:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 35px rgba(76, 175, 80, 0.5);
        }

        #startButton:active {
            transform: translateY(-1px);
        }

        #startButton:disabled {
            background: linear-gradient(135deg, #555 0%, #444 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #startButton:disabled::before {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Currency Display -->
    <div class="currency-display">
        <span class="coin-icon">$</span>
        <span id="currencyAmount">0</span>
    </div>

    <!-- Gacha Toggle Button -->
    <button class="gacha-toggle-btn" onclick="toggleGachaPanel()">ROLL SHOP</button>
    <button class="skill-tree-btn" onclick="toggleSkillTree()">SKILL TREE</button>

    <!-- Gacha Panel -->
    <div id="gachaPanel" class="gacha-panel">
        <span class="close-gacha" onclick="toggleGachaPanel()">X</span>
        <h2 class="gacha-title">WEAPON BALL GACHA</h2>

        <div class="gacha-rates">
            <h4>Drop Rates:</h4>
            <div class="rate-row secret"><span>SECRET</span><span>???</span></div>
            <div class="rate-row godly"><span>GODLY</span><span>0.1%</span></div>
            <div class="rate-row mythical"><span>Mythical</span><span>0.35%</span></div>
            <div class="rate-row legendary"><span>Legendary</span><span>4.5%</span></div>
            <div class="rate-row special"><span>Special</span><span>15%</span></div>
            <div class="rate-row magic"><span>Magic</span><span>30%</span></div>
            <div class="rate-row melee"><span>Melee</span><span>50%</span></div>
        </div>

        <div class="roll-buttons">
            <button class="roll-btn single" onclick="doGachaRoll(1)">
                Roll x1<br><small>100 $</small>
            </button>
            <button class="roll-btn multi" onclick="doGachaRoll(10)">
                Roll x10<br><small>900 $</small>
            </button>
            <button class="roll-btn mega" onclick="doGachaRoll(100)">
                Roll x100<br><small>8000 $</small>
            </button>
        </div>

        <div id="rollResult" class="roll-result">
            <div class="result-name" id="resultName"></div>
            <div class="result-type" id="resultType"></div>
        </div>

        <div class="unlock-count">
            Unlocked: <span id="unlockedCount">2</span> / <span id="totalWeapons">0</span>
        </div>
    </div>

    <!-- Skill Tree Panel -->
    <div id="skillTreePanel" class="skill-tree-panel">
        <span class="close-skill-tree" onclick="toggleSkillTree()">X</span>
        <h2 class="skill-tree-title">SKILL TREE</h2>
        <div class="skill-points-display">
            Skill Points: <span id="skillPointsAmount">0</span> |
            <span style="color: #aaa; font-size: 14px;">Earn 1 point per round, 3 for wins</span>
        </div>
        <div class="weapon-selector" id="weaponTabs"></div>
        <div class="skill-tree-container" id="skillTreeContainer"></div>
    </div>

    <!-- Achievement Popup -->
    <div id="achievementPopup" class="achievement-popup">
        <div class="achievement-title">ACHIEVEMENT UNLOCKED!</div>
        <div class="achievement-desc" id="achievementDesc"></div>
        <div class="achievement-reward" id="achievementReward"></div>
        <button onclick="closeAchievement()" style="margin-top: 20px; padding: 10px 30px; font-size: 16px; cursor: pointer;">NICE!</button>
    </div>

    <!-- Power-up Toolbar -->
    <div id="powerupToolbar">
        <h3>Power-Ups</h3>
        <button class="powerup-btn heal" data-type="heal"><span style="font-size:28px">+</span><span class="powerup-tooltip">HEAL</span></button>
        <button class="powerup-btn damage" data-type="damage"><span style="font-size:24px">X</span><span class="powerup-tooltip">DAMAGE x2</span></button>
        <button class="powerup-btn speed" data-type="speed"><span style="font-size:28px">&#8811;</span><span class="powerup-tooltip">SPEED</span></button>
        <button class="powerup-btn shield" data-type="shield"><span style="font-size:24px">( )</span><span class="powerup-tooltip">SHIELD</span></button>
        <button class="powerup-btn freeze" data-type="freeze"><span style="font-size:28px">*</span><span class="powerup-tooltip">FREEZE</span></button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="700" height="700"></canvas>
        <div id="settingsPanel">
            <h2>Weapon Ball</h2>
            <div class="subtitle">Battle Arena</div>
            <div class="round-display" id="roundDisplay">Round 1 / 1</div>
            <div class="score-display" id="scoreDisplay"></div>
            <div id="winnerDisplay" class="winner-display" style="display: none;"></div>

            <div class="settings-section team-mode-section">
                <h3>Game Mode</h3>
                <label class="team-mode-toggle">
                    <input type="checkbox" id="teamModeToggle">
                    <span>Enable 2v1 Team Mode</span>
                </label>
            </div>

            <div class="settings-section">
                <h3>Game Settings</h3>
                <div class="slider-container">
                    <label><span>Ball Speed</span><span id="speedValue">1.0x</span></label>
                    <input type="range" id="speedSlider" min="0.25" max="2" step="0.25" value="1">
                </div>
                <div class="slider-container">
                    <label><span>Ball Health</span><span id="healthValue">100</span></label>
                    <input type="range" id="healthSlider" min="50" max="300" step="25" value="100">
                </div>
                <div class="slider-container">
                    <label><span>Rounds</span><span id="roundsValue">1</span></label>
                    <input type="range" id="roundsSlider" min="1" max="10" step="1" value="1">
                </div>
            </div>

            <div class="settings-section">
                <h3>Select Balls</h3>
                <div class="ball-selection" id="ballSelection"></div>
            </div>

            <!-- Betting Section -->
            <div class="settings-section betting-section" id="bettingSection">
                <h3>Place Your Bet</h3>
                <div class="bet-row">
                    <label>Bet On:</label>
                    <select class="bet-select" id="betBallSelect">
                        <option value="">-- Select Ball --</option>
                    </select>
                </div>
                <div class="bet-row">
                    <label>Amount:</label>
                    <input type="number" class="bet-input" id="betAmount" min="10" max="1000" value="50" step="10">
                    <span style="color: #ffd700;">$</span>
                </div>
                <div class="bet-odds">
                    <div class="odds-display">
                        <span>Odds:</span>
                        <span id="betOdds">-</span>
                    </div>
                    <div class="odds-display">
                        <span>Your Balance:</span>
                        <span id="betBalance">0$</span>
                    </div>
                    <div class="potential-win">
                        Win: <span id="potentialWin">0</span>$
                    </div>
                </div>
                <div class="bet-buttons">
                    <button class="bet-btn place" id="placeBetBtn" onclick="placeBet()">Place Bet</button>
                    <button class="bet-btn clear" id="clearBetBtn" onclick="clearBet()">Clear</button>
                </div>
            </div>

            <!-- Bet Result Popup -->
            <div id="betResult" class="bet-result">
                <div class="bet-result-title" id="betResultTitle">YOU WIN!</div>
                <div class="bet-result-amount" id="betResultAmount">+500$</div>
                <button onclick="closeBetResult()" style="padding: 10px 30px; font-size: 16px; cursor: pointer;">OK</button>
            </div>

            <button id="startButton">Start Battle</button>
        </div>
    </div>

    <script>
        // === GACHA/UNLOCK SYSTEM ===
        const GACHA_COST_SINGLE = 100;
        const GACHA_COST_MULTI = 900;
        const GACHA_COST_MEGA = 8000;

        // Tier drop rates (must sum to 100)
        const TIER_RATES = {
            secret: 0.05,
            godly: 0.1,
            mythical: 0.35,
            legendary: 4.5,
            special: 15,
            magic: 30,
            melee: 50
        };

        // Load saved data from localStorage
        const GACHA_VERSION = 5; // Increment to reset player data

        function loadGameData() {
            const saved = localStorage.getItem('weaponBallData');
            console.log('Loading game data, saved:', saved);
            if (saved) {
                const data = JSON.parse(saved);
                console.log('Parsed data version:', data.version, 'Current version:', GACHA_VERSION);
                // Check version - if old version or no version, reset to new defaults
                if (!data.version || data.version < GACHA_VERSION) {
                    console.log('Resetting gacha data to new version');
                    localStorage.removeItem('weaponBallData');
                    return getDefaultGameData();
                }
                console.log('Using saved data, unlocked weapons:', data.unlockedWeapons);
                return data;
            }
            console.log('No saved data, using defaults');
            return getDefaultGameData();
        }

        function getDefaultGameData() {
            return {
                version: GACHA_VERSION,
                currency: 500, // Start with enough for a few rolls
                unlockedWeapons: ['sword', 'spear', 'lightyagami'], // Starting weapons + Light for testing
                achievements: [],
                skillPoints: 5,
                skills: {},
                stats: {
                    totalKills: 0,
                    totalWins: 0,
                    totalRounds: 0,
                    damageDealt: 0,
                    perfectWins: 0, // Win without taking damage
                    comebackWins: 0, // Win from <10% HP
                    killStreaks: 0 // 5+ kills in one round
                }
            };
        }

        function saveGameData() {
            gameData.version = GACHA_VERSION; // Always ensure version is set
            localStorage.setItem('weaponBallData', JSON.stringify(gameData));
        }

        // === SKILL TREE SYSTEM ===
        const SKILL_DEFINITIONS = {
            // Universal skills (all weapons)
            damage1: { name: 'Sharpen I', icon: 'âš”ï¸', desc: '+10% damage', maxLevel: 3, cost: 1, tier: 1, effect: { damage: 0.1 } },
            damage2: { name: 'Sharpen II', icon: 'ðŸ—¡ï¸', desc: '+15% damage', maxLevel: 3, cost: 2, tier: 2, requires: 'damage1', effect: { damage: 0.15 } },
            speed1: { name: 'Swiftness I', icon: 'ðŸ’¨', desc: '+8% speed', maxLevel: 3, cost: 1, tier: 1, effect: { speed: 0.08 } },
            speed2: { name: 'Swiftness II', icon: 'âš¡', desc: '+12% speed', maxLevel: 3, cost: 2, tier: 2, requires: 'speed1', effect: { speed: 0.12 } },
            health1: { name: 'Vitality I', icon: 'â¤ï¸', desc: '+15% max HP', maxLevel: 3, cost: 1, tier: 1, effect: { health: 0.15 } },
            health2: { name: 'Vitality II', icon: 'ðŸ’–', desc: '+20% max HP', maxLevel: 3, cost: 2, tier: 2, requires: 'health1', effect: { health: 0.2 } },
            cooldown1: { name: 'Focus I', icon: 'ðŸ”„', desc: '-10% ability cooldown', maxLevel: 3, cost: 2, tier: 1, effect: { cooldown: 0.1 } },
            cooldown2: { name: 'Focus II', icon: 'ðŸŽ¯', desc: '-15% ability cooldown', maxLevel: 2, cost: 3, tier: 2, requires: 'cooldown1', effect: { cooldown: 0.15 } },
            size1: { name: 'Growth I', icon: 'ðŸ“ˆ', desc: '+10% size', maxLevel: 2, cost: 1, tier: 1, effect: { size: 0.1 } },
            defense1: { name: 'Armor I', icon: 'ðŸ›¡ï¸', desc: '-10% damage taken', maxLevel: 3, cost: 2, tier: 1, effect: { defense: 0.1 } },
            defense2: { name: 'Armor II', icon: 'ðŸ°', desc: '-15% damage taken', maxLevel: 2, cost: 3, tier: 2, requires: 'defense1', effect: { defense: 0.15 } },
            lifesteal: { name: 'Vampirism', icon: 'ðŸ§›', desc: 'Heal 5% of damage dealt', maxLevel: 3, cost: 3, tier: 2, effect: { lifesteal: 0.05 } },
            crit1: { name: 'Precision I', icon: 'ðŸŽ¯', desc: '+5% crit chance', maxLevel: 3, cost: 2, tier: 1, effect: { crit: 0.05 } },
            crit2: { name: 'Precision II', icon: 'ðŸ’¥', desc: '+50% crit damage', maxLevel: 2, cost: 3, tier: 2, requires: 'crit1', effect: { critDamage: 0.5 } },
            regen: { name: 'Regeneration', icon: 'ðŸ’š', desc: 'Heal 1 HP/sec', maxLevel: 3, cost: 2, tier: 2, effect: { regen: 1 } },
            ultimate: { name: 'Mastery', icon: 'ðŸ‘‘', desc: 'All stats +5%', maxLevel: 1, cost: 10, tier: 3, requires: ['damage2', 'health2'], effect: { all: 0.05 } }
        };

        let currentSkillWeapon = null;

        function toggleSkillTree() {
            const panel = document.getElementById('skillTreePanel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                updateSkillPointsDisplay();
                buildWeaponTabs();
                if (!currentSkillWeapon && gameData.unlockedWeapons.length > 0) {
                    currentSkillWeapon = gameData.unlockedWeapons[0];
                }
                renderSkillTree();
            }
        }

        function updateSkillPointsDisplay() {
            document.getElementById('skillPointsAmount').textContent = gameData.skillPoints || 0;
        }

        function buildWeaponTabs() {
            const container = document.getElementById('weaponTabs');
            container.innerHTML = '';

            weapons.forEach(w => {
                const tab = document.createElement('div');
                tab.className = 'weapon-tab';
                if (!isWeaponUnlocked(w.id)) {
                    tab.className += ' locked';
                    tab.title = 'Locked';
                } else if (currentSkillWeapon === w.id) {
                    tab.className += ' active';
                }
                tab.textContent = w.name;
                tab.onclick = () => {
                    if (isWeaponUnlocked(w.id)) {
                        currentSkillWeapon = w.id;
                        buildWeaponTabs();
                        renderSkillTree();
                    }
                };
                container.appendChild(tab);
            });
        }

        function renderSkillTree() {
            const container = document.getElementById('skillTreeContainer');
            container.innerHTML = '';

            if (!currentSkillWeapon) {
                container.innerHTML = '<div style="color:#888;text-align:center;grid-column:span 3;">Select a weapon above</div>';
                return;
            }

            const weaponSkills = getWeaponSkills(currentSkillWeapon);

            // Group by tier
            const tiers = { 1: [], 2: [], 3: [] };
            Object.entries(weaponSkills).forEach(([id, skill]) => {
                tiers[skill.tier].push({ id, ...skill });
            });

            // Render each tier
            [1, 2, 3].forEach(tier => {
                if (tiers[tier].length === 0) return;

                const tierLabel = document.createElement('div');
                tierLabel.className = 'tier-label';
                // Fix tier labels with HTML entities
                const tierLabels = {
                    1: '<span style="color:#6f6">&#9733;</span> TIER 1 - BASIC',
                    2: '<span style="color:#fc0">&#9733;</span> TIER 2 - ADVANCED',
                    3: '<span style="color:#fd0">&#9733;</span> TIER 3 - MASTER'
                };
                tierLabel.innerHTML = tierLabels[tier];
                container.appendChild(tierLabel);

                tiers[tier].forEach(skill => {
                    const node = createSkillNode(skill);
                    container.appendChild(node);
                });
            });
        }

        function getWeaponSkills(weaponId) {
            // All weapons get base skills, some get special ones
            return SKILL_DEFINITIONS;
        }

        function createSkillNode(skill) {
            const node = document.createElement('div');
            node.className = 'skill-node';

            const currentLevel = getSkillLevel(currentSkillWeapon, skill.id);
            const isMaxed = currentLevel >= skill.maxLevel;
            const canUnlock = canUnlockSkill(currentSkillWeapon, skill);

            if (isMaxed) {
                node.className += ' maxed';
            } else if (currentLevel > 0) {
                node.className += ' unlocked';
            } else if (!canUnlock) {
                node.className += ' locked';
            }

            // Use text-based icons for compatibility
            const iconMap = {
                damage1: '<b style="color:#f60">ATK</b>',
                damage2: '<b style="color:#f30">ATK+</b>',
                speed1: '<b style="color:#0cf">SPD</b>',
                speed2: '<b style="color:#0ff">SPD+</b>',
                health1: '<b style="color:#f06">HP</b>',
                health2: '<b style="color:#f09">HP+</b>',
                cooldown1: '<b style="color:#96f">CD</b>',
                cooldown2: '<b style="color:#c9f">CD+</b>',
                size1: '<b style="color:#6f6">SIZE</b>',
                defense1: '<b style="color:#69f">DEF</b>',
                defense2: '<b style="color:#36f">DEF+</b>',
                lifesteal: '<b style="color:#c00">VAMP</b>',
                crit1: '<b style="color:#fc0">CRIT</b>',
                crit2: '<b style="color:#ff0">CRIT+</b>',
                regen: '<b style="color:#0f6">REGEN</b>',
                ultimate: '<b style="color:#fd0">MASTER</b>'
            };
            const displayIcon = iconMap[skill.id] || skill.icon;

            node.innerHTML = `
                <div class="skill-icon">${displayIcon}</div>
                <div class="skill-name">${skill.name}</div>
                <div class="skill-desc">${skill.desc}</div>
                <div class="skill-level">${currentLevel} / ${skill.maxLevel}</div>
                ${!isMaxed ? `<div class="skill-cost">Cost: ${skill.cost} pts</div>` : '<div class="skill-cost" style="color:#0f0;">MAXED</div>'}
            `;

            if (!isMaxed && canUnlock) {
                node.onclick = () => upgradeSkill(skill);
            }

            return node;
        }

        function getSkillLevel(weaponId, skillId) {
            if (!gameData.skills) gameData.skills = {};
            if (!gameData.skills[weaponId]) gameData.skills[weaponId] = {};
            return gameData.skills[weaponId][skillId] || 0;
        }

        function canUnlockSkill(weaponId, skill) {
            // Check if has enough points
            if ((gameData.skillPoints || 0) < skill.cost) return false;

            // Check requirements
            if (skill.requires) {
                const reqs = Array.isArray(skill.requires) ? skill.requires : [skill.requires];
                for (const req of reqs) {
                    const reqSkill = SKILL_DEFINITIONS[req];
                    if (getSkillLevel(weaponId, req) < reqSkill.maxLevel) {
                        return false;
                    }
                }
            }

            return true;
        }

        function upgradeSkill(skill) {
            const currentLevel = getSkillLevel(currentSkillWeapon, skill.id);
            if (currentLevel >= skill.maxLevel) return;
            if ((gameData.skillPoints || 0) < skill.cost) return;
            if (!canUnlockSkill(currentSkillWeapon, skill)) return;

            // Spend points
            gameData.skillPoints -= skill.cost;

            // Upgrade skill
            if (!gameData.skills) gameData.skills = {};
            if (!gameData.skills[currentSkillWeapon]) gameData.skills[currentSkillWeapon] = {};
            gameData.skills[currentSkillWeapon][skill.id] = currentLevel + 1;

            saveGameData();
            updateSkillPointsDisplay();
            renderSkillTree();

            // Visual feedback
            const flash = document.createElement('div');
            flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(191,0,255,0.2);z-index:10002;pointer-events:none;';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 200);
        }

        function getWeaponSkillBonuses(weaponId) {
            const bonuses = {
                damage: 1,
                speed: 1,
                health: 1,
                size: 1,
                cooldown: 1,
                defense: 0,
                lifesteal: 0,
                crit: 0,
                critDamage: 1.5,
                regen: 0
            };

            if (!gameData.skills || !gameData.skills[weaponId]) return bonuses;

            Object.entries(gameData.skills[weaponId]).forEach(([skillId, level]) => {
                if (level <= 0) return;
                const skill = SKILL_DEFINITIONS[skillId];
                if (!skill || !skill.effect) return;

                Object.entries(skill.effect).forEach(([stat, value]) => {
                    if (stat === 'all') {
                        bonuses.damage += value * level;
                        bonuses.speed += value * level;
                        bonuses.health += value * level;
                    } else if (stat === 'defense' || stat === 'lifesteal' || stat === 'crit' || stat === 'regen') {
                        bonuses[stat] += value * level;
                    } else if (stat === 'cooldown') {
                        bonuses[stat] -= value * level;
                    } else {
                        bonuses[stat] += value * level;
                    }
                });
            });

            // Clamp cooldown reduction
            bonuses.cooldown = Math.max(0.3, bonuses.cooldown);

            return bonuses;
        }

        let gameData = loadGameData();

        function updateCurrencyDisplay() {
            const el = document.getElementById('currencyAmount');
            if (el) el.textContent = gameData.currency;
        }

        function updateUnlockCount() {
            const unlocked = document.getElementById('unlockedCount');
            const total = document.getElementById('totalWeapons');
            if (unlocked) unlocked.textContent = gameData.unlockedWeapons.length;
            // Total will be set after weapons array is defined
        }

        function toggleGachaPanel() {
            const panel = document.getElementById('gachaPanel');
            panel.classList.toggle('active');
            updateUnlockCount();
        }

        function getRandomWeaponByTier() {
            // Roll for tier first
            const roll = Math.random() * 100;
            let cumulative = 0;
            let selectedTier = 'melee';

            for (const [tier, rate] of Object.entries(TIER_RATES)) {
                cumulative += rate;
                if (roll < cumulative) {
                    selectedTier = tier;
                    break;
                }
            }

            // Get weapons of this tier that exist
            const tierWeapons = weapons.filter(w => w.type === selectedTier);
            if (tierWeapons.length === 0) {
                // Fallback to melee if no weapons of this tier
                return weapons.filter(w => w.type === 'melee')[0];
            }

            // Random weapon from this tier
            return tierWeapons[Math.floor(Math.random() * tierWeapons.length)];
        }

        function doGachaRoll(count) {
            const cost = count === 1 ? GACHA_COST_SINGLE : count === 10 ? GACHA_COST_MULTI : GACHA_COST_MEGA;

            if (gameData.currency < cost) {
                alert('Not enough currency! Play more rounds to earn money.');
                return;
            }

            gameData.currency -= cost;
            updateCurrencyDisplay();

            const results = [];
            let newUnlocks = [];

            for (let i = 0; i < count; i++) {
                const weapon = getRandomWeaponByTier();
                results.push(weapon);

                if (!gameData.unlockedWeapons.includes(weapon.id)) {
                    gameData.unlockedWeapons.push(weapon.id);
                    newUnlocks.push(weapon);
                }
            }

            saveGameData();
            updateUnlockCount();
            refreshWeaponDropdowns();

            // Show result (last roll or best new unlock)
            const bestResult = newUnlocks.length > 0 ?
                newUnlocks.reduce((a, b) => getTierValue(a.type) > getTierValue(b.type) ? a : b) :
                results[results.length - 1];

            showRollResult(bestResult, newUnlocks.length > 0, count > 1 ? newUnlocks.length : null);
        }

        function getTierValue(tier) {
            const values = { secret: 7, godly: 6, mythical: 5, legendary: 4, special: 3, magic: 2, melee: 1 };
            return values[tier] || 0;
        }

        function showRollResult(weapon, isNew, multiCount) {
            const resultDiv = document.getElementById('rollResult');
            const nameEl = document.getElementById('resultName');
            const typeEl = document.getElementById('resultType');

            resultDiv.className = 'roll-result active ' + (isNew ? weapon.type : 'dupe');
            nameEl.textContent = isNew ? weapon.name : weapon.name + ' (DUPE +50$)';
            typeEl.textContent = isNew ?
                (multiCount ? `NEW! (${multiCount} new unlock${multiCount > 1 ? 's' : ''})` : 'NEW UNLOCK!') :
                'Already owned - Refund';

            // Special GODLY roll effect!
            if (isNew && weapon.type === 'godly') {
                showGodlyRollEffect(weapon.name);
            }

            // Special SECRET roll effect!
            if (isNew && weapon.type === 'secret') {
                showSecretRollEffect(weapon.name);
            }

            if (!isNew) {
                // Refund some currency for dupes
                gameData.currency += 50;
                updateCurrencyDisplay();
                saveGameData();
            }

            // Hide after delay (longer for godly)
            setTimeout(() => {
                resultDiv.classList.remove('active');
            }, weapon.type === 'godly' ? 6000 : 3000);
        }

        function showGodlyRollEffect(weaponName) {
            // Create full-screen overlay for GODLY roll
            const overlay = document.createElement('div');
            overlay.id = 'godlyOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,0,0,0.9) 100%);
                z-index: 10000; display: flex; flex-direction: column;
                justify-content: center; align-items: center;
                animation: godlyOverlayFade 0.5s ease-out;
            `;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes godlyOverlayFade { from { opacity: 0; } to { opacity: 1; } }
                @keyframes godlyTextPulse {
                    0%, 100% { transform: scale(1); text-shadow: 0 0 30px #00ffff, 0 0 60px #ff00ff; }
                    50% { transform: scale(1.1); text-shadow: 0 0 50px #ffff00, 0 0 100px #00ffff; }
                }
                @keyframes godlyRainbow {
                    0% { color: #ff00ff; }
                    33% { color: #00ffff; }
                    66% { color: #ffff00; }
                    100% { color: #ff00ff; }
                }
                @keyframes paradoxSpin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);

            overlay.innerHTML = `
                <div style="font-size: 80px; animation: godlyTextPulse 0.5s infinite, godlyRainbow 1s infinite;">
                    GODLY!!!
                </div>
                <div style="font-size: 50px; color: #fff; margin-top: 20px; animation: godlyTextPulse 0.5s infinite 0.1s;">
                    ${weaponName}
                </div>
                <div style="font-size: 200px; margin-top: 30px; animation: paradoxSpin 2s linear infinite;">
                    &#8734;
                </div>
                <div style="font-size: 24px; color: #00ffff; margin-top: 20px;">
                    REALITY BENDS TO YOUR WILL
                </div>
            `;

            document.body.appendChild(overlay);

            // Screen shake effect
            document.body.style.animation = 'none';
            document.body.offsetHeight; // Trigger reflow
            document.body.style.animation = 'shake 0.1s infinite';

            // Remove after 5 seconds
            setTimeout(() => {
                overlay.style.animation = 'godlyOverlayFade 0.5s ease-out reverse';
                document.body.style.animation = 'none';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                }, 500);
            }, 5000);
        }

        function showSecretRollEffect(weaponName) {
            // Create ominous overlay for SECRET roll
            const overlay = document.createElement('div');
            overlay.id = 'secretOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(circle, rgba(139,0,0,0.9) 0%, rgba(0,0,0,0.95) 100%);
                z-index: 10000; display: flex; flex-direction: column;
                justify-content: center; align-items: center;
            `;

            overlay.innerHTML = `
                <div style="font-size: 60px; color: #ff0000; font-family: 'Times New Roman', serif;
                            text-shadow: 0 0 30px #8b0000; animation: secretTextPulse 0.5s infinite;">
                    SECRET
                </div>
                <div style="font-size: 40px; color: #fff; margin-top: 20px;
                            text-shadow: 0 0 20px #ff0000;">
                    ${weaponName}
                </div>
                <div style="font-size: 100px; margin-top: 30px; color: #8b0000;">
                    &#9760;
                </div>
                <div style="font-size: 18px; color: #ff0000; margin-top: 20px; font-style: italic;">
                    "I am justice."
                </div>
            `;

            const style = document.createElement('style');
            style.textContent = `
                @keyframes secretTextPulse {
                    0%, 100% { opacity: 1; transform: scale(1); }
                    50% { opacity: 0.7; transform: scale(1.05); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(overlay);

            // Heartbeat sound effect simulation with screen pulse
            let pulseCount = 0;
            const pulseInterval = setInterval(() => {
                overlay.style.background = pulseCount % 2 === 0
                    ? 'radial-gradient(circle, rgba(255,0,0,0.9) 0%, rgba(0,0,0,0.95) 100%)'
                    : 'radial-gradient(circle, rgba(139,0,0,0.9) 0%, rgba(0,0,0,0.95) 100%)';
                pulseCount++;
                if (pulseCount > 10) clearInterval(pulseInterval);
            }, 300);

            setTimeout(() => {
                overlay.style.transition = 'opacity 0.5s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                }, 500);
            }, 4000);
        }

        function isWeaponUnlocked(weaponId) {
            // Unarmed requires achievement
            if (weaponId === 'unarmed') {
                return gameData.achievements.includes('true_warrior');
            }
            // Paradoxical requires Mythical Battle achievement
            if (weaponId === 'paradoxical') {
                return gameData.achievements.includes('mythical_battle') && gameData.unlockedWeapons.includes(weaponId);
            }
            const unlocked = gameData.unlockedWeapons.includes(weaponId);
            return unlocked;
        }

        function refreshWeaponDropdowns() {
            // Will be called after weapons array is defined
            if (typeof weapons === 'undefined') return;

            const swordIdx = weapons.findIndex(w => w.id === 'sword');

            document.querySelectorAll('.weapon-select').forEach(select => {
                const currentValue = parseInt(select.value);
                select.innerHTML = '';

                const weaponTypes = ['secret', 'godly', 'mythical', 'legendary', 'special', 'melee', 'magic'];
                weaponTypes.forEach(type => {
                    const typeWeapons = weapons.filter(w => w.type === type);
                    if (typeWeapons.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = type.charAt(0).toUpperCase() + type.slice(1);

                        typeWeapons.forEach(w => {
                            const weaponIdx = weapons.indexOf(w);
                            const opt = document.createElement('option');
                            opt.value = weaponIdx; // Use numeric index, not string ID

                            if (isWeaponUnlocked(w.id)) {
                                opt.textContent = w.name;
                            } else {
                                opt.textContent = '[LOCKED] ' + w.name;
                                opt.disabled = true;
                                opt.style.color = '#666';
                            }

                            optgroup.appendChild(opt);
                        });

                        select.appendChild(optgroup);
                    }
                });

                // Try to restore previous value if valid
                if (!isNaN(currentValue) && currentValue >= 0 && currentValue < weapons.length) {
                    const weapon = weapons[currentValue];
                    if (weapon && isWeaponUnlocked(weapon.id)) {
                        select.value = currentValue;
                    } else {
                        select.value = swordIdx;
                    }
                } else {
                    select.value = swordIdx;
                }
            });
        }

        // Award currency after round
        function awardRoundCurrency(ball, isWinner, stats) {
            let reward = 0;
            const reasons = [];

            // Base participation reward
            reward += 20;
            reasons.push('+20 Participation');

            // Winner bonus
            if (isWinner) {
                reward += 100;
                reasons.push('+100 Victory!');
            }

            // Kill bonus
            if (stats.kills > 0) {
                const killBonus = stats.kills * 25;
                reward += killBonus;
                reasons.push(`+${killBonus} Kills (${stats.kills})`);
            }

            // Damage bonus
            if (stats.damageDealt > 0) {
                const dmgBonus = Math.floor(stats.damageDealt / 50) * 5;
                reward += dmgBonus;
                if (dmgBonus > 0) reasons.push(`+${dmgBonus} Damage`);
            }

            // Survival bonus (% HP remaining)
            if (isWinner && stats.hpPercent > 0) {
                const survivalBonus = Math.floor(stats.hpPercent * 50);
                reward += survivalBonus;
                reasons.push(`+${survivalBonus} HP Bonus`);
            }

            // Perfect win (no damage taken)
            if (isWinner && stats.hpPercent >= 1) {
                reward += 200;
                reasons.push('+200 PERFECT!');
                checkAchievement('perfect_warrior', 'Perfect Victory', 'Win without taking any damage', 'Unlocked: Bonus 500$');
            }

            // Comeback win
            if (isWinner && stats.lowestHp < 0.1) {
                reward += 150;
                reasons.push('+150 COMEBACK!');
                gameData.stats.comebackWins++;
            }

            gameData.currency += reward;
            gameData.stats.totalRounds++;
            if (isWinner) gameData.stats.totalWins++;

            // Award skill points
            const skillPointsEarned = isWinner ? 3 : 1;
            if (!gameData.skillPoints) gameData.skillPoints = 0;
            gameData.skillPoints += skillPointsEarned;
            reasons.push(`+${skillPointsEarned} Skill Points`);

            saveGameData();
            updateCurrencyDisplay();

            // Check for Unarmed achievement
            checkUnarmedAchievement();

            // Check for Mythical Battle achievement
            checkMythicalBattleAchievement();

            return { total: reward, breakdown: reasons };
        }

        // Achievement system
        function checkAchievement(id, title, desc, rewardText) {
            if (gameData.achievements.includes(id)) return false;

            gameData.achievements.push(id);

            // Special rewards
            if (id === 'true_warrior') {
                // Unarmed unlock - no currency, just the unlock
            } else if (id === 'perfect_warrior') {
                gameData.currency += 500;
            } else if (id === 'mythical_battle') {
                gameData.currency += 1000;
                // Paradoxical can now be rolled
            }

            saveGameData();
            showAchievement(title, desc, rewardText);
            return true;
        }

        function checkUnarmedAchievement() {
            // Win 10 rounds with only melee weapons to unlock Unarmed
            // For now, let's make it: Win 5 rounds total
            if (!gameData.achievements.includes('true_warrior') && gameData.stats.totalWins >= 5) {
                checkAchievement('true_warrior', 'TRUE WARRIOR', 'Won 5 battles - Prove your worth without weapons!', 'Unlocked: UNARMED BALL!');
                refreshWeaponDropdowns();
            }
        }

        function checkMythicalBattleAchievement() {
            // Check if the last battle was only mythical or godly balls
            if (gameData.achievements.includes('mythical_battle')) return;

            // We need at least 2 balls and all must be mythical or godly
            if (!lastBattleWeapons || lastBattleWeapons.length < 2) {
                console.log('Mythical Battle: Not enough balls', lastBattleWeapons);
                return;
            }

            const allMythicalOrHigher = lastBattleWeapons.every(weaponId => {
                const weapon = weapons.find(w => w.id === weaponId);
                const isMythicalOrGodly = weapon && (weapon.type === 'mythical' || weapon.type === 'godly');
                console.log('Checking weapon:', weaponId, weapon?.type, isMythicalOrGodly);
                return isMythicalOrGodly;
            });

            console.log('All mythical or higher?', allMythicalOrHigher);

            if (allMythicalOrHigher) {
                checkAchievement('mythical_battle', 'MYTHICAL BATTLE', 'Witnessed a clash of legendary power!', 'Unlocked: GODLY Paradoxical can now be rolled!');
                refreshWeaponDropdowns();
            }
        }

        // Track weapons used in last battle
        let lastBattleWeapons = [];

        function showAchievement(title, desc, reward) {
            const popup = document.getElementById('achievementPopup');
            document.getElementById('achievementDesc').textContent = desc;
            document.getElementById('achievementReward').textContent = reward;
            popup.classList.add('active');
        }

        function closeAchievement() {
            document.getElementById('achievementPopup').classList.remove('active');
        }

        // === BETTING SYSTEM ===
        let currentBet = {
            ballIndex: null,
            amount: 0,
            odds: 0,
            active: false
        };

        // Calculate ball power rating based on weapon
        function getBallPowerRating(weaponIndex) {
            if (weaponIndex === undefined || weaponIndex === null) return 50;
            const weapon = weapons[weaponIndex];
            if (!weapon) return 50;

            let power = 50; // Base power

            // Type bonuses
            const typeBonus = {
                'mythical': 100,
                'legendary': 60,
                'special': 35,
                'magic': 25,
                'melee': 15
            };
            power += typeBonus[weapon.type] || 0;

            // Stat bonuses
            power += (weapon.damage || 10) * 2;
            power += (weapon.length || 30) * 0.5;
            power += ((weapon.speed || 1) - 1) * 20;
            power += ((weapon.size || 1) - 1) * 30;

            return Math.round(power);
        }

        // Calculate odds based on relative power
        function calculateBetOdds(ballIndex) {
            const selectedBalls = [];
            ballConfigs.forEach((_, i) => {
                if (document.getElementById(`ball${i}`)?.checked) {
                    selectedBalls.push({
                        index: i,
                        weaponIndex: settings.weaponAssignments[i],
                        power: getBallPowerRating(settings.weaponAssignments[i])
                    });
                }
            });

            if (selectedBalls.length < 2) return 1;

            const betBall = selectedBalls.find(b => b.index === ballIndex);
            if (!betBall) return 1;

            // Calculate total power and bet ball's share
            const totalPower = selectedBalls.reduce((sum, b) => sum + b.power, 0);
            const avgPower = totalPower / selectedBalls.length;

            // Underdog multiplier: weaker balls get higher odds
            // If your ball has 50 power and average is 100, you get 2x base odds
            const powerRatio = avgPower / betBall.power;

            // Base odds from number of balls
            const baseOdds = selectedBalls.length;

            // Final odds: base * power ratio, with min 1.5x and max 50x
            let finalOdds = baseOdds * powerRatio;
            finalOdds = Math.max(1.5, Math.min(50, finalOdds));

            return Math.round(finalOdds * 10) / 10; // Round to 1 decimal
        }

        function updateBetUI() {
            const betSelect = document.getElementById('betBallSelect');
            const betAmount = document.getElementById('betAmount');
            const betOdds = document.getElementById('betOdds');
            const potentialWin = document.getElementById('potentialWin');
            const betBalance = document.getElementById('betBalance');

            // Update balance display
            if (betBalance) {
                betBalance.textContent = gameData.currency + '$';
            }

            // Populate ball select
            if (betSelect) {
                const currentVal = betSelect.value;
                betSelect.innerHTML = '<option value="">-- Select Ball --</option>';

                ballConfigs.forEach((config, i) => {
                    if (document.getElementById(`ball${i}`)?.checked) {
                        const weaponIdx = settings.weaponAssignments[i];
                        const weapon = weapons[weaponIdx];
                        const power = getBallPowerRating(weaponIdx);
                        const opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = `${config.name} (${weapon?.name || 'Sword'}) - Power: ${power}`;
                        opt.style.color = config.color;
                        betSelect.appendChild(opt);
                    }
                });

                if (currentVal) betSelect.value = currentVal;
            }

            // Update odds display
            if (betSelect && betSelect.value !== '') {
                const odds = calculateBetOdds(parseInt(betSelect.value));
                currentBet.odds = odds;
                betOdds.textContent = odds + 'x';

                const amount = parseInt(betAmount.value) || 0;
                potentialWin.textContent = Math.round(amount * odds);

                // Color code odds
                if (odds >= 10) {
                    betOdds.style.color = '#ff00ff'; // Mythical odds!
                    potentialWin.style.color = '#ff00ff';
                } else if (odds >= 5) {
                    betOdds.style.color = '#ffd700'; // Great odds
                    potentialWin.style.color = '#ffd700';
                } else if (odds >= 3) {
                    betOdds.style.color = '#00ff00'; // Good odds
                    potentialWin.style.color = '#00ff00';
                } else {
                    betOdds.style.color = '#aaa'; // Low odds
                    potentialWin.style.color = '#aaa';
                }
            } else {
                betOdds.textContent = '-';
                potentialWin.textContent = '0';
            }
        }

        function placeBet() {
            const betSelect = document.getElementById('betBallSelect');
            const betAmount = document.getElementById('betAmount');

            if (!betSelect.value) {
                alert('Select a ball to bet on!');
                return;
            }

            const amount = parseInt(betAmount.value) || 0;
            if (amount < 10) {
                alert('Minimum bet is 10$!');
                return;
            }

            if (amount > gameData.currency) {
                alert('Not enough money! You have ' + gameData.currency + '$');
                return;
            }

            // Place the bet
            currentBet.ballIndex = parseInt(betSelect.value);
            currentBet.amount = amount;
            currentBet.odds = calculateBetOdds(currentBet.ballIndex);
            currentBet.active = true;

            // Deduct bet amount
            gameData.currency -= amount;
            saveGameData();
            updateCurrencyDisplay();
            updateBetUI();

            // Visual feedback
            document.getElementById('bettingSection').classList.add('bet-active');
            document.getElementById('placeBetBtn').disabled = true;
            document.getElementById('betBallSelect').disabled = true;
            document.getElementById('betAmount').disabled = true;

            console.log(`Bet placed: ${amount}$ on ball ${currentBet.ballIndex} at ${currentBet.odds}x odds`);
        }

        function clearBet() {
            if (currentBet.active) {
                // Refund the bet
                gameData.currency += currentBet.amount;
                saveGameData();
                updateCurrencyDisplay();
            }

            currentBet = { ballIndex: null, amount: 0, odds: 0, active: false };

            document.getElementById('bettingSection').classList.remove('bet-active');
            document.getElementById('placeBetBtn').disabled = false;
            document.getElementById('betBallSelect').disabled = false;
            document.getElementById('betBallSelect').value = '';
            document.getElementById('betAmount').disabled = false;

            updateBetUI();
        }

        function resolveBet(winnerIndex) {
            if (!currentBet.active) return;

            const betResult = document.getElementById('betResult');
            const betResultTitle = document.getElementById('betResultTitle');
            const betResultAmount = document.getElementById('betResultAmount');

            if (winnerIndex === currentBet.ballIndex) {
                // WIN!
                const winnings = Math.round(currentBet.amount * currentBet.odds);
                gameData.currency += winnings;
                saveGameData();
                updateCurrencyDisplay();

                betResult.className = 'bet-result active win';
                betResultTitle.textContent = 'YOU WIN!';
                betResultAmount.textContent = '+' + winnings + '$';

                // Check for big win achievement
                if (winnings >= 1000) {
                    checkAchievement('high_roller', 'HIGH ROLLER', 'Won 1000$+ on a single bet!', '+500$ Bonus!');
                }
                if (currentBet.odds >= 10) {
                    checkAchievement('underdog_champion', 'UNDERDOG CHAMPION', 'Won a bet with 10x+ odds!', '+300$ Bonus!');
                }
            } else {
                // LOSE
                betResult.className = 'bet-result active lose';
                betResultTitle.textContent = 'YOU LOSE!';
                betResultAmount.textContent = '-' + currentBet.amount + '$';
            }

            // Reset bet state
            currentBet = { ballIndex: null, amount: 0, odds: 0, active: false };

            document.getElementById('bettingSection').classList.remove('bet-active');
            document.getElementById('placeBetBtn').disabled = false;
            document.getElementById('betBallSelect').disabled = false;
            document.getElementById('betAmount').disabled = false;

            updateBetUI();
        }

        function closeBetResult() {
            document.getElementById('betResult').classList.remove('active');
        }

        // Update bet UI when balls are checked/unchecked or weapons change
        function setupBettingListeners() {
            // Update when ball selection changes
            ballConfigs.forEach((_, i) => {
                const checkbox = document.getElementById(`ball${i}`);
                if (checkbox) {
                    checkbox.addEventListener('change', updateBetUI);
                }
                const weaponSelect = document.getElementById(`weapon${i}`);
                if (weaponSelect) {
                    weaponSelect.addEventListener('change', updateBetUI);
                }
            });

            // Update when bet selection changes
            const betSelect = document.getElementById('betBallSelect');
            if (betSelect) {
                betSelect.addEventListener('change', updateBetUI);
            }

            // Update when bet amount changes
            const betAmount = document.getElementById('betAmount');
            if (betAmount) {
                betAmount.addEventListener('input', updateBetUI);
            }

            // Initial update
            updateBetUI();
        }

        // Initialize on load
        setTimeout(() => {
            updateCurrencyDisplay();
            updateUnlockCount();
            if (typeof weapons !== 'undefined') {
                document.getElementById('totalWeapons').textContent = weapons.length;
                refreshWeaponDropdowns();
            }
        }, 100);

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const arenaRadius = 320;

        // Ball configs
        const ballConfigs = [
            { name: 'Red', color: '#ff4444', darkColor: '#cc0000' },
            { name: 'Purple', color: '#9944ff', darkColor: '#6600cc' },
            { name: 'Cyan', color: '#44ffff', darkColor: '#00cccc' },
            { name: 'Green', color: '#44ff44', darkColor: '#00cc00' },
            { name: 'Yellow', color: '#ffff44', darkColor: '#cccc00' },
            { name: 'Orange', color: '#ff8844', darkColor: '#cc5500' }
        ];

        // Draw functions
        function drawSword(ctx, weapon, ball) {
            const isParry = ball && ball.abilityActive && ball.weapon.id === 'sword';
            ctx.fillStyle = '#4a3728'; ctx.fillRect(-2, -3, 12, 6);
            ctx.fillStyle = '#8B4513';
            for (let i = 0; i < 3; i++) { ctx.fillRect(i * 3, -3, 2, 6); }
            ctx.fillStyle = '#c9a227'; ctx.fillRect(8, -8, 4, 16);
            ctx.fillStyle = isParry ? '#00ffff' : '#c0c0c0';
            ctx.shadowColor = isParry ? '#00ffff' : 'transparent';
            ctx.shadowBlur = isParry ? 15 : 0;
            ctx.beginPath(); ctx.moveTo(12, -4); ctx.lineTo(42, -2); ctx.lineTo(48, 0);
            ctx.lineTo(42, 2); ctx.lineTo(12, 4); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#e8e8e8';
            ctx.beginPath(); ctx.moveTo(14, -1); ctx.lineTo(40, 0); ctx.lineTo(14, 1); ctx.closePath(); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawAxe(ctx, weapon, ball) {
            ctx.fillStyle = '#5c4033'; ctx.fillRect(-5, -3, 35, 6);
            ctx.fillStyle = '#8B4513';
            for (let i = 0; i < 6; i++) { ctx.fillRect(-5 + i * 5, -3, 2, 6); }
            ctx.fillStyle = '#708090';
            ctx.beginPath(); ctx.moveTo(25, -5); ctx.lineTo(40, -15); ctx.lineTo(45, -12);
            ctx.lineTo(38, 0); ctx.lineTo(45, 12); ctx.lineTo(40, 15);
            ctx.lineTo(25, 5); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#a8a8a8';
            ctx.beginPath(); ctx.moveTo(28, -3); ctx.lineTo(38, -10); ctx.lineTo(42, -8);
            ctx.lineTo(35, 0); ctx.lineTo(42, 8); ctx.lineTo(38, 10);
            ctx.lineTo(28, 3); ctx.closePath(); ctx.fill();
        }

        function drawPickaxe(ctx, weapon, ball) {
            ctx.fillStyle = '#5c4033'; ctx.fillRect(-5, -3, 35, 6);
            ctx.fillStyle = '#8B4513';
            for (let i = 0; i < 6; i++) { ctx.fillRect(-5 + i * 5, -3, 2, 6); }
            ctx.fillStyle = '#505050';
            ctx.beginPath(); ctx.moveTo(25, 0); ctx.lineTo(30, -4); ctx.lineTo(48, -6);
            ctx.lineTo(50, -3); ctx.lineTo(35, 0); ctx.lineTo(50, 3);
            ctx.lineTo(48, 6); ctx.lineTo(30, 4); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#707070';
            ctx.beginPath(); ctx.moveTo(28, 0); ctx.lineTo(32, -2); ctx.lineTo(45, -4);
            ctx.lineTo(46, -2); ctx.lineTo(34, 0); ctx.lineTo(46, 2);
            ctx.lineTo(45, 4); ctx.lineTo(32, 2); ctx.closePath(); ctx.fill();
        }

        function drawSpear(ctx, weapon, ball) {
            const isCharging = ball && ball.abilityActive && ball.weapon.id === 'spear';
            ctx.fillStyle = '#5c4033'; ctx.fillRect(-5, -2, 50, 4);
            ctx.fillStyle = '#8B4513';
            for (let i = 0; i < 10; i++) { ctx.fillRect(-5 + i * 5, -2, 2, 4); }
            ctx.fillStyle = isCharging ? '#ff6600' : '#708090';
            ctx.shadowColor = isCharging ? '#ff6600' : 'transparent';
            ctx.shadowBlur = isCharging ? 15 : 0;
            ctx.beginPath(); ctx.moveTo(45, -4); ctx.lineTo(60, 0); ctx.lineTo(45, 4); ctx.closePath(); ctx.fill();
            ctx.fillStyle = isCharging ? '#ffaa00' : '#a0a0a0';
            ctx.beginPath(); ctx.moveTo(47, -2); ctx.lineTo(56, 0); ctx.lineTo(47, 2); ctx.closePath(); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawHammer(ctx, weapon, ball) {
            const isSlamming = ball && ball.abilityActive && ball.weapon.id === 'hammer';
            ctx.fillStyle = '#5c4033'; ctx.fillRect(-5, -3, 40, 6);
            ctx.fillStyle = isSlamming ? '#ffcc00' : '#505050';
            ctx.shadowColor = isSlamming ? '#ffcc00' : 'transparent';
            ctx.shadowBlur = isSlamming ? 20 : 0;
            ctx.fillRect(30, -15, 18, 30);
            ctx.fillStyle = isSlamming ? '#ffee88' : '#707070';
            ctx.fillRect(33, -12, 12, 24);
            ctx.fillStyle = '#404040';
            ctx.fillRect(30, -2, 18, 4);
            ctx.shadowBlur = 0;
        }

        function drawDagger(ctx, weapon, ball) {
            const isShadow = ball && ball.abilityActive && ball.weapon.id === 'dagger';
            ctx.globalAlpha = isShadow ? 0.5 : 1;
            ctx.fillStyle = '#2a1a0a'; ctx.fillRect(-2, -3, 10, 6);
            ctx.fillStyle = '#4a3020';
            for (let i = 0; i < 2; i++) { ctx.fillRect(i * 4, -3, 2, 6); }
            ctx.fillStyle = '#3a3a3a'; ctx.fillRect(6, -5, 3, 10);
            ctx.fillStyle = isShadow ? '#8844ff' : '#b0b0b0';
            ctx.shadowColor = isShadow ? '#8844ff' : 'transparent';
            ctx.shadowBlur = isShadow ? 10 : 0;
            ctx.beginPath(); ctx.moveTo(9, -3); ctx.lineTo(30, -1); ctx.lineTo(32, 0);
            ctx.lineTo(30, 1); ctx.lineTo(9, 3); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#d0d0d0';
            ctx.beginPath(); ctx.moveTo(10, -1); ctx.lineTo(28, 0); ctx.lineTo(10, 1); ctx.closePath(); ctx.fill();
            ctx.shadowBlur = 0; ctx.globalAlpha = 1;
        }

        function drawScythe(ctx, weapon, ball) {
            const isLifeSteal = ball && ball.abilityActive && ball.weapon.id === 'scythe';
            ctx.fillStyle = '#2a1a1a'; ctx.fillRect(-5, -2, 45, 4);
            ctx.fillStyle = isLifeSteal ? '#ff0000' : '#303030';
            ctx.shadowColor = isLifeSteal ? '#ff0000' : 'transparent';
            ctx.shadowBlur = isLifeSteal ? 15 : 0;
            ctx.beginPath(); ctx.moveTo(35, -2); ctx.lineTo(40, -25); ctx.lineTo(55, -30);
            ctx.lineTo(50, -20); ctx.lineTo(55, -5); ctx.lineTo(45, 0);
            ctx.lineTo(35, 2); ctx.closePath(); ctx.fill();
            ctx.fillStyle = isLifeSteal ? '#ff4444' : '#505050';
            ctx.beginPath(); ctx.moveTo(38, -3); ctx.lineTo(42, -20); ctx.lineTo(50, -24);
            ctx.lineTo(47, -17); ctx.lineTo(50, -7); ctx.lineTo(43, -2); ctx.closePath(); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawFireStaff(ctx, weapon, ball) {
            ctx.fillStyle = '#3a1a0a'; ctx.fillRect(-5, -3, 40, 6);
            const time = Date.now() / 100;
            for (let i = 0; i < 8; i++) {
                const flicker = Math.sin(time + i) * 3;
                ctx.fillStyle = i % 2 === 0 ? '#ff4400' : '#ffaa00';
                ctx.beginPath();
                ctx.arc(40, Math.sin(time * 0.5 + i) * 3, 8 - i * 0.5 + flicker * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff4400'; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(40, 0, 10, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawIceWand(ctx, weapon, ball) {
            ctx.fillStyle = '#e0f0ff'; ctx.fillRect(-5, -2, 35, 4);
            ctx.fillStyle = '#88ddff';
            for (let i = 0; i < 6; i++) { ctx.fillRect(-5 + i * 6, -2, 3, 4); }
            ctx.fillStyle = '#44ccff';
            ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 15;
            ctx.beginPath(); ctx.moveTo(28, -8); ctx.lineTo(32, 0); ctx.lineTo(28, 8);
            ctx.lineTo(38, 4); ctx.lineTo(45, 0); ctx.lineTo(38, -4); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#aaeeff';
            ctx.beginPath(); ctx.moveTo(30, -4); ctx.lineTo(33, 0); ctx.lineTo(30, 4);
            ctx.lineTo(36, 2); ctx.lineTo(40, 0); ctx.lineTo(36, -2); ctx.closePath(); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawLightningRod(ctx, weapon, ball) {
            ctx.fillStyle = '#2a2a3a'; ctx.fillRect(-5, -3, 35, 6);
            const time = Date.now() / 50;
            ctx.strokeStyle = '#ffff00';
            ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                let x = 30, y = (i - 1) * 4;
                ctx.moveTo(x, y);
                for (let j = 0; j < 4; j++) {
                    x += 4; y += Math.sin(time + i + j) * 3;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.fillStyle = '#ffff44';
            ctx.beginPath(); ctx.arc(35, 0, 6, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawVoidOrb(ctx, weapon, ball) {
            ctx.fillStyle = '#1a0a2a'; ctx.fillRect(-5, -2, 30, 4);
            const time = Date.now() / 200;
            ctx.fillStyle = '#220033';
            ctx.shadowColor = '#8800ff'; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(35, 0, 12, 0, Math.PI * 2); ctx.fill();
            for (let i = 0; i < 6; i++) {
                const angle = time + (i / 6) * Math.PI * 2;
                const dist = 8 + Math.sin(time * 2 + i) * 2;
                ctx.fillStyle = '#aa44ff';
                ctx.beginPath();
                ctx.arc(35 + Math.cos(angle) * dist, Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.fillStyle = '#000000';
            ctx.beginPath(); ctx.arc(35, 0, 5, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawHealStaff(ctx, weapon, ball) {
            ctx.fillStyle = '#2a4a2a'; ctx.fillRect(-5, -2, 35, 4);
            const time = Date.now() / 150;
            ctx.fillStyle = '#44ff44';
            ctx.shadowColor = '#44ff44'; ctx.shadowBlur = 15;
            ctx.beginPath(); ctx.arc(38, 0, 8, 0, Math.PI * 2); ctx.fill();
            for (let i = 0; i < 5; i++) {
                const angle = time + (i / 5) * Math.PI * 2;
                const dist = 12 + Math.sin(time * 3) * 2;
                ctx.fillStyle = '#88ff88';
                ctx.beginPath();
                ctx.arc(38 + Math.cos(angle) * dist, Math.sin(angle) * dist, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(35, -5, 6, 10); ctx.fillRect(33, -2, 10, 4);
            ctx.shadowBlur = 0;
        }

        function drawSunStaff(ctx, weapon, ball) {
            ctx.fillStyle = '#4a3a1a'; ctx.fillRect(-5, -3, 40, 6);
            const time = Date.now() / 100;
            ctx.fillStyle = '#ffcc00';
            ctx.shadowColor = '#ffaa00'; ctx.shadowBlur = 25;
            ctx.beginPath(); ctx.arc(42, 0, 10, 0, Math.PI * 2); ctx.fill();
            for (let i = 0; i < 8; i++) {
                const angle = time * 0.5 + (i / 8) * Math.PI * 2;
                const len = 8 + Math.sin(time + i) * 2;
                ctx.strokeStyle = '#ffdd44'; ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(42 + Math.cos(angle) * 10, Math.sin(angle) * 10);
                ctx.lineTo(42 + Math.cos(angle) * (10 + len), Math.sin(angle) * (10 + len));
                ctx.stroke();
            }
            ctx.fillStyle = '#ffffff';
            ctx.beginPath(); ctx.arc(42, 0, 5, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawUnarmed(ctx, weapon, ball) {
            if (ball && ball.unarmedSpeed) {
                const intensity = Math.min(ball.unarmedSpeed / 10, 1);
                ctx.fillStyle = `rgba(255, ${Math.floor(100 + 155 * (1 - intensity))}, 0, ${0.3 + intensity * 0.4})`;
                ctx.shadowColor = '#ff4400';
                ctx.shadowBlur = 10 + intensity * 20;
                ctx.beginPath(); ctx.arc(0, 0, 25 + intensity * 10, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function drawArchangelMichael(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isSmite = ball && ball.abilityActive && ball.currentAbility === 'smite';
            const isShield = ball && ball.abilityActive && ball.currentAbility === 'holyshield';
            const isDash = ball && ball.abilityActive && ball.currentAbility === 'divinedash';
            const isRes = ball && ball.abilityActive && ball.currentAbility === 'resurrection';

            // Wings
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 15;
            for (let w = 0; w < 2; w++) {
                const side = w === 0 ? -1 : 1;
                ctx.beginPath();
                ctx.moveTo(-15, side * 5);
                for (let i = 0; i < 5; i++) {
                    const featherAngle = (i / 5) * 0.8 + 0.3;
                    const featherLen = 25 + i * 5;
                    const wave = Math.sin(time * 3 + i * 0.5) * 3;
                    ctx.lineTo(-15 - Math.cos(featherAngle * side) * featherLen, side * (10 + Math.sin(featherAngle) * featherLen + wave));
                }
                ctx.lineTo(-15, side * 15);
                ctx.closePath(); ctx.fill();
            }

            // Halo
            ctx.strokeStyle = '#ffd700';
            ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(-20, 0, 15, 5, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Holy shield effect
            if (isShield) {
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(0, 0, 45 + Math.sin(time * 5) * 3, 0, Math.PI * 2); ctx.stroke();
            }

            // Handle
            ctx.fillStyle = '#ffd700'; ctx.fillRect(-2, -4, 14, 8);
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 3; i++) { ctx.fillRect(i * 4, -4, 2, 8); }

            // Crossguard
            ctx.fillStyle = '#ffd700';
            ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(8, -12); ctx.lineTo(14, -8);
            ctx.lineTo(14, 8); ctx.lineTo(8, 12); ctx.closePath(); ctx.fill();

            // Blade
            const bladeGlow = isSmite || isDash || isRes;
            ctx.fillStyle = bladeGlow ? '#ffffff' : '#f0f0f0';
            ctx.shadowColor = bladeGlow ? '#ffffff' : '#ffd700';
            ctx.shadowBlur = bladeGlow ? 25 : 10;
            ctx.beginPath(); ctx.moveTo(14, -5); ctx.lineTo(50, -3); ctx.lineTo(58, 0);
            ctx.lineTo(50, 3); ctx.lineTo(14, 5); ctx.closePath(); ctx.fill();

            // Flames on blade
            for (let i = 0; i < 5; i++) {
                const fx = 20 + i * 8;
                const flicker = Math.sin(time * 10 + i * 2) * 2;
                ctx.fillStyle = i % 2 === 0 ? '#ffd700' : '#ffffff';
                ctx.beginPath();
                ctx.moveTo(fx, -4 + flicker); ctx.lineTo(fx + 4, -8 + flicker);
                ctx.lineTo(fx + 8, -4 + flicker); ctx.closePath(); ctx.fill();
                ctx.beginPath();
                ctx.moveTo(fx, 4 - flicker); ctx.lineTo(fx + 4, 8 - flicker);
                ctx.lineTo(fx + 8, 4 - flicker); ctx.closePath(); ctx.fill();
            }
            ctx.shadowBlur = 0;
        }

        function drawSolansSword(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isWhiteFlame = ball && ball.abilityActive && ball.currentAbility === 'whiteflamecharge';
            const isChargedBlow = ball && ball.abilityActive && ball.currentAbility === 'chargedblow';
            const isSoulbound = ball && ball.abilityActive && ball.currentAbility === 'soulbound';

            // Soulbound chains effect
            if (isSoulbound) {
                ctx.strokeStyle = 'rgba(200, 255, 255, 0.6)'; ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const offset = Math.sin(time * 5 + i * 2) * 5;
                    ctx.beginPath(); ctx.moveTo(-10, offset - 10 + i * 10);
                    ctx.lineTo(30, offset - 10 + i * 10); ctx.stroke();
                }
            }

            // Handle
            ctx.fillStyle = '#1a0a00'; ctx.fillRect(-2, -4, 14, 8);
            ctx.fillStyle = '#4a2800';
            for (let i = 0; i < 3; i++) { ctx.fillRect(i * 4, -4, 2, 8); }

            // Crossguard
            ctx.fillStyle = '#c9a227';
            ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 8;
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(6, -14); ctx.lineTo(14, -10);
            ctx.lineTo(14, 10); ctx.lineTo(6, 14); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#e8d280';
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(8, -10); ctx.lineTo(12, -7);
            ctx.lineTo(12, 7); ctx.lineTo(8, 10); ctx.closePath(); ctx.fill();

            // Blade
            const bladeColor = isWhiteFlame || isChargedBlow ? '#e0ffff' : '#d4d4d4';
            ctx.fillStyle = bladeColor;
            ctx.shadowColor = isWhiteFlame ? '#ffffff' : (isChargedBlow ? '#00ffff' : '#888');
            ctx.shadowBlur = isWhiteFlame || isChargedBlow ? 20 : 5;
            ctx.beginPath(); ctx.moveTo(14, -6); ctx.lineTo(48, -4); ctx.lineTo(58, 0);
            ctx.lineTo(48, 4); ctx.lineTo(14, 6); ctx.closePath(); ctx.fill();
            ctx.fillStyle = isWhiteFlame ? '#ffffff' : '#f0f0f0';
            ctx.beginPath(); ctx.moveTo(16, -2); ctx.lineTo(50, -1); ctx.lineTo(55, 0);
            ctx.lineTo(50, 1); ctx.lineTo(16, 2); ctx.closePath(); ctx.fill();

            // White flame effects
            if (isWhiteFlame || isChargedBlow) {
                for (let i = 0; i < 6; i++) {
                    const fx = 18 + i * 7;
                    const flicker = Math.sin(time * 12 + i * 1.5) * 3;
                    ctx.fillStyle = i % 2 === 0 ? '#ffffff' : '#e0ffff';
                    ctx.beginPath(); ctx.moveTo(fx, -5 + flicker);
                    ctx.lineTo(fx + 3, -10 + flicker); ctx.lineTo(fx + 6, -5 + flicker);
                    ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(fx, 5 - flicker);
                    ctx.lineTo(fx + 3, 10 - flicker); ctx.lineTo(fx + 6, 5 - flicker);
                    ctx.closePath(); ctx.fill();
                }
            }
            ctx.shadowBlur = 0;
        }

        function drawSuperman(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isFlying = ball && ball.abilityActive && ball.currentAbility === 'flight';
            const isHeatVision = ball && ball.abilityActive && ball.currentAbility === 'heatvision';
            const isSuperStrength = ball && ball.abilityActive && ball.currentAbility === 'superstrength';
            const isFreeze = ball && ball.abilityActive && ball.currentAbility === 'freezebreath';

            // Cape
            ctx.fillStyle = '#cc0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = isFlying ? 20 : 5;
            const capeWave = Math.sin(time * 4) * (isFlying ? 15 : 5);
            ctx.beginPath();
            ctx.moveTo(-10, -8);
            ctx.quadraticCurveTo(-35 + capeWave, 0, -40 + capeWave * 1.5, 20);
            ctx.lineTo(-30 + capeWave, 25);
            ctx.quadraticCurveTo(-20, 5, -10, 8);
            ctx.closePath();
            ctx.fill();

            // S symbol shield
            ctx.fillStyle = '#ffe100';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(5, -12);
            ctx.lineTo(20, -8);
            ctx.lineTo(25, 0);
            ctx.lineTo(20, 8);
            ctx.lineTo(5, 12);
            ctx.lineTo(0, 8);
            ctx.lineTo(-2, 0);
            ctx.lineTo(0, -8);
            ctx.closePath();
            ctx.fill();

            // S letter
            ctx.fillStyle = '#cc0000';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('S', 6, 6);

            // Heat vision beams
            if (isHeatVision) {
                ctx.strokeStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 3;
                for (let i = 0; i < 2; i++) {
                    const offsetY = i === 0 ? -5 : 5;
                    ctx.beginPath();
                    ctx.moveTo(25, offsetY);
                    ctx.lineTo(80, offsetY + (Math.random() - 0.5) * 10);
                    ctx.stroke();
                }
            }

            // Freeze breath effect
            if (isFreeze) {
                for (let i = 0; i < 5; i++) {
                    ctx.fillStyle = `rgba(150, 220, 255, ${0.6 - i * 0.1})`;
                    ctx.beginPath();
                    ctx.arc(30 + i * 10, Math.sin(time * 5 + i) * 5, 8 - i, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Super strength aura
            if (isSuperStrength) {
                ctx.strokeStyle = 'rgba(255, 225, 0, 0.5)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, 35 + Math.sin(time * 8) * 3, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function drawGojo(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isInfinity = ball && ball.abilityActive && ball.currentAbility === 'infinity';
            const isDomain = ball && ball.abilityActive && ball.currentAbility === 'domain';
            const isHollow = ball && ball.abilityActive && ball.currentAbility === 'hollowpurple';
            const isRed = ball && ball.abilityActive && ball.currentAbility === 'reversal';

            // Blindfold
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(-15, -6, 30, 12);
            ctx.fillStyle = '#000';
            ctx.fillRect(-12, -4, 24, 8);

            // Six Eyes glow (when blindfold is off during abilities)
            if (isDomain || isHollow) {
                ctx.fillStyle = '#00bfff';
                ctx.shadowColor = '#00bfff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(-5, 0, 4, 0, Math.PI * 2);
                ctx.arc(5, 0, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Infinity barrier
            if (isInfinity) {
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const radius = 30 + i * 8 + Math.sin(time * 3 + i) * 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Domain Expansion - Unlimited Void pattern
            if (isDomain) {
                ctx.fillStyle = 'rgba(0, 0, 50, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, 60, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#4444ff';
                ctx.shadowColor = '#0000ff';
                ctx.shadowBlur = 15;
                for (let i = 0; i < 8; i++) {
                    const angle = time + (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * 60, Math.sin(angle) * 60);
                    ctx.stroke();
                }
            }

            // Hollow Purple
            if (isHollow) {
                ctx.fillStyle = '#9932cc';
                ctx.shadowColor = '#9400d3';
                ctx.shadowBlur = 25;
                ctx.beginPath();
                ctx.arc(40, 0, 15 + Math.sin(time * 10) * 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Reversal Red
            if (isRed) {
                ctx.fillStyle = '#ff3333';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(35, 0, 12, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;
        }

        function drawSukuna(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isCleave = ball && ball.abilityActive && ball.currentAbility === 'cleave';
            const isDismantle = ball && ball.abilityActive && ball.currentAbility === 'dismantle';
            const isShrine = ball && ball.abilityActive && ball.currentAbility === 'shrine';
            const isFire = ball && ball.abilityActive && ball.currentAbility === 'openflame';

            // Four arms silhouette
            ctx.fillStyle = '#8b0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;

            // Extra arms
            for (let side of [-1, 1]) {
                ctx.beginPath();
                ctx.moveTo(0, side * 10);
                ctx.lineTo(-20, side * 20);
                ctx.lineTo(-25, side * 18);
                ctx.lineTo(-8, side * 8);
                ctx.closePath();
                ctx.fill();
            }

            // Mouth marking
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-5, 8);
            ctx.lineTo(5, 8);
            ctx.moveTo(-3, 10);
            ctx.lineTo(3, 10);
            ctx.stroke();

            // Cleave slashes
            if (isCleave) {
                ctx.strokeStyle = '#ff4444';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 3;
                for (let i = 0; i < 3; i++) {
                    const offset = (i - 1) * 15;
                    ctx.beginPath();
                    ctx.moveTo(20, -30 + offset);
                    ctx.lineTo(60, 30 + offset);
                    ctx.stroke();
                }
            }

            // Dismantle grid
            if (isDismantle) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.lineWidth = 1;
                for (let i = -3; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(20, i * 12);
                    ctx.lineTo(70, i * 12);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(30 + i * 8, -40);
                    ctx.lineTo(50 + i * 8, 40);
                    ctx.stroke();
                }
            }

            // Malevolent Shrine
            if (isShrine) {
                ctx.fillStyle = 'rgba(139, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, 80, 0, Math.PI * 2);
                ctx.fill();
                // Shrine torii gates
                ctx.strokeStyle = '#8b0000';
                ctx.lineWidth = 4;
                for (let i = 0; i < 4; i++) {
                    const angle = time * 0.5 + (i / 4) * Math.PI * 2;
                    const x = Math.cos(angle) * 60;
                    const y = Math.sin(angle) * 60;
                    ctx.beginPath();
                    ctx.moveTo(x - 8, y - 10);
                    ctx.lineTo(x - 8, y + 10);
                    ctx.moveTo(x + 8, y - 10);
                    ctx.lineTo(x + 8, y + 10);
                    ctx.moveTo(x - 10, y - 8);
                    ctx.lineTo(x + 10, y - 8);
                    ctx.stroke();
                }
            }

            // Open flame
            if (isFire) {
                for (let i = 0; i < 8; i++) {
                    const flicker = Math.sin(time * 15 + i) * 5;
                    ctx.fillStyle = i % 2 === 0 ? '#ff4500' : '#ff6600';
                    ctx.beginPath();
                    ctx.arc(30 + i * 5, flicker, 6 - i * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawJobApplication(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isReject = ball && ball.abilityActive && ball.currentAbility === 'reject';
            const isGhost = ball && ball.abilityActive && ball.currentAbility === 'ghost';
            const isOverqualified = ball && ball.abilityActive && ball.currentAbility === 'overqualified';
            const isExperience = ball && ball.abilityActive && ball.currentAbility === 'experience';

            // Paper document
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = isReject ? '#ff0000' : '#888';
            ctx.shadowBlur = 10;
            ctx.fillRect(-10, -20, 40, 50);

            // Paper lines
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(-5, -12 + i * 8);
                ctx.lineTo(25, -12 + i * 8);
                ctx.stroke();
            }

            // Red REJECTED stamp
            if (isReject || (!ball?.abilityActive)) {
                ctx.save();
                ctx.rotate(-0.3);
                ctx.fillStyle = '#ff0000';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(-5, -10, 45, 20);
                ctx.font = 'bold 10px Arial';
                ctx.fillText('REJECTED', 0, 4);
                ctx.restore();
            }

            // Ghost effect (no response)
            if (isGhost) {
                ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(45 + i * 12, Math.sin(time * 3 + i) * 5, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.font = '12px Arial';
                ctx.fillStyle = '#888';
                ctx.fillText('...', 50, 5);
            }

            // Overqualified rays
            if (isOverqualified) {
                ctx.strokeStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = time * 2 + (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(15, 5);
                    ctx.lineTo(15 + Math.cos(angle) * 40, 5 + Math.sin(angle) * 40);
                    ctx.stroke();
                }
            }

            // Experience needed spiral
            if (isExperience) {
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < 30; i++) {
                    const angle = i * 0.5 + time * 3;
                    const radius = i * 1.5;
                    const x = 15 + Math.cos(angle) * radius;
                    const y = 5 + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function drawDio(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isTimestop = ball && ball.abilityActive && ball.currentAbility === 'timestop';
            const isKnives = ball && ball.abilityActive && ball.currentAbility === 'knives';
            const isRoadroller = ball && ball.abilityActive && ball.currentAbility === 'roadroller';
            const isMuda = ball && ball.abilityActive && ball.currentAbility === 'mudamuda';

            // Menacing aura
            if (ball && ball.abilityActive) {
                ctx.strokeStyle = '#ffff00';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 3;
                for (let i = 0; i < 6; i++) {
                    const angle = time * 2 + (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 25, Math.sin(angle) * 25);
                    ctx.lineTo(Math.cos(angle) * 45, Math.sin(angle) * 45);
                    ctx.stroke();
                }
            }

            // The World stand silhouette behind
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(0, -15, 35, 0, Math.PI * 2);
            ctx.fill();

            // Dio head
            ctx.fillStyle = '#ffe4b5';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = isTimestop ? 30 : 10;
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();

            // Blonde hair
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, -8, 16, Math.PI, 0);
            ctx.fill();
            // Spiky hair
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(-12 + i * 6, -14);
                ctx.lineTo(-9 + i * 6, -28);
                ctx.lineTo(-6 + i * 6, -14);
                ctx.fill();
            }

            // Red eyes
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = isTimestop ? 15 : 5;
            ctx.beginPath();
            ctx.arc(-6, -2, 3, 0, Math.PI * 2);
            ctx.arc(6, -2, 3, 0, Math.PI * 2);
            ctx.fill();

            // ZA WARUDO effect
            if (isTimestop) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 25;
                for (let i = 0; i < 8; i++) {
                    const angle = i * Math.PI / 4;
                    const dist = 50 + Math.sin(time * 10) * 10;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = '#ffff00';
                ctx.fillText('ZA WARUDO', -30, -50);
            }

            // Knives
            if (isKnives) {
                ctx.fillStyle = '#c0c0c0';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 10;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + time * 3;
                    const dist = 35 + Math.sin(time * 5 + i) * 5;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(angle + Math.PI / 2);
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(2, 8);
                    ctx.lineTo(-2, 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Road Roller
            if (isRoadroller) {
                ctx.fillStyle = '#ffcc00';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 20;
                ctx.fillRect(-30, 25, 60, 25);
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(-20, 50, 12, 0, Math.PI * 2);
                ctx.arc(20, 50, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.fillText('WRYYY!', -15, 40);
            }

            // MUDA MUDA
            if (isMuda) {
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;
                for (let i = 0; i < 5; i++) {
                    const ox = Math.sin(time * 20 + i) * 20;
                    const oy = Math.cos(time * 20 + i * 2) * 20;
                    ctx.fillText('MUDA', ox - 15, oy);
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawBlackhole(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isSingularity = ball && ball.abilityActive && ball.currentAbility === 'singularity';
            const isEventHorizon = ball && ball.abilityActive && ball.currentAbility === 'eventhorizon';
            const isHawking = ball && ball.abilityActive && ball.currentAbility === 'hawking';
            const isCollapse = ball && ball.abilityActive && ball.currentAbility === 'collapse';

            // Gravitational lensing effect
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 5; i++) {
                const radius = 40 + i * 8 + Math.sin(time * 2 + i) * 3;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Accretion disk
            ctx.save();
            ctx.rotate(time * 0.5);
            const gradient = ctx.createRadialGradient(0, 0, 15, 0, 0, 45);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.3, 'rgba(255, 100, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 50, 0.9)');
            gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.6)');
            gradient.addColorStop(1, 'rgba(100, 0, 100, 0.3)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, 45, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Event horizon (black center)
            ctx.fillStyle = '#000000';
            ctx.shadowColor = '#000000';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();

            // Inner glow
            const innerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 18);
            innerGrad.addColorStop(0, 'rgba(50, 0, 80, 0.8)');
            innerGrad.addColorStop(1, 'rgba(0, 0, 0, 1)');
            ctx.fillStyle = innerGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();

            // Singularity pull effect
            if (isSingularity) {
                ctx.strokeStyle = '#ff00ff';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const startDist = 80;
                    const endDist = 20;
                    const progress = (time * 2 + i * 0.3) % 1;
                    const dist = startDist - (startDist - endDist) * progress;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Event horizon trap ring
            if (isEventHorizon) {
                ctx.strokeStyle = '#8800ff';
                ctx.shadowColor = '#8800ff';
                ctx.shadowBlur = 25;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(0, 0, 60 + Math.sin(time * 5) * 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Hawking radiation particles
            if (isHawking) {
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                for (let i = 0; i < 20; i++) {
                    const angle = time * 3 + (i / 20) * Math.PI * 2;
                    const dist = 20 + (time * 50 + i * 10) % 60;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Collapse implosion
            if (isCollapse) {
                ctx.strokeStyle = '#ffffff';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 30;
                ctx.lineWidth = 3;
                const collapseRadius = 100 - (time * 100 % 80);
                ctx.beginPath();
                ctx.arc(0, 0, collapseRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function drawNinja(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isShadowClone = ball && ball.abilityActive && ball.currentAbility === 'shadowclone';
            const isRasengan = ball && ball.abilityActive && ball.currentAbility === 'rasengan';
            const isChakram = ball && ball.abilityActive && ball.currentAbility === 'chakram';
            const isFireball = ball && ball.abilityActive && ball.currentAbility === 'fireballjutsu';

            // Headband
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(-18, -12, 36, 8);
            ctx.fillStyle = '#4a90d9';
            ctx.fillRect(-10, -11, 20, 6);
            // Leaf symbol
            ctx.strokeStyle = '#c0c0c0';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, -8, 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(0, -4);
            ctx.stroke();

            // Face/mask
            ctx.fillStyle = '#2d2d44';
            ctx.beginPath();
            ctx.arc(0, 2, 15, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(-6, 0, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(6, 0, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(-6, 0, 2, 0, Math.PI * 2);
            ctx.arc(6, 0, 2, 0, Math.PI * 2);
            ctx.fill();

            // Shadow clones effect
            if (isShadowClone) {
                ctx.globalAlpha = 0.4;
                for (let i = 0; i < 3; i++) {
                    const angle = time * 3 + (i / 3) * Math.PI * 2;
                    const dist = 35;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.fillStyle = '#2d2d44';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#4a90d9';
                    ctx.fillRect(-8, -10, 16, 5);
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }

            // Rasengan in hand
            if (isRasengan) {
                ctx.save();
                ctx.translate(25, 0);
                // Outer spiral
                ctx.strokeStyle = '#00bfff';
                ctx.shadowColor = '#00bfff';
                ctx.shadowBlur = 25;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    for (let j = 0; j < 30; j++) {
                        const angle = j * 0.4 + time * 10 + i * 2;
                        const radius = 5 + j * 0.4;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                // Core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Chakram spinning around
            if (isChakram) {
                ctx.strokeStyle = '#ff6600';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 3;
                for (let i = 0; i < 4; i++) {
                    const angle = time * 5 + (i / 4) * Math.PI * 2;
                    const x = Math.cos(angle) * 30;
                    const y = Math.sin(angle) * 30;
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    // Inner star
                    ctx.beginPath();
                    for (let j = 0; j < 6; j++) {
                        const a2 = (j / 6) * Math.PI * 2 + time * 8;
                        const r = j % 2 === 0 ? 6 : 3;
                        if (j === 0) ctx.moveTo(x + Math.cos(a2) * r, y + Math.sin(a2) * r);
                        else ctx.lineTo(x + Math.cos(a2) * r, y + Math.sin(a2) * r);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            // Fireball jutsu
            if (isFireball) {
                ctx.fillStyle = '#ff4400';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 30;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time * 4;
                    const dist = 30 + Math.sin(time * 10 + i) * 8;
                    const size = 10 + Math.sin(time * 8 + i * 2) * 4;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;
        }

        function drawCasinoBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isSlotRoll = ball && ball.abilityActive && ball.currentAbility === 'slotroll';
            const isChips = ball && ball.abilityActive && ball.currentAbility === 'chipbarrage';
            const isCards = ball && ball.abilityActive && ball.currentAbility === 'cardshark';
            const isHouse = ball && ball.abilityActive && ball.currentAbility === 'housewins';
            const hasJackpot = ball && ball.jackpotActive;

            // Jackpot glow effect
            if (hasJackpot) {
                ctx.strokeStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 30;
                ctx.lineWidth = 4;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 35 + i * 12 + Math.sin(time * 8) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Cash trail particles handled in update
            }

            // Slot machine body
            ctx.fillStyle = '#8b0000';
            ctx.shadowColor = hasJackpot ? '#ffd700' : '#ff0000';
            ctx.shadowBlur = hasJackpot ? 25 : 10;
            ctx.fillRect(-22, -25, 44, 50);

            // Gold trim
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-24, -27, 48, 4);
            ctx.fillRect(-24, 23, 48, 4);
            ctx.fillRect(-24, -27, 4, 54);
            ctx.fillRect(20, -27, 4, 54);

            // Slot window
            ctx.fillStyle = '#111';
            ctx.fillRect(-16, -15, 32, 20);

            // Slot symbols (spinning or result)
            if (isSlotRoll) {
                // Spinning effect
                const symbols = ['7', '$', '*', '#', '!'];
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let i = 0; i < 3; i++) {
                    const sym = symbols[Math.floor(time * 20 + i * 7) % symbols.length];
                    ctx.fillStyle = '#ff0';
                    ctx.fillText(sym, -10 + i * 10, -5);
                }
            } else if (hasJackpot) {
                // Jackpot display
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#ffd700';
                ctx.textAlign = 'center';
                ctx.fillText('777', 0, -5);
            } else {
                // Default display
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#0f0';
                ctx.textAlign = 'center';
                ctx.fillText('$ $ $', 0, -5);
            }

            // Lever
            ctx.fillStyle = '#444';
            ctx.fillRect(24, -10, 6, 25);
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(27, -12, 6, 0, Math.PI * 2);
            ctx.fill();

            // Chip barrage effect
            if (isChips) {
                const chipColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ffffff'];
                for (let i = 0; i < 8; i++) {
                    const angle = time * 5 + (i / 8) * Math.PI * 2;
                    const dist = 35 + Math.sin(time * 3 + i) * 5;
                    ctx.fillStyle = chipColors[i % chipColors.length];
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Card shark effect
            if (isCards) {
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 6; i++) {
                    const angle = time * 4 + (i / 6) * Math.PI * 2;
                    const dist = 40;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(angle + time * 3);
                    ctx.fillRect(-5, -7, 10, 14);
                    ctx.fillStyle = i % 2 === 0 ? '#ff0000' : '#000000';
                    ctx.font = '8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(i % 2 === 0 ? 'A' : 'K', 0, 3);
                    ctx.fillStyle = '#fff';
                    ctx.restore();
                }
            }

            // House wins effect
            if (isHouse) {
                ctx.strokeStyle = '#00ff00';
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 3;
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = '#00ff00';
                const texts = ['WIN', 'JACKPOT', 'BONUS'];
                for (let i = 0; i < 3; i++) {
                    const angle = time * 2 + (i / 3) * Math.PI * 2;
                    ctx.fillText(texts[i], Math.cos(angle) * 50 - 20, Math.sin(angle) * 50);
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawAmericanBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isShotgun = ball && ball.abilityActive && ball.currentAbility === 'shotgun';
            const isAR = ball && ball.abilityActive && ball.currentAbility === 'assaultrifle';
            const isGrenade = ball && ball.abilityActive && ball.currentAbility === 'grenadelauncher';
            const isAirSupport = ball && ball.airSupportActive;

            // American flag background circle
            ctx.save();
            ctx.beginPath();
            ctx.arc(0, 0, 22, 0, Math.PI * 2);
            ctx.clip();

            // Red and white stripes
            for (let i = 0; i < 7; i++) {
                ctx.fillStyle = i % 2 === 0 ? '#ff0000' : '#ffffff';
                ctx.fillRect(-25, -22 + i * 6.5, 50, 6.5);
            }

            // Blue corner with stars
            ctx.fillStyle = '#0000aa';
            ctx.fillRect(-25, -22, 20, 22);
            ctx.fillStyle = '#ffffff';
            ctx.font = '6px Arial';
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    ctx.fillText('*', -22 + col * 6, -16 + row * 7);
                }
            }
            ctx.restore();

            // Military helmet
            ctx.fillStyle = '#556b2f';
            ctx.beginPath();
            ctx.ellipse(0, -18, 18, 10, 0, Math.PI, 0);
            ctx.fill();

            // Gun (assault rifle shape)
            ctx.fillStyle = '#2f2f2f';
            ctx.save();
            ctx.rotate(0.3);
            ctx.fillRect(15, -5, 35, 8);
            ctx.fillRect(20, -12, 5, 12);
            ctx.fillRect(35, 3, 8, 10);
            ctx.restore();

            // Muzzle flash when shooting
            if (isShotgun || isAR) {
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ff8800';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(45, 0);
                ctx.lineTo(60, -10);
                ctx.lineTo(55, 0);
                ctx.lineTo(60, 10);
                ctx.closePath();
                ctx.fill();
            }

            // Grenade launcher smoke
            if (isGrenade) {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.arc(40 + i * 8, Math.sin(time * 5 + i) * 10, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Air support indicator
            if (isAirSupport) {
                ctx.strokeStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 3;
                // Target reticle
                ctx.beginPath();
                ctx.arc(0, 0, 50, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-60, 0); ctx.lineTo(60, 0);
                ctx.moveTo(0, -60); ctx.lineTo(0, 60);
                ctx.stroke();
                // Flashing warning
                if (Math.sin(time * 10) > 0) {
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = '#ff0000';
                    ctx.textAlign = 'center';
                    ctx.fillText('AIR SUPPORT', 0, -40);
                }
            }

            // Low HP warning (below 10%)
            if (ball && ball.health < ball.maxHealth * 0.1 && !ball.airSupportUsed) {
                ctx.strokeStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                const flash = Math.sin(time * 8) > 0;
                if (flash) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawDivinityBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isOmnipotent = ball && ball.omnipotentActive;
            const isAscended = ball && ball.ascended;
            const isCharming = ball && ball.charmActive;

            // Divine aura - outer glow rings
            for (let ring = 3; ring >= 1; ring--) {
                const pulse = Math.sin(time * 2 + ring) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 * pulse / ring})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, 25 + ring * 15, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Main body - radiant gold
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, '#fff8dc');
            gradient.addColorStop(0.7, '#ffd700');
            gradient.addColorStop(1, '#daa520');
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(0, 0, 24, 0, Math.PI * 2);
            ctx.fill();

            // Halo above
            ctx.strokeStyle = '#ffd700';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 20;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(0, -30, 18, 6, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Inner halo glow
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.ellipse(0, -30, 16, 5, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Angel wings
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            // Left wing
            ctx.save();
            ctx.translate(-20, 0);
            ctx.rotate(-0.3 + Math.sin(time * 3) * 0.1);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-25, -15, -40, -5);
            ctx.quadraticCurveTo(-35, 0, -40, 10);
            ctx.quadraticCurveTo(-25, 5, 0, 0);
            ctx.fill();
            // Wing feathers
            for (let f = 0; f < 4; f++) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.ellipse(-15 - f * 7, -5 + f * 3, 8, 3, -0.5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            // Right wing
            ctx.save();
            ctx.translate(20, 0);
            ctx.rotate(0.3 - Math.sin(time * 3) * 0.1);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(25, -15, 40, -5);
            ctx.quadraticCurveTo(35, 0, 40, 10);
            ctx.quadraticCurveTo(25, 5, 0, 0);
            ctx.fill();
            for (let f = 0; f < 4; f++) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.ellipse(15 + f * 7, -5 + f * 3, 8, 3, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Divine eye in center
            ctx.fillStyle = '#4169e1';
            ctx.shadowColor = '#4169e1';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(-2, -2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Holy symbols orbiting
            ctx.font = 'bold 10px Arial';
            ctx.fillStyle = '#ffd700';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const symbols = ['+', '*', '+', '*', '+', '*'];
            for (let i = 0; i < symbols.length; i++) {
                const angle = time * 1.5 + (i / symbols.length) * Math.PI * 2;
                const orbitX = Math.cos(angle) * 35;
                const orbitY = Math.sin(angle) * 35;
                ctx.fillText(symbols[i], orbitX, orbitY);
            }

            // Omnipotence effect - 10 ability circles
            if (isOmnipotent) {
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 + time;
                    const orbitX = Math.cos(angle) * 60;
                    const orbitY = Math.sin(angle) * 60;
                    ctx.fillStyle = `hsl(${i * 36}, 100%, 50%)`;
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(orbitX, orbitY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Power lines connecting to center
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 + time;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * 60, Math.sin(angle) * 60);
                    ctx.stroke();
                }
            }

            // Ascension effect - ethereal form
            if (isAscended) {
                ctx.globalAlpha = 0.5 + Math.sin(time * 5) * 0.3;
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 50;
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Charm effect - hearts emanating
            if (isCharming) {
                ctx.fillStyle = '#ff69b4';
                ctx.font = '12px Arial';
                for (let h = 0; h < 6; h++) {
                    const hAngle = time * 2 + h;
                    const hDist = 40 + Math.sin(time * 3 + h) * 10;
                    ctx.fillText('<3', Math.cos(hAngle) * hDist, Math.sin(hAngle) * hDist);
                }
            }

            // MYTHICAL text indicator
            if (Math.sin(time * 4) > 0.5) {
                ctx.font = 'bold 8px Arial';
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 10;
                ctx.textAlign = 'center';
                ctx.fillText('MYTHICAL', 0, 45);
            }

            ctx.shadowBlur = 0;
        }

        function drawArchmageBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isCasting = ball && ball.abilityActive;
            const hasZombies = ball && ball.zombieCount > 0;

            // Mystical aura rings
            for (let ring = 0; ring < 3; ring++) {
                const pulse = Math.sin(time * 2 + ring * 0.5) * 0.3 + 0.7;
                ctx.strokeStyle = `rgba(138, 43, 226, ${0.4 * pulse / (ring + 1)})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 28 + ring * 12, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Main body - deep purple magical orb
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 24);
            gradient.addColorStop(0, '#e0b0ff');
            gradient.addColorStop(0.4, '#9932cc');
            gradient.addColorStop(0.8, '#4b0082');
            gradient.addColorStop(1, '#1a0033');
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#9932cc';
            ctx.shadowBlur = 25;
            ctx.beginPath();
            ctx.arc(0, 0, 23, 0, Math.PI * 2);
            ctx.fill();

            // Wizard hat
            ctx.fillStyle = '#1a0033';
            ctx.beginPath();
            ctx.moveTo(-15, -18);
            ctx.lineTo(0, -50);
            ctx.lineTo(15, -18);
            ctx.closePath();
            ctx.fill();
            // Hat brim
            ctx.fillStyle = '#2d0052';
            ctx.beginPath();
            ctx.ellipse(0, -18, 20, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            // Hat band with star
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-12, -22, 24, 4);
            ctx.font = 'bold 8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('*', 0, -19);

            // Long beard
            ctx.fillStyle = '#cccccc';
            ctx.beginPath();
            ctx.moveTo(-8, 10);
            ctx.quadraticCurveTo(-12, 25, -5, 35);
            ctx.lineTo(5, 35);
            ctx.quadraticCurveTo(12, 25, 8, 10);
            ctx.closePath();
            ctx.fill();

            // Staff
            ctx.save();
            ctx.rotate(0.3 + Math.sin(time * 2) * 0.1);
            ctx.fillStyle = '#5c3d2e';
            ctx.fillRect(20, -40, 5, 70);
            // Staff orb
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(22, -45, 10, 0, Math.PI * 2);
            ctx.fill();
            // Inner glow
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(20, -47, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Arcane symbols orbiting
            ctx.font = '10px Arial';
            ctx.fillStyle = '#00ffff';
            const symbols = ['\u2605', '\u2606', '\u2726', '\u2727', '\u2728', '\u2729'];
            for (let i = 0; i < 6; i++) {
                const angle = time * 1.2 + (i / 6) * Math.PI * 2;
                const dist = 38 + Math.sin(time * 3 + i) * 5;
                const sx = Math.cos(angle) * dist;
                const sy = Math.sin(angle) * dist;
                ctx.fillText('*', sx, sy);
            }

            // Casting effect - magic circle beneath
            if (isCasting) {
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 3;
                const circleSize = 60 + Math.sin(time * 5) * 10;
                ctx.beginPath();
                ctx.arc(0, 0, circleSize, 0, Math.PI * 2);
                ctx.stroke();
                // Inner pattern
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 + time * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * circleSize, Math.sin(angle) * circleSize);
                    ctx.stroke();
                }
                // Runes
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = '#ff00ff';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 - time;
                    const rx = Math.cos(angle) * (circleSize - 10);
                    const ry = Math.sin(angle) * (circleSize - 10);
                    ctx.fillText('*', rx, ry);
                }
                ctx.restore();
            }

            // Zombie indicator
            if (hasZombies) {
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Zombies: ' + ball.zombieCount, 0, 55);
            }

            // Grand Disintegration charging indicator
            if (ball && ball.disintegrationReady) {
                ctx.strokeStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 30;
                ctx.lineWidth = 4;
                const pulse = Math.sin(time * 8) > 0;
                if (pulse) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 45, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.font = 'bold 8px Arial';
                    ctx.fillStyle = '#ff0000';
                    ctx.fillText('DISINTEGRATE', 0, -55);
                }
            }

            // MYTHICAL indicator
            if (Math.sin(time * 3) > 0.3) {
                ctx.font = 'bold 8px Arial';
                ctx.fillStyle = '#9932cc';
                ctx.shadowColor = '#9932cc';
                ctx.shadowBlur = 10;
                ctx.textAlign = 'center';
                ctx.fillText('MYTHICAL', 0, 65);
            }

            ctx.shadowBlur = 0;
        }

        function drawParadoxicalBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const phase = ball ? ball.paradoxPhase || 1 : 1;
            const isUltimate = ball && ball.ultimateActive;

            // Phase colors
            const phaseColors = {
                1: ['#00ffff', '#0088ff'],    // Cyan/Blue - Reality Warper
                2: ['#ff00ff', '#8800ff'],    // Magenta/Purple - Fractal Master
                3: ['#ffff00', '#ff8800']     // Yellow/Orange - Paradox Incarnate
            };
            const colors = phaseColors[phase] || phaseColors[1];

            // Outer fractal rings (more rings at higher phases)
            for (let ring = 0; ring < phase + 2; ring++) {
                const ringRadius = 35 + ring * 15;
                const segments = 6 + phase * 2;
                const rotation = time * (ring % 2 === 0 ? 1 : -1) * (0.5 + phase * 0.2);

                ctx.strokeStyle = colors[ring % 2];
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6 - ring * 0.1;

                ctx.beginPath();
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2 + rotation;
                    const wobble = Math.sin(time * 3 + i + ring) * 5;
                    const r = ringRadius + wobble;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Main body - impossible geometry (Penrose-inspired)
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, colors[0]);
            gradient.addColorStop(0.7, colors[1]);
            gradient.addColorStop(1, '#000000');

            ctx.fillStyle = gradient;
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 30 + phase * 10;
            ctx.beginPath();
            ctx.arc(0, 0, 24, 0, Math.PI * 2);
            ctx.fill();

            // Inner paradox symbol (infinity/mÃ¶bius)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            // Draw infinity symbol
            for (let t = 0; t < Math.PI * 2; t += 0.1) {
                const scale = 12;
                const x = Math.cos(t) * scale / (1 + Math.sin(t) * Math.sin(t));
                const y = Math.sin(t) * Math.cos(t) * scale / (1 + Math.sin(t) * Math.sin(t));
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Fractal triangles orbiting (SierpiÅ„ski inspired)
            ctx.fillStyle = colors[0];
            for (let i = 0; i < 3 + phase; i++) {
                const angle = time * 1.5 + (i / (3 + phase)) * Math.PI * 2;
                const dist = 40 + Math.sin(time * 2 + i) * 5;
                ctx.save();
                ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                ctx.rotate(time * 2 + i);
                // Draw small triangle
                ctx.beginPath();
                ctx.moveTo(0, -6);
                ctx.lineTo(5, 4);
                ctx.lineTo(-5, 4);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Eye of paradox in center (phase 2+)
            if (phase >= 2) {
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = colors[0];
                ctx.beginPath();
                ctx.arc(Math.sin(time * 2) * 2, 0, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Reality cracks (phase 3)
            if (phase >= 3) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 15;
                for (let crack = 0; crack < 5; crack++) {
                    const angle = (crack / 5) * Math.PI * 2 + time * 0.3;
                    const length = 60 + Math.sin(time * 4 + crack) * 20;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
                    // Jagged crack line
                    for (let j = 0; j < 4; j++) {
                        const dist = 30 + (j + 1) * (length - 30) / 4;
                        const offset = (Math.random() - 0.5) * 10;
                        ctx.lineTo(Math.cos(angle + offset * 0.02) * dist,
                                   Math.sin(angle + offset * 0.02) * dist + offset);
                    }
                    ctx.stroke();
                }
            }

            // Ultimate effect - reality tearing apart
            if (isUltimate) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 50;
                for (let tear = 0; tear < 8; tear++) {
                    const angle = (tear / 8) * Math.PI * 2 + time;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * 100, Math.sin(angle) * 100);
                    ctx.stroke();
                }
                // Warning text
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                if (Math.sin(time * 10) > 0) {
                    ctx.fillText('PARADOX', 0, -60);
                    ctx.fillText('COLLAPSE', 0, -48);
                }
            }

            // Phase indicator
            ctx.font = 'bold 8px Arial';
            ctx.fillStyle = colors[0];
            ctx.textAlign = 'center';
            ctx.shadowBlur = 5;
            ctx.fillText(`PHASE ${phase}`, 0, 50);

            // GODLY text
            if (Math.sin(time * 2) > 0) {
                ctx.font = 'bold 9px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = colors[0];
                ctx.shadowBlur = 15;
                ctx.fillText('GODLY', 0, 62);
            }

            ctx.shadowBlur = 0;
        }

        function drawParadoxicalBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const phase = ball ? ball.paradoxPhase || 1 : 1;
            const isUltimate = ball && ball.ultimateActive;

            // Phase colors
            const phaseColors = {
                1: ['#00ffff', '#0088ff'],    // Cyan/Blue - Reality Warper
                2: ['#ff00ff', '#8800ff'],    // Magenta/Purple - Fractal Master
                3: ['#ffff00', '#ff8800']     // Yellow/Orange - Paradox Incarnate
            };
            const colors = phaseColors[phase] || phaseColors[1];

            // Outer fractal rings (more rings at higher phases)
            for (let ring = 0; ring < phase + 2; ring++) {
                const ringRadius = 35 + ring * 15;
                const segments = 6 + phase * 2;
                const rotation = time * (ring % 2 === 0 ? 1 : -1) * (0.5 + phase * 0.2);

                ctx.strokeStyle = colors[ring % 2];
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6 - ring * 0.1;

                ctx.beginPath();
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2 + rotation;
                    const wobble = Math.sin(time * 3 + i + ring) * 5;
                    const r = ringRadius + wobble;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // Main body - impossible geometry (Penrose-inspired)
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, colors[0]);
            gradient.addColorStop(0.7, colors[1]);
            gradient.addColorStop(1, '#000000');

            ctx.fillStyle = gradient;
            ctx.shadowColor = colors[0];
            ctx.shadowBlur = 30 + phase * 10;
            ctx.beginPath();
            ctx.arc(0, 0, 24, 0, Math.PI * 2);
            ctx.fill();

            // Inner paradox symbol (infinity/mÃ¶bius)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            // Draw infinity symbol
            for (let t = 0; t < Math.PI * 2; t += 0.1) {
                const scale = 12;
                const x = Math.cos(t) * scale / (1 + Math.sin(t) * Math.sin(t));
                const y = Math.sin(t) * Math.cos(t) * scale / (1 + Math.sin(t) * Math.sin(t));
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Fractal triangles orbiting (SierpiÅ„ski inspired)
            ctx.fillStyle = colors[0];
            for (let i = 0; i < 3 + phase; i++) {
                const angle = time * 1.5 + (i / (3 + phase)) * Math.PI * 2;
                const dist = 40 + Math.sin(time * 2 + i) * 5;
                ctx.save();
                ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                ctx.rotate(time * 2 + i);
                // Draw small triangle
                ctx.beginPath();
                ctx.moveTo(0, -6);
                ctx.lineTo(5, 4);
                ctx.lineTo(-5, 4);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Eye of paradox in center (phase 2+)
            if (phase >= 2) {
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = colors[0];
                ctx.beginPath();
                ctx.arc(Math.sin(time * 2) * 2, 0, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Reality cracks (phase 3)
            if (phase >= 3) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 15;
                for (let crack = 0; crack < 5; crack++) {
                    const angle = (crack / 5) * Math.PI * 2 + time * 0.3;
                    const length = 60 + Math.sin(time * 4 + crack) * 20;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
                    // Jagged crack line
                    for (let j = 0; j < 4; j++) {
                        const dist = 30 + (j + 1) * (length - 30) / 4;
                        const offset = (Math.random() - 0.5) * 10;
                        ctx.lineTo(Math.cos(angle + offset * 0.02) * dist,
                                   Math.sin(angle + offset * 0.02) * dist + offset);
                    }
                    ctx.stroke();
                }
            }

            // Ultimate effect - reality tearing apart
            if (isUltimate) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 50;
                for (let tear = 0; tear < 8; tear++) {
                    const angle = (tear / 8) * Math.PI * 2 + time;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * 100, Math.sin(angle) * 100);
                    ctx.stroke();
                }
                // Warning text
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                if (Math.sin(time * 10) > 0) {
                    ctx.fillText('PARADOX', 0, -60);
                    ctx.fillText('COLLAPSE', 0, -48);
                }
            }

            // Phase indicator
            ctx.font = 'bold 8px Arial';
            ctx.fillStyle = colors[0];
            ctx.textAlign = 'center';
            ctx.shadowBlur = 5;
            ctx.fillText(`PHASE ${phase}`, 0, 50);

            // GODLY text
            if (Math.sin(time * 2) > 0) {
                ctx.font = 'bold 9px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = colors[0];
                ctx.shadowBlur = 15;
                ctx.fillText('GODLY', 0, 62);
            }

            ctx.shadowBlur = 0;
        }

        // THE ETERNAL - 5 Forms
        function drawEternal(ctx, weapon, ball) {
            const form = ball?.eternalForm || 1;
            const time = Date.now() / 1000;
            const x = 0, y = 0;
            const radius = 25;

            // Form-specific visuals
            switch(form) {
                case 1: // SEED - Small, dim
                    ctx.beginPath();
                    const seedGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    seedGrad.addColorStop(0, '#888');
                    seedGrad.addColorStop(0.7, '#555');
                    seedGrad.addColorStop(1, '#333');
                    ctx.fillStyle = seedGrad;
                    ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255,255,255,${0.2 + 0.1 * Math.sin(time * 2)})`;
                    ctx.lineWidth = 1;
                    ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                    break;

                case 2: // SPARK - Electric blue
                    const sparkGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    sparkGrad.addColorStop(0, '#fff');
                    sparkGrad.addColorStop(0.3, '#00ffff');
                    sparkGrad.addColorStop(0.7, '#0088ff');
                    sparkGrad.addColorStop(1, '#004488');
                    ctx.beginPath();
                    ctx.fillStyle = sparkGrad;
                    ctx.arc(0, 0, radius * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 4; i++) {
                        ctx.save();
                        ctx.rotate(time * 3 + i * Math.PI / 2);
                        ctx.beginPath();
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.moveTo(radius * 0.5, 0);
                        ctx.lineTo(radius * 0.7, 5);
                        ctx.lineTo(radius * 0.9, -3);
                        ctx.lineTo(radius * 1.2, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                    break;

                case 3: // FLAME - Fiery
                    const flameGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    flameGrad.addColorStop(0, '#fff');
                    flameGrad.addColorStop(0.2, '#ffff00');
                    flameGrad.addColorStop(0.5, '#ff8800');
                    flameGrad.addColorStop(0.8, '#ff0000');
                    flameGrad.addColorStop(1, '#880000');
                    ctx.beginPath();
                    ctx.fillStyle = flameGrad;
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate(time * 2 + i * Math.PI / 4);
                        ctx.beginPath();
                        const flicker = 0.8 + 0.4 * Math.sin(time * 10 + i);
                        ctx.fillStyle = `rgba(255,${150 + Math.random()*50},0,0.8)`;
                        ctx.ellipse(radius * 0.9, 0, radius * 0.15 * flicker, radius * 0.4 * flicker, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 4: // NOVA - Cosmic purple
                    const novaGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 1.2);
                    novaGrad.addColorStop(0, '#fff');
                    novaGrad.addColorStop(0.2, '#ff88ff');
                    novaGrad.addColorStop(0.5, '#aa00ff');
                    novaGrad.addColorStop(0.8, '#6600aa');
                    novaGrad.addColorStop(1, '#330066');
                    ctx.beginPath();
                    ctx.fillStyle = novaGrad;
                    ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 6; i++) {
                        ctx.save();
                        ctx.rotate(time + i * Math.PI / 3);
                        ctx.beginPath();
                        ctx.fillStyle = '#fff';
                        ctx.arc(radius * 1.3, 0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255,0,255,${0.5 + 0.3 * Math.sin(time * 4)})`;
                    ctx.lineWidth = 3;
                    ctx.arc(0, 0, radius * 1.4 + Math.sin(time * 3) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                    break;

                case 5: // ETERNAL - Ultimate golden
                    for (let r = 3; r >= 0; r--) {
                        ctx.beginPath();
                        const eternGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * (1.3 + r * 0.2));
                        eternGrad.addColorStop(0, r === 0 ? '#fff' : 'transparent');
                        eternGrad.addColorStop(0.3, `rgba(255,215,0,${0.8 - r * 0.15})`);
                        eternGrad.addColorStop(0.6, `rgba(255,165,0,${0.6 - r * 0.1})`);
                        eternGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = eternGrad;
                        ctx.arc(0, 0, radius * (1.3 + r * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    coreGrad.addColorStop(0, '#fff');
                    coreGrad.addColorStop(0.5, '#ffd700');
                    coreGrad.addColorStop(1, '#ff8800');
                    ctx.beginPath();
                    ctx.fillStyle = coreGrad;
                    ctx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Infinity symbol
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-15, 0);
                    ctx.bezierCurveTo(-15, -10, -5, -10, 0, 0);
                    ctx.bezierCurveTo(5, 10, 15, 10, 15, 0);
                    ctx.bezierCurveTo(15, -10, 5, -10, 0, 0);
                    ctx.bezierCurveTo(-5, 10, -15, 10, -15, 0);
                    ctx.stroke();
                    for (let i = 0; i < 12; i++) {
                        ctx.save();
                        ctx.rotate(time * 1.5 + i * Math.PI / 6);
                        const dist = radius * 1.5 + Math.sin(time * 5 + i) * 10;
                        ctx.beginPath();
                        ctx.fillStyle = `rgba(255,215,0,${0.5 + 0.5 * Math.sin(time * 3 + i)})`;
                        ctx.arc(dist, 0, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 6: // TRANSCENDENCE - Divine white/red apocalypse form
                    for (let r = 4; r >= 0; r--) {
                        ctx.beginPath();
                        const transGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * (2 + r * 0.4));
                        transGrad.addColorStop(0, r === 0 ? '#fff' : 'transparent');
                        transGrad.addColorStop(0.2, `rgba(255,255,255,${0.9 - r * 0.15})`);
                        transGrad.addColorStop(0.5, `rgba(255,0,0,${0.7 - r * 0.1})`);
                        transGrad.addColorStop(0.8, `rgba(139,0,0,${0.5 - r * 0.08})`);
                        transGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = transGrad;
                        ctx.arc(0, 0, radius * (2 + r * 0.4 + Math.sin(time * 4) * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    const transcendCore = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 1.5);
                    transcendCore.addColorStop(0, '#ffffff');
                    transcendCore.addColorStop(0.3, '#ffffcc');
                    transcendCore.addColorStop(0.6, '#ff6666');
                    transcendCore.addColorStop(1, '#8b0000');
                    ctx.beginPath();
                    ctx.fillStyle = transcendCore;
                    ctx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radius * 0.4, radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(radius * 0.1, -radius * 0.1, radius * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate(time * 2 + i * Math.PI / 4);
                        const orbitDist = radius * 2.2 + Math.sin(time * 6 + i * 2) * 15;
                        ctx.translate(orbitDist, 0);
                        ctx.rotate(-time * 2 - i * Math.PI / 4);
                        ctx.fillStyle = i % 2 === 0 ? '#ff0000' : '#ffffff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;
            }

            // Form indicator text
            ctx.fillStyle = form === 6 ? '#ff0000' : '#fff';
            ctx.font = form === 6 ? 'bold 14px Arial' : 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(form === 6 ? 'TRANSCENDENCE' : `FORM ${form}`, 0, radius + 15);
        }

        function drawLooksmaxxingBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isMewing = ball && ball.mewingActive;
            const isMogging = ball && ball.moggingActive;

            // Base - Chad jawline shaped ball
            const jawGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
            jawGrad.addColorStop(0, '#ffdbac');
            jawGrad.addColorStop(0.6, '#deb887');
            jawGrad.addColorStop(1, '#cd853f');

            // Main face
            ctx.beginPath();
            ctx.fillStyle = jawGrad;
            ctx.ellipse(0, 0, 25, 28, 0, 0, Math.PI * 2);
            ctx.fill();

            // Sharp jawline
            ctx.beginPath();
            ctx.fillStyle = '#deb887';
            ctx.moveTo(-20, 5);
            ctx.lineTo(0, 30);
            ctx.lineTo(20, 5);
            ctx.closePath();
            ctx.fill();

            // Hunter eyes
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-8, -5, 5, 2.5, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, -5, 5, 2.5, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Eyebrows (strong brow ridge)
            ctx.strokeStyle = '#4a3728';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-15, -12);
            ctx.lineTo(-3, -10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(15, -12);
            ctx.lineTo(3, -10);
            ctx.stroke();

            // Hair (styled)
            ctx.fillStyle = '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(0, -20, 22, 12, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Mewing indicator (tongue on roof of mouth = glowing jaw)
            if (isMewing) {
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-18, 8);
                ctx.lineTo(0, 28);
                ctx.lineTo(18, 8);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Mogging aura
            if (isMogging) {
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + 0.3 * Math.sin(time * 5)})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 40 + Math.sin(time * 3) * 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // "MAXXING" text when ability active
            if (ball && ball.abilityActive) {
                ctx.fillStyle = '#ff69b4';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MAXXING', 0, -40);
            }
        }

        function drawLightYagamiBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isWriting = ball && ball.writingDeathNote;

            // Pulsating red aura
            const pulseSize = 25 + Math.sin(time * 3) * 5;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize);
            gradient.addColorStop(0, 'rgba(139, 0, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 0, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(139, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
            ctx.fill();

            // Main body - suit
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();

            // Red tie
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.moveTo(-3, -8);
            ctx.lineTo(0, 10);
            ctx.lineTo(3, -8);
            ctx.closePath();
            ctx.fill();

            // Face/hair
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(0, -5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Brown hair
            ctx.fillStyle = '#4a3728';
            ctx.beginPath();
            ctx.ellipse(0, -10, 9, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (menacing)
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.arc(-3, -5, 2, 0, Math.PI * 2);
            ctx.arc(3, -5, 2, 0, Math.PI * 2);
            ctx.fill();

            // Smug smile when writing
            if (isWriting) {
                ctx.strokeStyle = '#8b0000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, -2, 4, 0.1, Math.PI - 0.1);
                ctx.stroke();
            }

            // Death Note book
            ctx.save();
            ctx.rotate(Math.sin(time * 2) * 0.1);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(20, -15, 18, 25);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 5px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('DEATH', 29, -5);
            ctx.fillText('NOTE', 29, 2);
            ctx.restore();

            // Writing animation
            if (isWriting) {
                // Pen
                ctx.fillStyle = '#333';
                ctx.save();
                ctx.translate(28, 5);
                ctx.rotate(time * 5);
                ctx.fillRect(-1, -8, 2, 16);
                ctx.restore();

                // Writing particles
                for (let i = 0; i < 3; i++) {
                    const angle = time * 3 + i * 2;
                    ctx.fillStyle = '#8b0000';
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.arc(28 + Math.cos(angle) * 10, Math.sin(angle) * 10,
                            2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Countdown text
                if (ball.deathNoteCountdown) {
                    const seconds = Math.ceil(ball.deathNoteCountdown / 60);
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = '#ff0000';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 5;
                    ctx.fillText(seconds, 0, 35);
                    ctx.shadowBlur = 0;
                }
            }

            // SECRET text
            if (Math.sin(time * 4) > 0) {
                ctx.font = 'bold 7px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                ctx.fillText('SECRET', 0, -25);
                ctx.shadowBlur = 0;
            }
        }

        function drawBowBall(ctx, weapon, ball) {
            // Wooden bow
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, 18, -Math.PI * 0.7, Math.PI * 0.7);
            ctx.stroke();
            // String
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, -17);
            ctx.lineTo(0, 17);
            ctx.stroke();
            // Arrow
            ctx.fillStyle = '#654321';
            ctx.fillRect(-2, -12, 4, 20);
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.moveTo(0, -18);
            ctx.lineTo(-4, -10);
            ctx.lineTo(4, -10);
            ctx.closePath();
            ctx.fill();
        }

        function drawLongswordBall(ctx, weapon, ball) {
            // Long blade
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(-3, -30, 6, 45);
            // Edge shine
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-1, -28, 2, 40);
            // Guard
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-12, 12, 24, 4);
            // Handle
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3, 16, 6, 12);
            // Pommel
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, 30, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawChainsawBall(ctx, weapon, ball) {
            const time = Date.now() / 50;
            // Body
            ctx.fillStyle = '#ff4500';
            ctx.fillRect(-8, -5, 16, 25);
            // Blade bar
            ctx.fillStyle = '#808080';
            ctx.fillRect(-4, -25, 8, 22);
            // Chain teeth (animated)
            ctx.fillStyle = '#404040';
            for (let i = 0; i < 6; i++) {
                const offset = (time + i * 3) % 18;
                ctx.fillRect(-6, -23 + offset, 2, 3);
                ctx.fillRect(4, -23 + offset, 2, 3);
            }
            // Handle
            ctx.fillStyle = '#333';
            ctx.fillRect(-10, 15, 20, 8);
        }

        function drawCrossbowBall(ctx, weapon, ball) {
            // Stock
            ctx.fillStyle = '#654321';
            ctx.fillRect(-3, 0, 6, 25);
            // Bow arms
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-20, -2, 40, 5);
            // String
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-18, 0);
            ctx.lineTo(0, 8);
            ctx.lineTo(18, 0);
            ctx.stroke();
            // Bolt
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(-1, -15, 2, 18);
            ctx.beginPath();
            ctx.moveTo(0, -18);
            ctx.lineTo(-3, -12);
            ctx.lineTo(3, -12);
            ctx.closePath();
            ctx.fill();
        }

        function drawFlailBall(ctx, weapon, ball) {
            const time = Date.now() / 200;
            const swingX = Math.sin(time) * 15;
            const swingY = Math.cos(time) * 10 - 20;
            // Handle
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3, 5, 6, 20);
            // Chain
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.lineTo(swingX, swingY);
            ctx.stroke();
            // Spiked ball
            ctx.fillStyle = '#404040';
            ctx.beginPath();
            ctx.arc(swingX, swingY, 10, 0, Math.PI * 2);
            ctx.fill();
            // Spikes
            ctx.fillStyle = '#c0c0c0';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(swingX + Math.cos(angle) * 8, swingY + Math.sin(angle) * 8);
                ctx.lineTo(swingX + Math.cos(angle) * 14, swingY + Math.sin(angle) * 14);
                ctx.lineTo(swingX + Math.cos(angle + 0.3) * 8, swingY + Math.sin(angle + 0.3) * 8);
                ctx.fill();
            }
        }

        function drawPickaxeBall(ctx, weapon, ball) {
            // Handle
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-2, -5, 4, 30);
            // Head
            ctx.fillStyle = '#4169e1';
            ctx.beginPath();
            ctx.moveTo(-20, -8);
            ctx.lineTo(0, -3);
            ctx.lineTo(20, -8);
            ctx.lineTo(15, -12);
            ctx.lineTo(0, -8);
            ctx.lineTo(-15, -12);
            ctx.closePath();
            ctx.fill();
            // Shine
            ctx.fillStyle = '#6495ed';
            ctx.beginPath();
            ctx.moveTo(-15, -10);
            ctx.lineTo(0, -6);
            ctx.lineTo(0, -8);
            ctx.lineTo(-12, -11);
            ctx.closePath();
            ctx.fill();
        }

        function drawWhipBall(ctx, weapon, ball) {
            const time = Date.now() / 100;
            // Handle
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(-3, 10, 6, 15);
            // Whip (wavy)
            ctx.strokeStyle = '#8b0000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 10);
            for (let i = 0; i < 8; i++) {
                const y = 10 - i * 5;
                const x = Math.sin(time + i) * (3 + i);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            // Tip
            ctx.lineWidth = 2;
            ctx.lineTo(Math.sin(time + 8) * 12, -35);
            ctx.stroke();
        }

        function drawSlingshotBall(ctx, weapon, ball) {
            // Y-frame
            ctx.fillStyle = '#d2691e';
            ctx.fillRect(-2, 5, 4, 20);
            ctx.fillRect(-12, -15, 5, 22);
            ctx.fillRect(7, -15, 5, 22);
            // Bands
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, -13);
            ctx.lineTo(0, 0);
            ctx.lineTo(10, -13);
            ctx.stroke();
            // Rock in pouch
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBoomerangBall(ctx, weapon, ball) {
            const time = Date.now() / 300;
            ctx.save();
            ctx.rotate(time);
            // Boomerang shape
            ctx.fillStyle = '#daa520';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-15, -20, -5, -25);
            ctx.quadraticCurveTo(5, -20, 0, 0);
            ctx.quadraticCurveTo(20, -15, 25, -5);
            ctx.quadraticCurveTo(20, 5, 0, 0);
            ctx.fill();
            // Stripes
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-3, -10);
            ctx.lineTo(-3, -20);
            ctx.moveTo(10, -5);
            ctx.lineTo(18, -5);
            ctx.stroke();
            ctx.restore();
        }

        function drawTorchBall(ctx, weapon, ball) {
            const time = Date.now() / 100;
            // Handle
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3, 5, 6, 20);
            // Wrap
            ctx.fillStyle = '#ddd';
            ctx.fillRect(-4, -5, 8, 12);
            // Fire (animated)
            ctx.fillStyle = '#ff6600';
            for (let i = 0; i < 5; i++) {
                const flicker = Math.sin(time * 2 + i) * 3;
                const height = 12 + Math.sin(time + i * 0.5) * 4;
                ctx.beginPath();
                ctx.moveTo(-6 + i * 3 + flicker, -5);
                ctx.quadraticCurveTo(-4 + i * 3, -5 - height, -3 + i * 3 + flicker, -5);
                ctx.fill();
            }
            // Inner flame
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.moveTo(-2, -5);
            ctx.quadraticCurveTo(0, -15 + Math.sin(time * 3) * 2, 2, -5);
            ctx.fill();
        }

        // THE ETERNAL - 5 Forms
        function drawEternal(ctx, weapon, ball) {
            const form = ball?.eternalForm || 1;
            const time = Date.now() / 1000;
            const x = 0, y = 0;
            const radius = 25;

            // Form-specific visuals
            switch(form) {
                case 1: // SEED - Small, dim
                    ctx.beginPath();
                    const seedGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    seedGrad.addColorStop(0, '#888');
                    seedGrad.addColorStop(0.7, '#555');
                    seedGrad.addColorStop(1, '#333');
                    ctx.fillStyle = seedGrad;
                    ctx.arc(0, 0, radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255,255,255,${0.2 + 0.1 * Math.sin(time * 2)})`;
                    ctx.lineWidth = 1;
                    ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                    break;

                case 2: // SPARK - Electric blue
                    const sparkGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    sparkGrad.addColorStop(0, '#fff');
                    sparkGrad.addColorStop(0.3, '#00ffff');
                    sparkGrad.addColorStop(0.7, '#0088ff');
                    sparkGrad.addColorStop(1, '#004488');
                    ctx.beginPath();
                    ctx.fillStyle = sparkGrad;
                    ctx.arc(0, 0, radius * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 4; i++) {
                        ctx.save();
                        ctx.rotate(time * 3 + i * Math.PI / 2);
                        ctx.beginPath();
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.moveTo(radius * 0.5, 0);
                        ctx.lineTo(radius * 0.7, 5);
                        ctx.lineTo(radius * 0.9, -3);
                        ctx.lineTo(radius * 1.2, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                    break;

                case 3: // FLAME - Fiery
                    const flameGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    flameGrad.addColorStop(0, '#fff');
                    flameGrad.addColorStop(0.2, '#ffff00');
                    flameGrad.addColorStop(0.5, '#ff8800');
                    flameGrad.addColorStop(0.8, '#ff0000');
                    flameGrad.addColorStop(1, '#880000');
                    ctx.beginPath();
                    ctx.fillStyle = flameGrad;
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate(time * 2 + i * Math.PI / 4);
                        ctx.beginPath();
                        const flicker = 0.8 + 0.4 * Math.sin(time * 10 + i);
                        ctx.fillStyle = `rgba(255,${150 + Math.random()*50},0,0.8)`;
                        ctx.ellipse(radius * 0.9, 0, radius * 0.15 * flicker, radius * 0.4 * flicker, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 4: // NOVA - Cosmic purple
                    const novaGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 1.2);
                    novaGrad.addColorStop(0, '#fff');
                    novaGrad.addColorStop(0.2, '#ff88ff');
                    novaGrad.addColorStop(0.5, '#aa00ff');
                    novaGrad.addColorStop(0.8, '#6600aa');
                    novaGrad.addColorStop(1, '#330066');
                    ctx.beginPath();
                    ctx.fillStyle = novaGrad;
                    ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 6; i++) {
                        ctx.save();
                        ctx.rotate(time + i * Math.PI / 3);
                        ctx.beginPath();
                        ctx.fillStyle = '#fff';
                        ctx.arc(radius * 1.3, 0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255,0,255,${0.5 + 0.3 * Math.sin(time * 4)})`;
                    ctx.lineWidth = 3;
                    ctx.arc(0, 0, radius * 1.4 + Math.sin(time * 3) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                    break;

                case 5: // ETERNAL - Ultimate golden
                    for (let r = 3; r >= 0; r--) {
                        ctx.beginPath();
                        const eternGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * (1.3 + r * 0.2));
                        eternGrad.addColorStop(0, r === 0 ? '#fff' : 'transparent');
                        eternGrad.addColorStop(0.3, `rgba(255,215,0,${0.8 - r * 0.15})`);
                        eternGrad.addColorStop(0.6, `rgba(255,165,0,${0.6 - r * 0.1})`);
                        eternGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = eternGrad;
                        ctx.arc(0, 0, radius * (1.3 + r * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    coreGrad.addColorStop(0, '#fff');
                    coreGrad.addColorStop(0.5, '#ffd700');
                    coreGrad.addColorStop(1, '#ff8800');
                    ctx.beginPath();
                    ctx.fillStyle = coreGrad;
                    ctx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    // Infinity symbol
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-15, 0);
                    ctx.bezierCurveTo(-15, -10, -5, -10, 0, 0);
                    ctx.bezierCurveTo(5, 10, 15, 10, 15, 0);
                    ctx.bezierCurveTo(15, -10, 5, -10, 0, 0);
                    ctx.bezierCurveTo(-5, 10, -15, 10, -15, 0);
                    ctx.stroke();
                    for (let i = 0; i < 12; i++) {
                        ctx.save();
                        ctx.rotate(time * 1.5 + i * Math.PI / 6);
                        const dist = radius * 1.5 + Math.sin(time * 5 + i) * 10;
                        ctx.beginPath();
                        ctx.fillStyle = `rgba(255,215,0,${0.5 + 0.5 * Math.sin(time * 3 + i)})`;
                        ctx.arc(dist, 0, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;

                case 6: // TRANSCENDENCE - Divine white/red apocalypse form
                    for (let r = 4; r >= 0; r--) {
                        ctx.beginPath();
                        const transGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * (2 + r * 0.4));
                        transGrad.addColorStop(0, r === 0 ? '#fff' : 'transparent');
                        transGrad.addColorStop(0.2, `rgba(255,255,255,${0.9 - r * 0.15})`);
                        transGrad.addColorStop(0.5, `rgba(255,0,0,${0.7 - r * 0.1})`);
                        transGrad.addColorStop(0.8, `rgba(139,0,0,${0.5 - r * 0.08})`);
                        transGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = transGrad;
                        ctx.arc(0, 0, radius * (2 + r * 0.4 + Math.sin(time * 4) * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    const transcendCore = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 1.5);
                    transcendCore.addColorStop(0, '#ffffff');
                    transcendCore.addColorStop(0.3, '#ffffcc');
                    transcendCore.addColorStop(0.6, '#ff6666');
                    transcendCore.addColorStop(1, '#8b0000');
                    ctx.beginPath();
                    ctx.fillStyle = transcendCore;
                    ctx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radius * 0.4, radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(radius * 0.1, -radius * 0.1, radius * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate(time * 2 + i * Math.PI / 4);
                        const orbitDist = radius * 2.2 + Math.sin(time * 6 + i * 2) * 15;
                        ctx.translate(orbitDist, 0);
                        ctx.rotate(-time * 2 - i * Math.PI / 4);
                        ctx.fillStyle = i % 2 === 0 ? '#ff0000' : '#ffffff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                    break;
            }

            // Form indicator text
            ctx.fillStyle = form === 6 ? '#ff0000' : '#fff';
            ctx.font = form === 6 ? 'bold 14px Arial' : 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(form === 6 ? 'TRANSCENDENCE' : `FORM ${form}`, 0, radius + 15);
        }

        function drawLooksmaxxingBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isMewing = ball && ball.mewingActive;
            const isMogging = ball && ball.moggingActive;

            // Base - Chad jawline shaped ball
            const jawGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
            jawGrad.addColorStop(0, '#ffdbac');
            jawGrad.addColorStop(0.6, '#deb887');
            jawGrad.addColorStop(1, '#cd853f');

            // Main face
            ctx.beginPath();
            ctx.fillStyle = jawGrad;
            ctx.ellipse(0, 0, 25, 28, 0, 0, Math.PI * 2);
            ctx.fill();

            // Sharp jawline
            ctx.beginPath();
            ctx.fillStyle = '#deb887';
            ctx.moveTo(-20, 5);
            ctx.lineTo(0, 30);
            ctx.lineTo(20, 5);
            ctx.closePath();
            ctx.fill();

            // Hunter eyes
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-8, -5, 5, 2.5, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, -5, 5, 2.5, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Eyebrows (strong brow ridge)
            ctx.strokeStyle = '#4a3728';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-15, -12);
            ctx.lineTo(-3, -10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(15, -12);
            ctx.lineTo(3, -10);
            ctx.stroke();

            // Hair (styled)
            ctx.fillStyle = '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(0, -20, 22, 12, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Mewing indicator (tongue on roof of mouth = glowing jaw)
            if (isMewing) {
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-18, 8);
                ctx.lineTo(0, 28);
                ctx.lineTo(18, 8);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Mogging aura
            if (isMogging) {
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + 0.3 * Math.sin(time * 5)})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 40 + Math.sin(time * 3) * 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // "MAXXING" text when ability active
            if (ball && ball.abilityActive) {
                ctx.fillStyle = '#ff69b4';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('MAXXING', 0, -40);
            }
        }

        function drawLightYagamiBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isWriting = ball && ball.writingDeathNote;

            // Pulsating red aura
            const pulseSize = 25 + Math.sin(time * 3) * 5;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize);
            gradient.addColorStop(0, 'rgba(139, 0, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 0, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(139, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
            ctx.fill();

            // Main body - suit
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(0, 0, 18, 0, Math.PI * 2);
            ctx.fill();

            // Red tie
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.moveTo(-3, -8);
            ctx.lineTo(0, 10);
            ctx.lineTo(3, -8);
            ctx.closePath();
            ctx.fill();

            // Face/hair
            ctx.fillStyle = '#d4a574';
            ctx.beginPath();
            ctx.arc(0, -5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Brown hair
            ctx.fillStyle = '#4a3728';
            ctx.beginPath();
            ctx.ellipse(0, -10, 9, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (menacing)
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.arc(-3, -5, 2, 0, Math.PI * 2);
            ctx.arc(3, -5, 2, 0, Math.PI * 2);
            ctx.fill();

            // Smug smile when writing
            if (isWriting) {
                ctx.strokeStyle = '#8b0000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, -2, 4, 0.1, Math.PI - 0.1);
                ctx.stroke();
            }

            // Death Note book
            ctx.save();
            ctx.rotate(Math.sin(time * 2) * 0.1);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(20, -15, 18, 25);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 5px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('DEATH', 29, -5);
            ctx.fillText('NOTE', 29, 2);
            ctx.restore();

            // Writing animation
            if (isWriting) {
                // Pen
                ctx.fillStyle = '#333';
                ctx.save();
                ctx.translate(28, 5);
                ctx.rotate(time * 5);
                ctx.fillRect(-1, -8, 2, 16);
                ctx.restore();

                // Writing particles
                for (let i = 0; i < 3; i++) {
                    const angle = time * 3 + i * 2;
                    ctx.fillStyle = '#8b0000';
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.arc(28 + Math.cos(angle) * 10, Math.sin(angle) * 10,
                            2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Countdown text
                if (ball.deathNoteCountdown) {
                    const seconds = Math.ceil(ball.deathNoteCountdown / 60);
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = '#ff0000';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#000';
                    ctx.shadowBlur = 5;
                    ctx.fillText(seconds, 0, 35);
                    ctx.shadowBlur = 0;
                }
            }

            // SECRET text
            if (Math.sin(time * 4) > 0) {
                ctx.font = 'bold 7px Arial';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                ctx.fillText('SECRET', 0, -25);
                ctx.shadowBlur = 0;
            }
        }

        function drawBowBall(ctx, weapon, ball) {
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, 18, -Math.PI * 0.7, Math.PI * 0.7);
            ctx.stroke();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, -17);
            ctx.lineTo(0, 17);
            ctx.stroke();
            ctx.fillStyle = '#654321';
            ctx.fillRect(-2, -12, 4, 20);
            ctx.fillStyle = '#c0c0c0';
            ctx.beginPath();
            ctx.moveTo(0, -18);
            ctx.lineTo(-4, -10);
            ctx.lineTo(4, -10);
            ctx.closePath();
            ctx.fill();
        }

        function drawLongswordBall(ctx, weapon, ball) {
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(-3, -30, 6, 45);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-1, -28, 2, 40);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-12, 12, 24, 4);
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3, 16, 6, 12);
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(0, 30, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawChainsawBall(ctx, weapon, ball) {
            const time = Date.now() / 50;
            ctx.fillStyle = '#ff4500';
            ctx.fillRect(-8, -5, 16, 25);
            ctx.fillStyle = '#808080';
            ctx.fillRect(-4, -25, 8, 22);
            ctx.fillStyle = '#404040';
            for (let i = 0; i < 6; i++) {
                const offset = (time + i * 3) % 18;
                ctx.fillRect(-6, -23 + offset, 2, 3);
                ctx.fillRect(4, -23 + offset, 2, 3);
            }
            ctx.fillStyle = '#333';
            ctx.fillRect(-10, 15, 20, 8);
        }

        function drawCrossbowBall(ctx, weapon, ball) {
            ctx.fillStyle = '#654321';
            ctx.fillRect(-3, 0, 6, 25);
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-20, -2, 40, 5);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-18, 0);
            ctx.lineTo(0, 8);
            ctx.lineTo(18, 0);
            ctx.stroke();
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(-1, -15, 2, 18);
            ctx.beginPath();
            ctx.moveTo(0, -18);
            ctx.lineTo(-3, -12);
            ctx.lineTo(3, -12);
            ctx.closePath();
            ctx.fill();
        }

        function drawFlailBall(ctx, weapon, ball) {
            const time = Date.now() / 200;
            const swingX = Math.sin(time) * 15;
            const swingY = Math.cos(time) * 10 - 20;
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3, 5, 6, 20);
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.lineTo(swingX, swingY);
            ctx.stroke();
            ctx.fillStyle = '#404040';
            ctx.beginPath();
            ctx.arc(swingX, swingY, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#c0c0c0';
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(swingX + Math.cos(angle) * 8, swingY + Math.sin(angle) * 8);
                ctx.lineTo(swingX + Math.cos(angle) * 14, swingY + Math.sin(angle) * 14);
                ctx.lineTo(swingX + Math.cos(angle + 0.3) * 8, swingY + Math.sin(angle + 0.3) * 8);
                ctx.fill();
            }
        }

        function drawMaceBall(ctx, weapon, ball) {
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3, 5, 6, 22);
            ctx.fillStyle = '#4169e1';
            ctx.beginPath();
            ctx.arc(0, -5, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#c0c0c0';
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 12, -5 + Math.sin(angle) * 12);
                ctx.lineTo(Math.cos(angle) * 20, -5 + Math.sin(angle) * 20);
                ctx.lineTo(Math.cos(angle + 0.2) * 12, -5 + Math.sin(angle + 0.2) * 12);
                ctx.fill();
            }
        }

        function drawWhipBall(ctx, weapon, ball) {
            const time = Date.now() / 100;
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(-3, 10, 6, 15);
            ctx.strokeStyle = '#8b0000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 10);
            for (let i = 0; i < 8; i++) {
                const y = 10 - i * 5;
                const x = Math.sin(time + i) * (3 + i);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.lineWidth = 2;
            ctx.lineTo(Math.sin(time + 8) * 12, -35);
            ctx.stroke();
        }

        function drawSlingshotBall(ctx, weapon, ball) {
            ctx.fillStyle = '#d2691e';
            ctx.fillRect(-2, 5, 4, 20);
            ctx.fillRect(-12, -15, 5, 22);
            ctx.fillRect(7, -15, 5, 22);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, -13);
            ctx.lineTo(0, 0);
            ctx.lineTo(10, -13);
            ctx.stroke();
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBoomerangBall(ctx, weapon, ball) {
            const time = Date.now() / 300;
            ctx.save();
            ctx.rotate(time);
            ctx.fillStyle = '#daa520';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-15, -20, -5, -25);
            ctx.quadraticCurveTo(5, -20, 0, 0);
            ctx.quadraticCurveTo(20, -15, 25, -5);
            ctx.quadraticCurveTo(20, 5, 0, 0);
            ctx.fill();
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-3, -10);
            ctx.lineTo(-3, -20);
            ctx.moveTo(10, -5);
            ctx.lineTo(18, -5);
            ctx.stroke();
            ctx.restore();
        }

        function drawTorchBall(ctx, weapon, ball) {
            const time = Date.now() / 100;
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-3, 5, 6, 20);
            ctx.fillStyle = '#ddd';
            ctx.fillRect(-4, -5, 8, 12);
            ctx.fillStyle = '#ff6600';
            for (let i = 0; i < 5; i++) {
                const flicker = Math.sin(time * 2 + i) * 3;
                const height = 12 + Math.sin(time + i * 0.5) * 4;
                ctx.beginPath();
                ctx.moveTo(-6 + i * 3 + flicker, -5);
                ctx.quadraticCurveTo(-4 + i * 3, -5 - height, -3 + i * 3 + flicker, -5);
                ctx.fill();
            }
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.moveTo(-2, -5);
            ctx.quadraticCurveTo(0, -15 + Math.sin(time * 3) * 2, 2, -5);
            ctx.fill();
        }

        function drawMoneyBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isFactory = ball && ball.abilityActive && ball.currentAbility === 'factory';
            const isMoneyThrow = ball && ball.abilityActive && ball.currentAbility === 'moneythrow';
            const isBodyguard = ball && ball.abilityActive && ball.currentAbility === 'bodyguard';
            const isBailout = ball && ball.abilityActive && ball.currentAbility === 'bailout';

            // Top hat
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(-12, -35, 24, 20);
            ctx.fillRect(-18, -18, 36, 6);

            // Monocle
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(10, -2, 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(18, -2);
            ctx.lineTo(25, 10);
            ctx.stroke();

            // Mustache
            ctx.fillStyle = '#4a3728';
            ctx.beginPath();
            ctx.ellipse(-8, 8, 8, 4, -0.3, 0, Math.PI * 2);
            ctx.ellipse(8, 8, 8, 4, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Dollar sign on body
            ctx.fillStyle = '#00aa00';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('$', 0, 5);

            // Factory smoke
            if (isFactory) {
                ctx.fillStyle = 'rgba(80, 80, 80, 0.6)';
                for (let i = 0; i < 5; i++) {
                    const smokeY = -40 - (time * 30 + i * 20) % 60;
                    const smokeX = Math.sin(time * 2 + i) * 10;
                    ctx.beginPath();
                    ctx.arc(smokeX, smokeY, 8 + i * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Money flying around
            if (isMoneyThrow) {
                ctx.fillStyle = '#00aa00';
                ctx.font = '14px Arial';
                for (let i = 0; i < 8; i++) {
                    const angle = time * 4 + (i / 8) * Math.PI * 2;
                    const dist = 30 + Math.sin(time * 3 + i) * 10;
                    ctx.fillText('$', Math.cos(angle) * dist, Math.sin(angle) * dist);
                }
            }

            // Bodyguard silhouettes
            if (isBodyguard) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                for (let i = 0; i < 3; i++) {
                    const angle = time + (i / 3) * Math.PI * 2;
                    const dist = 40;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(Math.cos(angle) * dist - 6, Math.sin(angle) * dist + 8, 12, 15);
                }
            }

            // Bailout golden aura
            if (isBailout) {
                ctx.strokeStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 3;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 30 + i * 15 + Math.sin(time * 5) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawSimonBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const spiralActive = ball && ball.spiralPowerActive;
            const rageMode = ball && ball.whoTheHellActive;
            const hpPercent = ball ? ball.health / ball.maxHealth : 1;

            // Spiral energy intensity based on low HP
            const spiralIntensity = spiralActive ? (1 - hpPercent) * 2 + 1 : 1;

            // Base - Blue coat with spiral energy
            ctx.save();

            // Spiral aura (more intense at low HP)
            if (spiralActive || rageMode) {
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.strokeStyle = rageMode ?
                        `rgba(255, ${100 + i * 50}, 0, ${0.5 - i * 0.15})` :
                        `rgba(0, 255, 100, ${0.6 - i * 0.15})`;
                    ctx.lineWidth = 3 - i;
                    const radius = 35 + i * 10 + Math.sin(time * 5) * 5;
                    // Spiral pattern
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 4; a += 0.1) {
                        const r = radius * (a / (Math.PI * 4)) * spiralIntensity;
                        const x = Math.cos(a + time * 3) * r;
                        const y = Math.sin(a + time * 3) * r;
                        if (a === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }

            // Body - Blue jumpsuit
            const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            bodyGrad.addColorStop(0, rageMode ? '#ff6600' : '#4169e1');
            bodyGrad.addColorStop(0.7, rageMode ? '#cc3300' : '#1e3a8a');
            bodyGrad.addColorStop(1, rageMode ? '#991100' : '#0f1f4a');
            ctx.beginPath();
            ctx.fillStyle = bodyGrad;
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();

            // Goggles on forehead
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.ellipse(-8, -15, 6, 4, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, -15, 6, 4, 0.2, 0, Math.PI * 2);
            ctx.fill();
            // Goggle lenses
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.ellipse(-8, -15, 4, 2.5, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(8, -15, 4, 2.5, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Face
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(0, -2, 12, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (determined look)
            ctx.fillStyle = rageMode ? '#ff0000' : '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-4, -4, 2, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(4, -4, 2, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Spiral mark/core drill pendant
            ctx.fillStyle = '#00ff00';
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = rageMode ? 20 : 10;
            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.lineTo(-4, 12);
            ctx.lineTo(0, 20);
            ctx.lineTo(4, 12);
            ctx.closePath();
            ctx.fill();

            // Drill grooves on pendant
            ctx.strokeStyle = '#003300';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-2, 10);
            ctx.lineTo(2, 14);
            ctx.moveTo(-2, 14);
            ctx.lineTo(2, 18);
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Wild blue hair
            ctx.fillStyle = '#1e3a8a';
            ctx.beginPath();
            ctx.moveTo(-12, -10);
            ctx.quadraticCurveTo(-15, -25, -5, -22);
            ctx.quadraticCurveTo(0, -28, 5, -22);
            ctx.quadraticCurveTo(15, -25, 12, -10);
            ctx.closePath();
            ctx.fill();

            ctx.restore();

            // HP-based spiral particles
            if (ball && hpPercent < 0.5) {
                if (Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    particles.push({
                        x: ball.x + Math.cos(angle) * 30,
                        y: ball.y + Math.sin(angle) * 30,
                        vx: -Math.cos(angle) * 2,
                        vy: -Math.sin(angle) * 2,
                        life: 20, color: '#00ff00', size: 4
                    });
                }
            }
        }

        function drawKirkBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isFlap = ball && ball.abilityActive && ball.currentAbility === 'wingflap';
            const isShrink = ball && ball.abilityActive && ball.currentAbility === 'shrinkface';
            const isTpusa = ball && ball.abilityActive && ball.currentAbility === 'tpusa';
            const isDebate = ball && ball.abilityActive && ball.currentAbility === 'debate';

            // Wing flapping
            const flapAngle = isFlap ? Math.sin(time * 20) * 0.5 : Math.sin(time * 2) * 0.1;

            // Left wing
            ctx.save();
            ctx.translate(-15, 0);
            ctx.rotate(-0.3 + flapAngle);
            ctx.fillStyle = '#deb887';
            ctx.beginPath();
            ctx.ellipse(0, 0, 25, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Right wing
            ctx.save();
            ctx.translate(15, 0);
            ctx.rotate(0.3 - flapAngle);
            ctx.fillStyle = '#deb887';
            ctx.beginPath();
            ctx.ellipse(0, 0, 25, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Face (smaller than normal)
            const faceScale = isShrink ? 0.4 + Math.sin(time * 10) * 0.1 : 0.7;
            ctx.save();
            ctx.scale(faceScale, faceScale);

            // Head
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();

            // Hair
            ctx.fillStyle = '#4a3728';
            ctx.beginPath();
            ctx.arc(0, -12, 18, Math.PI, 0);
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(-6, -2, 5, 0, Math.PI * 2);
            ctx.arc(6, -2, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(-6, -2, 2, 0, Math.PI * 2);
            ctx.arc(6, -2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.strokeStyle = '#cc6666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 8, 6, 0.2, Math.PI - 0.2);
            ctx.stroke();

            ctx.restore();

            // TPUSA logo effect
            if (isTpusa) {
                ctx.fillStyle = '#00bfff';
                ctx.shadowColor = '#00bfff';
                ctx.shadowBlur = 15;
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 6; i++) {
                    const angle = time * 2 + (i / 6) * Math.PI * 2;
                    const dist = 45;
                    ctx.fillText('USA', Math.cos(angle) * dist, Math.sin(angle) * dist);
                }
            }

            // Debate mode
            if (isDebate) {
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 12px Arial';
                const phrases = ['WRONG', 'FACTS', 'LOGIC'];
                for (let i = 0; i < 3; i++) {
                    const angle = time * 3 + (i / 3) * Math.PI * 2;
                    const dist = 50;
                    ctx.fillText(phrases[i], Math.cos(angle) * dist - 15, Math.sin(angle) * dist);
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawGabeBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isSteamSale = ball && ball.abilityActive && ball.currentAbility === 'steamsale';
            const isValveTime = ball && ball.abilityActive && ball.currentAbility === 'valvetime';
            const isGabenBlessing = ball && ball.abilityActive && ball.currentAbility === 'gabenblessing';
            const isHalfLife3 = ball && ball.abilityActive && ball.currentAbility === 'halflife3';

            // Bald head
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(0, -5, 22, 0, Math.PI * 2);
            ctx.fill();

            // Beard
            ctx.fillStyle = '#8b7355';
            ctx.beginPath();
            ctx.moveTo(-18, 5);
            ctx.quadraticCurveTo(-20, 25, -10, 30);
            ctx.lineTo(10, 30);
            ctx.quadraticCurveTo(20, 25, 18, 5);
            ctx.quadraticCurveTo(0, 15, -18, 5);
            ctx.fill();

            // Glasses
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(-8, -5, 8, 0, Math.PI * 2);
            ctx.arc(8, -5, 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(-16, -8);
            ctx.moveTo(16, -8);
            ctx.lineTo(22, -10);
            ctx.stroke();

            // Eyes behind glasses
            ctx.fillStyle = '#4a90d9';
            ctx.beginPath();
            ctx.arc(-8, -5, 3, 0, Math.PI * 2);
            ctx.arc(8, -5, 3, 0, Math.PI * 2);
            ctx.fill();

            // Steam sale effect - flying discount tags
            if (isSteamSale) {
                ctx.font = 'bold 10px Arial';
                ctx.fillStyle = '#00ff00';
                const discounts = ['-75%', '-90%', '-50%', '-95%'];
                for (let i = 0; i < 8; i++) {
                    const angle = time * 3 + (i / 8) * Math.PI * 2;
                    const dist = 40 + Math.sin(time * 5 + i) * 10;
                    ctx.fillText(discounts[i % discounts.length], Math.cos(angle) * dist - 10, Math.sin(angle) * dist);
                }
            }

            // Valve time effect - clock symbols
            if (isValveTime) {
                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    const angle = time + (i / 4) * Math.PI * 2;
                    const dist = 45;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -7);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(5, 0);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Gaben blessing - golden aura
            if (isGabenBlessing) {
                ctx.strokeStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 3;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 30 + i * 15 + Math.sin(time * 5) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Half-Life 3 - λ symbol and reality warping
            if (isHalfLife3) {
                ctx.fillStyle = '#ff6600';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 25;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 3; i++) {
                    const angle = time * 2 + (i / 3) * Math.PI * 2;
                    const dist = 50;
                    ctx.fillText('λ', Math.cos(angle) * dist, Math.sin(angle) * dist + 8);
                }
                // The 3
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('3', 0, 50 + Math.sin(time * 8) * 5);
            }

            ctx.shadowBlur = 0;
        }

        function drawLampBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isFlicker = ball && ball.abilityActive && ball.currentAbility === 'flicker';
            const isMothBeacon = ball && ball.abilityActive && ball.currentAbility === 'mothbeacon';
            const isBlindingLight = ball && ball.abilityActive && ball.currentAbility === 'blindinglight';
            const isLamppost = ball && ball.abilityActive && ball.currentAbility === 'lamppost';

            // Lamp base
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-8, 10, 16, 15);

            // Lamp shade (cone shape)
            ctx.fillStyle = '#daa520';
            ctx.beginPath();
            ctx.moveTo(-20, -5);
            ctx.lineTo(-12, -25);
            ctx.lineTo(12, -25);
            ctx.lineTo(20, -5);
            ctx.closePath();
            ctx.fill();

            // Lamp shade rim
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, -5, 20, 5, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#f0e68c';
            ctx.fill();

            // Light bulb glow
            const flickerIntensity = isFlicker ? Math.sin(time * 30) * 0.5 + 0.5 : 1;
            const glowSize = 15 + Math.sin(time * 3) * 3;

            ctx.fillStyle = `rgba(255, 255, 200, ${0.3 * flickerIntensity})`;
            ctx.shadowColor = '#ffff88';
            ctx.shadowBlur = 20 * flickerIntensity;
            ctx.beginPath();
            ctx.arc(0, -15, glowSize, 0, Math.PI * 2);
            ctx.fill();

            // Bulb
            ctx.fillStyle = '#ffffcc';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(0, -15, 8, 0, Math.PI * 2);
            ctx.fill();

            // Moth beacon - moths circling
            if (isMothBeacon) {
                ctx.fillStyle = '#d2b48c';
                for (let i = 0; i < 8; i++) {
                    const angle = time * 4 + (i / 8) * Math.PI * 2;
                    const dist = 30 + Math.sin(time * 6 + i) * 10;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist - 15);
                    ctx.rotate(angle + Math.PI / 2);
                    // Simple moth shape
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 4, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Wings
                    ctx.beginPath();
                    ctx.ellipse(-4, 0, 5, 3, -0.3, 0, Math.PI * 2);
                    ctx.ellipse(4, 0, 5, 3, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Blinding light - intense rays
            if (isBlindingLight) {
                ctx.strokeStyle = '#ffffff';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 30;
                ctx.lineWidth = 3;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const len = 50 + Math.sin(time * 10 + i) * 20;
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(Math.cos(angle) * len, -15 + Math.sin(angle) * len);
                    ctx.stroke();
                }
            }

            // Lamppost mode - tall streetlamp style
            if (isLamppost) {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 25);
                ctx.lineTo(0, 60);
                ctx.stroke();
                // Ground illumination
                ctx.fillStyle = 'rgba(255, 255, 150, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 60, 40, 15, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;
        }

        function drawWackyBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isBonkers = ball && ball.abilityActive && ball.currentAbility === 'bonkers';
            const isZany = ball && ball.abilityActive && ball.currentAbility === 'zany';
            const isSilly = ball && ball.abilityActive && ball.currentAbility === 'silly';
            const isChaos = ball && ball.abilityActive && ball.currentAbility === 'chaos';

            // Wobbly body effect
            const wobble = Math.sin(time * 8) * 0.2;
            ctx.save();
            ctx.rotate(wobble);

            // Rainbow shifting color
            const hue = (time * 100) % 360;
            ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;

            // Squiggly body
            ctx.beginPath();
            for (let i = 0; i <= 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const wiggle = Math.sin(time * 10 + i * 0.5) * 5;
                const r = 20 + wiggle;
                if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
            ctx.closePath();
            ctx.fill();

            // Googly eyes
            ctx.fillStyle = '#ffffff';
            const eyeOffset = Math.sin(time * 5) * 3;
            ctx.beginPath();
            ctx.arc(-8 + eyeOffset, -5, 8, 0, Math.PI * 2);
            ctx.arc(8 - eyeOffset, -5, 8, 0, Math.PI * 2);
            ctx.fill();

            // Crazy pupils that move around
            ctx.fillStyle = '#000000';
            const pupilX = Math.sin(time * 7) * 4;
            const pupilY = Math.cos(time * 6) * 4;
            ctx.beginPath();
            ctx.arc(-8 + pupilX, -5 + pupilY, 3, 0, Math.PI * 2);
            ctx.arc(8 + pupilX, -5 + pupilY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Silly tongue
            ctx.fillStyle = '#ff69b4';
            ctx.beginPath();
            const tongueWag = Math.sin(time * 12) * 10;
            ctx.ellipse(tongueWag, 15, 8, 12, Math.sin(time * 8) * 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Bonkers mode - everything spins
            if (isBonkers) {
                ctx.strokeStyle = `hsl(${(hue + 180) % 360}, 100%, 50%)`;
                ctx.lineWidth = 3;
                for (let i = 0; i < 6; i++) {
                    const angle = time * 5 + (i / 6) * Math.PI * 2;
                    const dist = 40;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(time * 10);
                    ctx.beginPath();
                    ctx.moveTo(-10, -10);
                    ctx.lineTo(10, 10);
                    ctx.moveTo(10, -10);
                    ctx.lineTo(-10, 10);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Zany mode - question marks and exclamation points
            if (isZany) {
                ctx.font = 'bold 16px Arial';
                const symbols = ['?', '!', '*', '~', '@', '#'];
                for (let i = 0; i < 8; i++) {
                    const angle = time * 3 + (i / 8) * Math.PI * 2;
                    const dist = 45 + Math.sin(time * 4 + i) * 10;
                    ctx.fillStyle = `hsl(${(hue + i * 45) % 360}, 100%, 50%)`;
                    ctx.fillText(symbols[i % symbols.length], Math.cos(angle) * dist - 5, Math.sin(angle) * dist + 5);
                }
            }

            // Silly mode - cartoon effects
            if (isSilly) {
                // Stars circling
                ctx.fillStyle = '#ffff00';
                for (let i = 0; i < 5; i++) {
                    const angle = time * 4 + (i / 5) * Math.PI * 2;
                    const dist = 35;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(time * 8);
                    // Draw star
                    ctx.beginPath();
                    for (let j = 0; j < 5; j++) {
                        const starAngle = (j / 5) * Math.PI * 2 - Math.PI / 2;
                        const r = j % 2 === 0 ? 8 : 4;
                        if (j === 0) ctx.moveTo(Math.cos(starAngle) * r, Math.sin(starAngle) * r);
                        else ctx.lineTo(Math.cos(starAngle) * r, Math.sin(starAngle) * r);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Chaos mode - everything goes crazy
            if (isChaos) {
                for (let i = 0; i < 12; i++) {
                    const angle = time * 6 + (i / 12) * Math.PI * 2;
                    const dist = 50 + Math.sin(time * 8 + i * 2) * 20;
                    ctx.fillStyle = `hsl(${(time * 200 + i * 30) % 360}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 5 + Math.sin(time * 10 + i) * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawShadowmanaBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isDrain = ball && ball.abilityActive && ball.currentAbility === 'manadrain';
            const isShadowStep = ball && ball.abilityActive && ball.currentAbility === 'shadowstep';
            const isDarkPulse = ball && ball.abilityActive && ball.currentAbility === 'darkpulse';
            const isVoidRift = ball && ball.abilityActive && ball.currentAbility === 'voidrift';

            // Dark swirling aura
            ctx.save();
            for (let i = 0; i < 3; i++) {
                ctx.rotate(time * (0.5 + i * 0.2));
                ctx.strokeStyle = `rgba(75, 0, 130, ${0.3 - i * 0.08})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 28 + i * 8, 0, Math.PI * 1.5);
                ctx.stroke();
            }
            ctx.restore();

            // Main body - dark purple with inner glow
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
            gradient.addColorStop(0, '#9932cc');
            gradient.addColorStop(0.5, '#4b0082');
            gradient.addColorStop(1, '#1a0033');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 22, 0, Math.PI * 2);
            ctx.fill();

            // Glowing runes
            ctx.strokeStyle = '#da70d6';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#da70d6';
            ctx.shadowBlur = 10;
            for (let i = 0; i < 4; i++) {
                const angle = time * 0.5 + (i / 4) * Math.PI * 2;
                ctx.save();
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(18, -4);
                ctx.lineTo(18, 4);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }

            // Central eye
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye pupil - follows a pattern
            ctx.fillStyle = '#000000';
            ctx.shadowBlur = 0;
            const eyeX = Math.sin(time * 2) * 3;
            const eyeY = Math.cos(time * 1.5) * 2;
            ctx.beginPath();
            ctx.ellipse(eyeX, eyeY, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mana drain effect - purple tendrils
            if (isDrain) {
                ctx.strokeStyle = '#9932cc';
                ctx.shadowColor = '#9932cc';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const angle = time * 2 + (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    for (let j = 1; j <= 5; j++) {
                        const dist = j * 12;
                        const wiggle = Math.sin(time * 8 + j + i) * 8;
                        ctx.lineTo(Math.cos(angle) * dist + Math.cos(angle + Math.PI/2) * wiggle,
                                   Math.sin(angle) * dist + Math.sin(angle + Math.PI/2) * wiggle);
                    }
                    ctx.stroke();
                }
            }

            // Shadow step effect - afterimages
            if (isShadowStep) {
                for (let i = 1; i <= 4; i++) {
                    ctx.fillStyle = `rgba(75, 0, 130, ${0.3 - i * 0.06})`;
                    ctx.beginPath();
                    ctx.arc(-i * 15, i * 5, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Dark pulse - expanding dark rings
            if (isDarkPulse) {
                for (let i = 0; i < 4; i++) {
                    const pulseTime = (time * 3 + i * 0.5) % 2;
                    const radius = pulseTime * 60;
                    ctx.strokeStyle = `rgba(138, 43, 226, ${1 - pulseTime / 2})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Void rift - reality tearing effect
            if (isVoidRift) {
                ctx.strokeStyle = '#000000';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                // Jagged rift
                ctx.beginPath();
                ctx.moveTo(-30, -40);
                for (let i = 0; i < 8; i++) {
                    const x = -30 + (i % 2) * 15 + Math.sin(time * 5 + i) * 5;
                    const y = -40 + i * 12;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(-15, 50);
                for (let i = 7; i >= 0; i--) {
                    const x = -15 + (i % 2) * 15 + Math.sin(time * 5 + i + 1) * 5;
                    const y = -40 + i * 12;
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#9932cc';
                ctx.stroke();

                // Purple energy at rift edges
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.strokeStyle = '#ff00ff';
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function drawSebastianBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isButlerStrike = ball && ball.abilityActive && ball.currentAbility === 'butlerstrike';
            const isTeaTime = ball && ball.abilityActive && ball.currentAbility === 'teatime';
            const isSilverware = ball && ball.abilityActive && ball.currentAbility === 'silverware';
            const isHellfire = ball && ball.abilityActive && ball.currentAbility === 'hellfire';

            // Butler tailcoat body
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(0, 5, 18, 22, 0, 0, Math.PI * 2);
            ctx.fill();

            // White shirt front
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(-8, -10);
            ctx.lineTo(0, 15);
            ctx.lineTo(8, -10);
            ctx.closePath();
            ctx.fill();

            // Face - pale
            ctx.fillStyle = '#f5e6d3';
            ctx.beginPath();
            ctx.arc(0, -12, 14, 0, Math.PI * 2);
            ctx.fill();

            // Black hair
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.ellipse(0, -18, 14, 8, 0, Math.PI, 0);
            ctx.fill();
            // Hair strands
            ctx.beginPath();
            ctx.moveTo(-10, -15);
            ctx.quadraticCurveTo(-15, -10, -12, -5);
            ctx.lineTo(-8, -10);
            ctx.fill();

            // Red eyes (demon butler)
            ctx.fillStyle = '#8b0000';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = isHellfire ? 15 : 5;
            ctx.beginPath();
            ctx.ellipse(-5, -12, 3, 2, 0, 0, Math.PI * 2);
            ctx.ellipse(5, -12, 3, 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Subtle smile
            ctx.strokeStyle = '#8b0000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, -8, 5, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // White gloves
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(-20, 10, 6, 0, Math.PI * 2);
            ctx.arc(20, 10, 6, 0, Math.PI * 2);
            ctx.fill();

            // Butler strike - silverware flying
            if (isButlerStrike) {
                ctx.fillStyle = '#c0c0c0';
                for (let i = 0; i < 6; i++) {
                    const angle = time * 5 + (i / 6) * Math.PI * 2;
                    const dist = 40;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(angle);
                    ctx.fillRect(-2, -12, 4, 24);
                    ctx.restore();
                }
            }

            // Tea time - healing steam
            if (isTeaTime) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const offset = (time * 2 + i * 0.5) % 2;
                    ctx.beginPath();
                    ctx.moveTo(-10 + i * 5, -30);
                    ctx.quadraticCurveTo(-8 + i * 5 + Math.sin(time * 3 + i) * 5, -40 - offset * 15, -10 + i * 5, -50 - offset * 10);
                    ctx.stroke();
                }
            }

            // Silverware storm
            if (isSilverware) {
                ctx.fillStyle = '#c0c0c0';
                ctx.strokeStyle = '#808080';
                for (let i = 0; i < 12; i++) {
                    const angle = time * 3 + (i / 12) * Math.PI * 2;
                    const dist = 50 + Math.sin(time * 5 + i) * 10;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(time * 8 + i);
                    // Fork or knife
                    if (i % 2 === 0) {
                        ctx.fillRect(-1, -10, 2, 20);
                        ctx.fillRect(-4, -10, 8, 3);
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(0, -12);
                        ctx.lineTo(-3, 8);
                        ctx.lineTo(3, 8);
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            // Hellfire mode
            if (isHellfire) {
                ctx.fillStyle = '#ff4500';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 25;
                for (let i = 0; i < 8; i++) {
                    const angle = time * 4 + (i / 8) * Math.PI * 2;
                    const dist = 45;
                    const flameHeight = 20 + Math.sin(time * 10 + i) * 10;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.quadraticCurveTo(
                        Math.cos(angle) * (dist + 15), Math.sin(angle) * (dist + 15),
                        Math.cos(angle) * dist + Math.cos(angle + 0.3) * flameHeight,
                        Math.sin(angle) * dist + Math.sin(angle + 0.3) * flameHeight
                    );
                    ctx.fill();
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawOoferBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isOof = ball && ball.abilityActive && ball.currentAbility === 'bigoof';
            const isRobloxian = ball && ball.abilityActive && ball.currentAbility === 'robloxian';
            const isNoob = ball && ball.abilityActive && ball.currentAbility === 'noobattack';
            const isBuildMode = ball && ball.abilityActive && ball.currentAbility === 'buildmode';

            // Classic Roblox body - blocky yellow
            ctx.fillStyle = '#f3b700';
            ctx.fillRect(-15, -15, 30, 30);

            // Roblox face
            ctx.fillStyle = '#000000';
            // Eyes - classic dot eyes
            ctx.beginPath();
            ctx.arc(-6, -3, 3, 0, Math.PI * 2);
            ctx.arc(6, -3, 3, 0, Math.PI * 2);
            ctx.fill();

            // Classic smile
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 3, 8, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // OOF text floating
            if (isOof) {
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                for (let i = 0; i < 5; i++) {
                    const angle = time * 3 + (i / 5) * Math.PI * 2;
                    const dist = 50;
                    const yOffset = Math.sin(time * 5 + i) * 10;
                    ctx.fillText('OOF', Math.cos(angle) * dist, Math.sin(angle) * dist + yOffset);
                }
            }

            // Robloxian power - blocky aura
            if (isRobloxian) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                for (let i = 0; i < 3; i++) {
                    const size = 25 + i * 12 + Math.sin(time * 4) * 5;
                    ctx.strokeRect(-size, -size, size * 2, size * 2);
                }
            }

            // Noob attack - yellow cubes
            if (isNoob) {
                ctx.fillStyle = '#ffff00';
                for (let i = 0; i < 8; i++) {
                    const angle = time * 4 + (i / 8) * Math.PI * 2;
                    const dist = 45;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(time * 3);
                    ctx.fillRect(-8, -8, 16, 16);
                    ctx.restore();
                }
            }

            // Build mode - floating bricks
            if (isBuildMode) {
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
                for (let i = 0; i < 10; i++) {
                    const angle = time * 2 + (i / 10) * Math.PI * 2;
                    const dist = 55 + Math.sin(time * 3 + i) * 15;
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.rotate(time * 2 + i);
                    ctx.fillRect(-6, -4, 12, 8);
                    // Brick studs
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(-3, 0, 2, 0, Math.PI * 2);
                    ctx.arc(3, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
        }

        function drawLeonitasBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isSparta = ball && ball.abilityActive && ball.currentAbility === 'thisssparta';
            const isPhalanx = ball && ball.abilityActive && ball.currentAbility === 'phalanx';
            const isShieldBash = ball && ball.abilityActive && ball.currentAbility === 'shieldbash';
            const isWarCry = ball && ball.abilityActive && ball.currentAbility === 'warcry';

            // Spartan helmet
            ctx.fillStyle = '#8b4513';
            // Helmet base
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();

            // Helmet crest (red mohawk)
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.moveTo(-5, -20);
            ctx.quadraticCurveTo(0, -35, 5, -20);
            ctx.lineTo(5, 10);
            ctx.quadraticCurveTo(0, 5, -5, 10);
            ctx.closePath();
            ctx.fill();

            // Helmet face guard
            ctx.fillStyle = '#654321';
            ctx.beginPath();
            ctx.moveTo(-15, -5);
            ctx.lineTo(-15, 15);
            ctx.lineTo(-8, 20);
            ctx.lineTo(-8, 0);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(15, -5);
            ctx.lineTo(15, 15);
            ctx.lineTo(8, 20);
            ctx.lineTo(8, 0);
            ctx.closePath();
            ctx.fill();

            // Eye slits - glowing
            ctx.fillStyle = '#ff6600';
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 10;
            ctx.fillRect(-12, -2, 8, 4);
            ctx.fillRect(4, -2, 8, 4);

            // Shield (lambda symbol)
            ctx.fillStyle = '#8b4513';
            ctx.beginPath();
            ctx.arc(25, 5, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.arc(25, 5, 15, 0, Math.PI * 2);
            ctx.fill();
            // Lambda
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(20, -5);
            ctx.lineTo(25, 10);
            ctx.lineTo(30, -5);
            ctx.stroke();

            // THIS IS SPARTA effect
            if (isSparta) {
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                const spartaY = -50 + Math.sin(time * 8) * 5;
                ctx.fillText('THIS IS', 0, spartaY);
                ctx.font = 'bold 18px Arial';
                ctx.fillText('SPARTA!', 0, spartaY + 18);
            }

            // Phalanx formation - shield wall
            if (isPhalanx) {
                ctx.fillStyle = '#8b4513';
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI - Math.PI / 2;
                    const dist = 50;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Shield bash - impact waves
            if (isShieldBash) {
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                for (let i = 0; i < 3; i++) {
                    const offset = (time * 4 + i * 0.3) % 1;
                    ctx.globalAlpha = 1 - offset;
                    ctx.beginPath();
                    ctx.arc(30, 5, 20 + offset * 40, -Math.PI / 2, Math.PI / 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            // War cry - sound waves
            if (isWarCry) {
                ctx.strokeStyle = '#ff4500';
                ctx.lineWidth = 3;
                for (let i = 0; i < 4; i++) {
                    const offset = (time * 3 + i * 0.25) % 1;
                    ctx.globalAlpha = 1 - offset;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30 + offset * 50, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            ctx.shadowBlur = 0;
        }

        function drawKillswitchBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isShutdown = ball && ball.abilityActive && ball.currentAbility === 'shutdown';
            const isOverload = ball && ball.abilityActive && ball.currentAbility === 'overload';
            const isVirus = ball && ball.abilityActive && ball.currentAbility === 'virus';
            const isReboot = ball && ball.abilityActive && ball.currentAbility === 'reboot';

            // Circuit board body
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 22);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#0f0f1a');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, 22, 0, Math.PI * 2);
            ctx.fill();

            // Circuit lines
            ctx.strokeStyle = isOverload ? '#ff0000' : '#00ff00';
            ctx.shadowColor = isOverload ? '#ff0000' : '#00ff00';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
            // Horizontal lines
            ctx.beginPath();
            ctx.moveTo(-20, -8);
            ctx.lineTo(-5, -8);
            ctx.lineTo(-5, -15);
            ctx.moveTo(5, -8);
            ctx.lineTo(20, -8);
            ctx.moveTo(-20, 8);
            ctx.lineTo(20, 8);
            ctx.stroke();
            // Vertical lines
            ctx.beginPath();
            ctx.moveTo(-10, -20);
            ctx.lineTo(-10, 20);
            ctx.moveTo(10, -20);
            ctx.lineTo(10, 20);
            ctx.stroke();

            // Central power indicator
            const pulseSize = 8 + Math.sin(time * 5) * 2;
            ctx.fillStyle = isShutdown ? '#ff0000' : '#00ff00';
            ctx.beginPath();
            ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
            ctx.fill();

            // Power symbol
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 2, 4, -Math.PI * 0.8, Math.PI * 0.8);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -2);
            ctx.lineTo(0, -6);
            ctx.stroke();

            // Shutdown effect - red X marks
            if (isShutdown) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                for (let i = 0; i < 6; i++) {
                    const angle = time * 2 + (i / 6) * Math.PI * 2;
                    const dist = 45;
                    ctx.save();
                    ctx.translate(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.beginPath();
                    ctx.moveTo(-8, -8);
                    ctx.lineTo(8, 8);
                    ctx.moveTo(8, -8);
                    ctx.lineTo(-8, 8);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Overload - electrical sparks
            if (isOverload) {
                ctx.strokeStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = time * 6 + (i / 8) * Math.PI * 2;
                    const dist = 35;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * 25, Math.sin(angle) * 25);
                    // Jagged lightning
                    for (let j = 0; j < 3; j++) {
                        const jx = Math.cos(angle) * (25 + (j + 1) * 10) + (Math.random() - 0.5) * 10;
                        const jy = Math.sin(angle) * (25 + (j + 1) * 10) + (Math.random() - 0.5) * 10;
                        ctx.lineTo(jx, jy);
                    }
                    ctx.stroke();
                }
            }

            // Virus - corrupted data particles
            if (isVirus) {
                ctx.fillStyle = '#ff00ff';
                ctx.font = '10px monospace';
                const virusChars = ['0', '1', 'X', '!', '#', '@'];
                for (let i = 0; i < 15; i++) {
                    const angle = time * 3 + (i / 15) * Math.PI * 2;
                    const dist = 40 + Math.sin(time * 5 + i) * 15;
                    ctx.fillText(virusChars[i % virusChars.length], Math.cos(angle) * dist, Math.sin(angle) * dist);
                }
            }

            // Reboot - loading circle
            if (isReboot) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 4;
                const progress = (time * 2) % 1;
                ctx.beginPath();
                ctx.arc(0, 0, 35, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.floor(progress * 100) + '%', 0, 4);
            }

            ctx.shadowBlur = 0;
        }

        function drawBigBritishDemonBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isTeaAndHell = ball && ball.abilityActive && ball.currentAbility === 'teaandhell';
            const isQueueWrath = ball && ball.abilityActive && ball.currentAbility === 'queuewrath';
            const isBloodyHell = ball && ball.abilityActive && ball.currentAbility === 'bloodyhell';
            const isGodSaveMe = ball && ball.abilityActive && ball.currentAbility === 'godsaveme';

            // Large demon body - red
            ctx.fillStyle = '#8b0000';
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();

            // Horns
            ctx.fillStyle = '#2f2f2f';
            ctx.beginPath();
            ctx.moveTo(-15, -15);
            ctx.quadraticCurveTo(-25, -35, -20, -40);
            ctx.quadraticCurveTo(-15, -35, -12, -18);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(15, -15);
            ctx.quadraticCurveTo(25, -35, 20, -40);
            ctx.quadraticCurveTo(15, -35, 12, -18);
            ctx.closePath();
            ctx.fill();

            // Top hat (British!)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(-12, -35, 24, 18);
            ctx.fillRect(-16, -20, 32, 5);

            // Monocle
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(10, -5, 7, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(17, -5);
            ctx.lineTo(25, 5);
            ctx.stroke();

            // Glowing yellow eyes
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.ellipse(-8, -5, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(8, -5, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Evil grin
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 5, 12, 0.1, Math.PI - 0.1);
            ctx.stroke();
            // Fangs
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(-8, 8);
            ctx.lineTo(-6, 15);
            ctx.lineTo(-4, 8);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(4, 8);
            ctx.lineTo(6, 15);
            ctx.lineTo(8, 8);
            ctx.fill();

            // Mustache
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-8, 2, 6, 3, -0.3, 0, Math.PI * 2);
            ctx.ellipse(8, 2, 6, 3, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Tea and Hell - teacup with hellfire
            if (isTeaAndHell) {
                // Floating teacup
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.ellipse(-35, 0, 10, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(-28, 0, 5, -Math.PI / 2, Math.PI / 2);
                ctx.stroke();
                // Hellfire steam
                ctx.fillStyle = '#ff4500';
                for (let i = 0; i < 5; i++) {
                    const flameY = -15 - Math.sin(time * 8 + i) * 10;
                    ctx.beginPath();
                    ctx.moveTo(-38 + i * 3, -8);
                    ctx.quadraticCurveTo(-37 + i * 3, flameY, -35 + i * 3, -8);
                    ctx.fill();
                }
            }

            // Queue wrath - orderly but deadly
            if (isQueueWrath) {
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                const phrases = ['QUEUE!', 'ORDERLY!', 'WAIT!'];
                for (let i = 0; i < 3; i++) {
                    const angle = time * 2 + (i / 3) * Math.PI * 2;
                    const dist = 50;
                    ctx.fillText(phrases[i], Math.cos(angle) * dist, Math.sin(angle) * dist);
                }
            }

            // Bloody Hell - blood splatter
            if (isBloodyHell) {
                ctx.fillStyle = '#8b0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                for (let i = 0; i < 12; i++) {
                    const angle = time * 3 + (i / 12) * Math.PI * 2;
                    const dist = 45 + Math.sin(time * 5 + i) * 10;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 5 + Math.sin(time * 7 + i) * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // God Save Me - divine/demonic clash
            if (isGodSaveMe) {
                // Half divine, half demonic aura
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 40, -Math.PI / 2, Math.PI / 2);
                ctx.stroke();
                ctx.strokeStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(0, 0, 40, Math.PI / 2, -Math.PI / 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        function drawAbaChanBall(ctx, weapon, ball) {
            const time = Date.now() / 1000;
            const isModeSwitch = ball && ball.abilityActive && ball.currentAbility === 'modeswitch';
            const isComboAttack = ball && ball.abilityActive && ball.currentAbility === 'comboattack';
            const isAwakening = ball && ball.abilityActive && ball.currentAbility === 'awakening';
            const isUltimate = ball && ball.abilityActive && ball.currentAbility === 'abaultimate';

            // Aba's mask/face - red and white
            const isRageMode = ball && ball.abaRageMode;

            // Base head
            ctx.fillStyle = isRageMode ? '#ff4444' : '#f5e6d3';
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();

            // Hair - spiky red/orange
            ctx.fillStyle = '#ff6600';
            for (let i = 0; i < 7; i++) {
                const angle = -Math.PI / 2 + (i - 3) * 0.3;
                const len = 15 + Math.sin(time * 5 + i) * (isRageMode ? 5 : 2);
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle - 0.15) * 18, Math.sin(angle - 0.15) * 18);
                ctx.lineTo(Math.cos(angle) * (18 + len), Math.sin(angle) * (18 + len));
                ctx.lineTo(Math.cos(angle + 0.15) * 18, Math.sin(angle + 0.15) * 18);
                ctx.closePath();
                ctx.fill();
            }

            // Eyes - intense
            if (isRageMode) {
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 15;
            } else {
                ctx.fillStyle = '#8b4513';
                ctx.shadowBlur = 0;
            }
            ctx.beginPath();
            ctx.ellipse(-7, -3, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(7, -3, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Rage marks
            if (isRageMode) {
                ctx.strokeStyle = '#8b0000';
                ctx.lineWidth = 2;
                // Cheek marks
                ctx.beginPath();
                ctx.moveTo(-15, 5);
                ctx.lineTo(-10, 3);
                ctx.moveTo(-15, 8);
                ctx.lineTo(-10, 6);
                ctx.moveTo(15, 5);
                ctx.lineTo(10, 3);
                ctx.moveTo(15, 8);
                ctx.lineTo(10, 6);
                ctx.stroke();
            }

            // Determined mouth
            ctx.strokeStyle = isRageMode ? '#8b0000' : '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (isRageMode) {
                ctx.moveTo(-8, 10);
                ctx.lineTo(0, 8);
                ctx.lineTo(8, 10);
            } else {
                ctx.arc(0, 8, 6, 0.2, Math.PI - 0.2);
            }
            ctx.stroke();

            // Key/sword weapon
            ctx.fillStyle = '#c0c0c0';
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 1;
            ctx.save();
            ctx.translate(25, 0);
            ctx.rotate(Math.sin(time * 3) * 0.2);
            // Blade
            ctx.fillRect(-3, -25, 6, 35);
            // Guard
            ctx.fillRect(-10, 8, 20, 4);
            // Handle
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(-2, 12, 4, 10);
            ctx.restore();

            // Mode switch - transformation particles
            if (isModeSwitch) {
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const dist = 35 + Math.sin(time * 8 + i) * 10;
                    ctx.fillStyle = i % 2 === 0 ? '#ff6600' : '#ffff00';
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Combo attack - slash effects
            if (isComboAttack) {
                ctx.strokeStyle = '#ffffff';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 10;
                ctx.lineWidth = 3;
                for (let i = 0; i < 3; i++) {
                    const offset = (time * 5 + i * 0.3) % 1;
                    ctx.globalAlpha = 1 - offset;
                    ctx.beginPath();
                    ctx.moveTo(20 + offset * 30, -20 - offset * 20);
                    ctx.lineTo(40 + offset * 30, 20 + offset * 20);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }

            // Awakening - power aura
            if (isAwakening) {
                ctx.strokeStyle = '#ff4500';
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 25;
                ctx.lineWidth = 4;
                for (let i = 0; i < 3; i++) {
                    const size = 30 + i * 15 + Math.sin(time * 6) * 5;
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Ultimate - massive energy burst
            if (isUltimate) {
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 30;
                for (let i = 0; i < 20; i++) {
                    const angle = time * 4 + (i / 20) * Math.PI * 2;
                    const dist = 50 + Math.sin(time * 10 + i * 2) * 20;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    ctx.lineTo(Math.cos(angle + 0.1) * dist * 0.8, Math.sin(angle + 0.1) * dist * 0.8);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            ctx.shadowBlur = 0;
        }

        // Weapons array
        const weapons = [
            { id: 'unarmed', name: 'Unarmed', length: 0, damage: 5, speed: 1.5, size: 0.85, type: 'special', draw: drawUnarmed,
              ability: 'Momentum', abilityDesc: 'Gains speed from bouncing, deals damage based on speed', abilityCooldown: 0, abilityDuration: 0 },
            { id: 'archangel', name: 'Archangel Michael', length: 55, damage: 30, speed: 1.0, size: 1.4, type: 'legendary', draw: drawArchangelMichael,
              ability: 'Divine Powers', abilityDesc: 'Rotating: Smite, Holy Shield, Divine Dash, Resurrection', abilityCooldown: 120, abilityDuration: 60,
              color: '#ffd700', abilities: ['smite', 'holyshield', 'divinedash', 'resurrection'] },
            { id: 'solans', name: "Solan's Sword", length: 55, damage: 22, speed: 1.3, size: 1.2, type: 'legendary', draw: drawSolansSword,
              ability: 'White Flame', abilityDesc: 'Rotating: White Flame Charge (burn), Charged Blow (fireball barrage), Soulbound (CC immunity)',
              abilityCooldown: 100, abilityDuration: 90, color: '#e0ffff', abilities: ['whiteflamecharge', 'chargedblow', 'soulbound'] },
            { id: 'superman', name: 'Superman', length: 30, damage: 28, speed: 1.4, size: 1.35, type: 'legendary', draw: drawSuperman,
              ability: 'Kryptonian', abilityDesc: 'Rotating: Flight (speed boost), Heat Vision (beam), Super Strength (3x damage), Freeze Breath',
              abilityCooldown: 90, abilityDuration: 70, color: '#0000ff', abilities: ['flight', 'heatvision', 'superstrength', 'freezebreath'] },
            { id: 'gojo', name: 'Gojo Satoru', length: 25, damage: 20, speed: 1.2, size: 1.3, type: 'legendary', draw: drawGojo,
              ability: 'Six Eyes', abilityDesc: 'Rotating: Infinity (invulnerable), Unlimited Void (stun all), Hollow Purple (big hit), Reversal Red',
              abilityCooldown: 110, abilityDuration: 80, color: '#00bfff', abilities: ['infinity', 'domain', 'hollowpurple', 'reversal'] },
            { id: 'sukuna', name: 'Ryomen Sukuna', length: 35, damage: 32, speed: 1.1, size: 1.4, type: 'legendary', draw: drawSukuna,
              ability: 'King of Curses', abilityDesc: 'Rotating: Cleave (slash), Dismantle (multi-hit), Malevolent Shrine (domain), Open Flame',
              abilityCooldown: 100, abilityDuration: 75, color: '#8b0000', abilities: ['cleave', 'dismantle', 'shrine', 'openflame'] },
            { id: 'jobapp', name: 'Job Application', length: 40, damage: 15, speed: 0.8, size: 1.1, type: 'legendary', draw: drawJobApplication,
              ability: 'Corporate', abilityDesc: 'Rotating: Rejected (damage), Ghosted (invisible), Overqualified (reflect), Need Experience (paradox damage)',
              abilityCooldown: 80, abilityDuration: 60, color: '#ff0000', abilities: ['reject', 'ghost', 'overqualified', 'experience'] },
            { id: 'dio', name: 'DIO', length: 35, damage: 25, speed: 1.2, size: 1.35, type: 'legendary', draw: drawDio,
              ability: 'The World', abilityDesc: 'Rotating: Time Stop (freeze all), Knives (projectiles), Road Roller (big damage), MUDA MUDA (rapid hits)',
              abilityCooldown: 130, abilityDuration: 90, color: '#ffd700', abilities: ['timestop', 'knives', 'roadroller', 'mudamuda'] },
            { id: 'blackhole', name: 'Black Hole', length: 30, damage: 18, speed: 0.7, size: 1.5, type: 'legendary', draw: drawBlackhole,
              ability: 'Gravity', abilityDesc: 'Rotating: Singularity (pull all), Event Horizon (trap), Hawking Radiation (DoT), Collapse (burst)',
              abilityCooldown: 120, abilityDuration: 100, color: '#4b0082', abilities: ['singularity', 'eventhorizon', 'hawking', 'collapse'] },
            { id: 'ninja', name: 'Ninja', length: 32, damage: 22, speed: 1.4, size: 1.2, type: 'legendary', draw: drawNinja,
              ability: 'Ninjutsu', abilityDesc: 'Rotating: Shadow Clone (decoys), Rasengan (burst), Chakram Trap (floor), Fireball Jutsu (AoE)',
              abilityCooldown: 100, abilityDuration: 80, color: '#ff6600', abilities: ['shadowclone', 'rasengan', 'chakram', 'fireballjutsu'] },
            { id: 'money', name: 'Money Ball', length: 30, damage: 18, speed: 0.9, size: 1.3, type: 'legendary', draw: drawMoneyBall,
              ability: 'Capitalism', abilityDesc: 'Rotating: Factory (pollution), Money Throw (projectiles), Bodyguards (summon), Bailout (heal+shield)',
              abilityCooldown: 90, abilityDuration: 100, color: '#00aa00', abilities: ['factory', 'moneythrow', 'bodyguard', 'bailout'] },
            { id: 'simon', name: 'Simon The Digger', length: 55, damage: 38, speed: 1.3, size: 1.8, type: 'godly', draw: drawSimonBall,
              ability: 'SPIRAL POWER', abilityDesc: 'GODLY! Uses 2 abilities at once! 15% Vampirism! Giga Drill, Spiral Power, Who The Hell, Pierce Heavens, Combine, Lagann Impact, Tengen Toppa, Infinity Big Bang!',
              abilityCooldown: 40, abilityDuration: 150, color: '#00ff00', vampirism: 0.15,
              abilities: ['gigadrill', 'spiralpower', 'whothehell', 'piercetheheavens', 'combine', 'lagannimpact', 'tengentoppa', 'infinitybigbang'] },
            { id: 'kirk', name: 'Kirk Ball', length: 35, damage: 28, speed: 1.4, size: 1.3, type: 'mythical', draw: drawKirkBall,
              ability: 'Facts & Logic', abilityDesc: 'MYTHICAL! Debate (50% instakill), Sing (heal), MOG (1000 shield + full heal), TPUSA (buff)',
              abilityCooldown: 60, abilityDuration: 90, color: '#deb887', abilities: ['debate', 'sing', 'mog', 'tpusa', 'wingflap', 'shrinkface'] },
            { id: 'casino', name: 'Casino Ball', length: 28, damage: 20, speed: 1.1, size: 1.25, type: 'legendary', draw: drawCasinoBall,
              ability: 'High Roller', abilityDesc: 'Rotating: Slot Roll (JACKPOT=500HP+buffs!), Chip Barrage (multi-hit), Card Shark (rapid), House Wins (burst)',
              abilityCooldown: 85, abilityDuration: 90, color: '#8b0000', abilities: ['slotroll', 'chipbarrage', 'cardshark', 'housewins'] },
            { id: 'american', name: 'American Ball', length: 40, damage: 24, speed: 1.0, size: 1.3, type: 'legendary', draw: drawAmericanBall,
              ability: 'Second Amendment', abilityDesc: 'Guns! Shotgun/AR/Grenades. AUTO AIR SUPPORT at <10% HP (nuke 1% chance!)',
              abilityCooldown: 70, abilityDuration: 60, color: '#ff0000', abilities: ['shotgun', 'assaultrifle', 'grenadelauncher', 'airstrike'] },
            { id: 'divinity', name: 'Divinity', length: 50, damage: 30, speed: 1.2, size: 1.5, type: 'mythical', draw: drawDivinityBall,
              ability: 'Divine Power', abilityDesc: 'MYTHICAL! 16 abilities: Heal, Omnipotence(10 at once!), Steal, Stun, Silence, Charm, Smite, Resurrect, Shield, Judgment, Blessing, Curse, Ascend, Holy Fire, Miracle, Rapture',
              abilityCooldown: 50, abilityDuration: 120, color: '#ffd700', abilities: ['heal', 'omnipotence', 'steal', 'stun', 'silence', 'charm', 'smite', 'resurrect', 'shield', 'judgment', 'blessing', 'curse', 'ascend', 'holyfire', 'miracle', 'rapture'] },
            { id: 'archmage', name: 'Archmage', length: 45, damage: 28, speed: 1.1, size: 1.4, type: 'mythical', draw: drawArchmageBall,
              ability: 'Supreme Sorcery', abilityDesc: 'MYTHICAL! 20 magic circle spells, Zombie resurrection, Grand Disintegration (1v1 + 30HP advantage)',
              abilityCooldown: 40, abilityDuration: 100, color: '#9932cc', abilities: ['magiccircle', 'resurrect_zombie', 'disintegrate'] },
            { id: 'paradoxical', name: 'Paradoxical', length: 55, damage: 40, speed: 1.2, size: 1.8, type: 'godly', draw: drawParadoxicalBall,
              ability: 'Reality Unbound', abilityDesc: 'GODLY! 3 PHASES with FULL HEAL on each! 50% damage reduction! 15+ attacks. ULTIMATE!',
              abilityCooldown: 25, abilityDuration: 150, color: '#00ffff', abilities: ['paradox_phase'] },
            { id: 'eternal', name: 'The Eternal', length: 25, damage: 5, speed: 0.5, size: 0.8, type: 'godly', draw: drawEternal,
              ability: 'Eternal Pulse', abilityDesc: 'Resurrects 5 times, each form stronger with new attacks!',
              abilityCooldown: 300, abilityDuration: 60, color: '#ffd700' },
            { id: 'lightyagami', name: 'Light Yagami', length: 30, damage: 5, speed: 1.5, size: 1.0, type: 'secret', draw: drawLightYagamiBall,
              ability: 'Death Note', abilityDesc: 'SECRET! 5 second windup then INSTAKILL a random enemy. Can dodge attacks.',
              abilityCooldown: 600, abilityDuration: 300, color: '#8b0000' },
            { id: 'looksmaxxing', name: 'Looksmaxxing Ball', length: 40, damage: 22, speed: 1.3, size: 1.2, type: 'secret', draw: drawLooksmaxxingBall,
              ability: 'Looksmaxx', abilityDesc: 'SECRET! Bonesmash (damage+stun), Mewing (defense), Carrotmaxx (vision), Mogging (intimidate), Dogpill (summon)',
              abilityCooldown: 90, abilityDuration: 60, color: '#ff69b4', abilities: ['bonesmash', 'mewing', 'carrotmaxx', 'mogging', 'dogpill'] },
            { id: 'gabe', name: 'Gabe Ball', length: 35, damage: 25, speed: 0.9, size: 1.3, type: 'legendary', draw: drawGabeBall,
              ability: 'Steam Power', abilityDesc: 'Rotating: Steam Sale (damage boost), Valve Time (slow enemies), Gaben Blessing (heal+shield), Half-Life 3 (ultimate burst)',
              abilityCooldown: 100, abilityDuration: 90, color: '#1b2838', abilities: ['steamsale', 'valvetime', 'gabenblessing', 'halflife3'] },
            { id: 'lamp', name: 'Lamp Ball', length: 30, damage: 18, speed: 1.1, size: 1.2, type: 'legendary', draw: drawLampBall,
              ability: 'Illumination', abilityDesc: 'Rotating: Flicker (confuse), Moth Beacon (summon moths), Blinding Light (stun+damage), Lamppost (AoE zone)',
              abilityCooldown: 85, abilityDuration: 80, color: '#ffd700', abilities: ['flicker', 'mothbeacon', 'blindinglight', 'lamppost'] },
            { id: 'wacky', name: 'Wacky Ball', length: 30, damage: 20, speed: 1.4, size: 1.2, type: 'legendary', draw: drawWackyBall,
              ability: 'Wackiness', abilityDesc: 'Rotating: Bonkers (random damage), Zany (confuse+random effects), Silly (buff self), Chaos (EVERYTHING RANDOM!)',
              abilityCooldown: 70, abilityDuration: 100, color: '#ff69b4', abilities: ['bonkers', 'zany', 'silly', 'chaos'] },
            { id: 'shadowmana', name: 'Shadowmana Ball', length: 40, damage: 26, speed: 1.0, size: 1.35, type: 'mythical', draw: drawShadowmanaBall,
              ability: 'Dark Arts', abilityDesc: 'MYTHICAL! Mana Drain (steal HP+silence), Shadow Step (teleport+invuln), Dark Pulse (AoE), Void Rift (massive damage zone)',
              abilityCooldown: 80, abilityDuration: 90, color: '#4b0082', abilities: ['manadrain', 'shadowstep', 'darkpulse', 'voidrift'] },
            { id: 'sebastian', name: 'Sebastian Ball', length: 38, damage: 24, speed: 1.2, size: 1.3, type: 'legendary', draw: drawSebastianBall,
              ability: 'One Hell of a Butler', abilityDesc: 'Rotating: Butler Strike (silverware), Tea Time (heal), Silverware Storm (AoE), Hellfire (demon mode)',
              abilityCooldown: 90, abilityDuration: 85, color: '#1a1a1a', abilities: ['butlerstrike', 'teatime', 'silverware', 'hellfire'] },
            { id: 'oofer', name: 'Oofer Ball', length: 30, damage: 22, speed: 1.3, size: 1.2, type: 'legendary', draw: drawOoferBall,
              ability: 'Roblox Power', abilityDesc: 'Rotating: Big OOF (damage+sound), Robloxian (power up), Noob Attack (projectiles), Build Mode (create barriers)',
              abilityCooldown: 75, abilityDuration: 80, color: '#f3b700', abilities: ['bigoof', 'robloxian', 'noobattack', 'buildmode'] },
            { id: 'leonitas', name: 'Leonitas Ball', length: 45, damage: 30, speed: 0.9, size: 1.4, type: 'legendary', draw: drawLeonitasBall,
              ability: 'Spartan Might', abilityDesc: 'Rotating: THIS IS SPARTA (kick), Phalanx (shield wall), Shield Bash (stun), War Cry (buff+fear)',
              abilityCooldown: 100, abilityDuration: 90, color: '#8b0000', abilities: ['thisssparta', 'phalanx', 'shieldbash', 'warcry'] },
            { id: 'killswitch', name: 'Killswitch Ball', length: 35, damage: 28, speed: 1.1, size: 1.25, type: 'mythical', draw: drawKillswitchBall,
              ability: 'System Override', abilityDesc: 'MYTHICAL! Shutdown (disable abilities), Overload (electric burst), Virus (DoT spread), Reboot (full heal+cleanse)',
              abilityCooldown: 85, abilityDuration: 100, color: '#00ff00', abilities: ['shutdown', 'overload', 'virus', 'reboot'] },
            { id: 'britishdemon', name: 'Big British Demon', length: 42, damage: 32, speed: 0.85, size: 1.5, type: 'mythical', draw: drawBigBritishDemonBall,
              ability: 'Proper Evil', abilityDesc: 'MYTHICAL! Tea & Hell (heal+burn), Queue Wrath (orderly damage), Bloody Hell (AoE), God Save Me (ultimate)',
              abilityCooldown: 95, abilityDuration: 95, color: '#8b0000', abilities: ['teaandhell', 'queuewrath', 'bloodyhell', 'godsaveme'] },
            { id: 'abachan', name: 'Aba Chan', length: 40, damage: 26, speed: 1.25, size: 1.3, type: 'mythical', draw: drawAbaChanBall,
              ability: 'Keyblade Master', abilityDesc: 'MYTHICAL! Mode Switch (rage toggle), Combo Attack (multi-hit), Awakening (power boost), Ultimate (massive burst)',
              abilityCooldown: 70, abilityDuration: 100, color: '#ff6600', abilities: ['modeswitch', 'comboattack', 'awakening', 'abaultimate'] },
            { id: 'sword', name: 'Sword', length: 45, damage: 15, speed: 1.2, size: 1.0, type: 'melee', draw: drawSword,
              ability: 'Parry', abilityDesc: 'Blocks incoming damage briefly', abilityCooldown: 180, abilityDuration: 30 },
            { id: 'axe', name: 'Axe', length: 40, damage: 25, speed: 0.8, size: 1.15, type: 'melee', draw: drawAxe,
              ability: 'Spin Attack', abilityDesc: 'Spins rapidly dealing area damage', abilityCooldown: 240, abilityDuration: 60 },
            { id: 'pickaxe', name: 'Pickaxe', length: 42, damage: 18, speed: 1.0, size: 1.05, type: 'melee', draw: drawPickaxe,
              ability: 'Armor Break', abilityDesc: 'Next hit deals 3x damage', abilityCooldown: 200, abilityDuration: 120 },
            { id: 'spear', name: 'Spear', length: 60, damage: 12, speed: 1.4, size: 0.95, type: 'melee', draw: drawSpear,
              ability: 'Charge', abilityDesc: 'Charges forward with increased damage', abilityCooldown: 150, abilityDuration: 40 },
            { id: 'hammer', name: 'Hammer', length: 38, damage: 35, speed: 0.6, size: 1.3, type: 'melee', draw: drawHammer,
              ability: 'Ground Slam', abilityDesc: 'Slams ground, stunning nearby enemies', abilityCooldown: 300, abilityDuration: 30 },
            { id: 'bow', name: 'Bow', length: 40, damage: 12, speed: 1.3, size: 0.9, type: 'special', draw: drawBowBall,
              ability: 'Arrow Volley', abilityDesc: 'Fire 5 arrows in a spread', abilityCooldown: 180, color: '#8b4513' },
            { id: 'longsword', name: 'Longsword', length: 55, damage: 18, speed: 1.0, size: 1.1, type: 'melee', draw: drawLongswordBall,
              ability: 'Sweeping Strike', abilityDesc: 'Wide arc attack hitting all nearby', abilityCooldown: 200, color: '#c0c0c0' },
            { id: 'chainsaw', name: 'Chainsaw', length: 35, damage: 25, speed: 0.9, size: 1.0, type: 'special', draw: drawChainsawBall,
              ability: 'Rev Up', abilityDesc: 'Rapid hits + bleeding for 5 seconds', abilityCooldown: 250, color: '#ff4500' },
            { id: 'crossbow', name: 'Crossbow', length: 42, damage: 22, speed: 1.1, size: 0.95, type: 'special', draw: drawCrossbowBall,
              ability: 'Power Shot', abilityDesc: 'Single powerful piercing bolt', abilityCooldown: 220, color: '#654321' },
            { id: 'flail', name: 'Flail', length: 50, damage: 16, speed: 1.15, size: 1.05, type: 'melee', draw: drawFlailBall,
              ability: 'Whirlwind', abilityDesc: 'Spin rapidly damaging all around', abilityCooldown: 190, color: '#808080' },
            { id: 'mace', name: 'Mace', length: 38, damage: 20, speed: 1.1, size: 1.0, type: 'melee', draw: drawMaceBall,
              ability: 'Crushing Blow', abilityDesc: 'Heavy strike that stuns enemy', abilityCooldown: 210, color: '#4169e1' },
            { id: 'whip', name: 'Whip', length: 60, damage: 10, speed: 1.4, size: 0.85, type: 'melee', draw: drawWhipBall,
              ability: 'Lash & Pull', abilityDesc: 'Grab and pull enemy closer', abilityCooldown: 150, color: '#8b0000' },
            { id: 'slingshot', name: 'Slingshot', length: 30, damage: 8, speed: 1.5, size: 0.8, type: 'melee', draw: drawSlingshotBall,
              ability: 'Rock Barrage', abilityDesc: 'Launch 3 bouncing rocks', abilityCooldown: 120, color: '#d2691e' },
            { id: 'boomerang', name: 'Boomerang', length: 35, damage: 13, speed: 1.35, size: 0.9, type: 'special', draw: drawBoomerangBall,
              ability: 'Curved Throw', abilityDesc: 'Throw boomerang that returns hitting twice', abilityCooldown: 170, color: '#daa520' },
            { id: 'torch', name: 'Torch', length: 32, damage: 11, speed: 1.2, size: 0.95, type: 'magic', draw: drawTorchBall,
              ability: 'Ignite', abilityDesc: 'Set enemy on fire for burn damage', abilityCooldown: 140, color: '#ff6600' },
            { id: 'dagger', name: 'Dagger', length: 28, damage: 10, speed: 1.8, size: 0.9, type: 'melee', draw: drawDagger,
              ability: 'Shadow Step', abilityDesc: 'Teleport behind nearest enemy', abilityCooldown: 120, abilityDuration: 20 },
            { id: 'scythe', name: 'Scythe', length: 50, damage: 22, speed: 0.9, size: 1.2, type: 'melee', draw: drawScythe,
              ability: 'Life Steal', abilityDesc: 'Heals for damage dealt', abilityCooldown: 200, abilityDuration: 80 },
            { id: 'firestaff', name: 'Fire Staff', length: 45, damage: 8, speed: 1.0, size: 1.1, type: 'magic', draw: drawFireStaff,
              ability: 'Fireball', abilityDesc: 'Shoots a burning fireball', abilityCooldown: 100, abilityDuration: 10 },
            { id: 'icewand', name: 'Ice Wand', length: 38, damage: 6, speed: 1.2, size: 1.0, type: 'magic', draw: drawIceWand,
              ability: 'Freeze', abilityDesc: 'Freezes nearby enemies', abilityCooldown: 180, abilityDuration: 45 },
            { id: 'lightning', name: 'Lightning Rod', length: 40, damage: 7, speed: 1.1, size: 1.05, type: 'magic', draw: drawLightningRod,
              ability: 'Chain Lightning', abilityDesc: 'Lightning chains between enemies', abilityCooldown: 140, abilityDuration: 20 },
            { id: 'voidorb', name: 'Void Orb', length: 42, damage: 5, speed: 0.9, size: 1.15, type: 'magic', draw: drawVoidOrb,
              ability: 'Gravity Well', abilityDesc: 'Pulls enemies toward you', abilityCooldown: 200, abilityDuration: 100 },
            { id: 'healstaff', name: 'Nature Staff', length: 40, damage: 4, speed: 1.0, size: 1.0, type: 'magic', draw: drawHealStaff,
              ability: 'Regeneration', abilityDesc: 'Heals over time', abilityCooldown: 150, abilityDuration: 120 },
            { id: 'sunstaff', name: 'Sun Staff', length: 48, damage: 10, speed: 0.85, size: 1.25, type: 'magic', draw: drawSunStaff,
              ability: 'Solar Flare', abilityDesc: 'Blinds and damages all enemies', abilityCooldown: 250, abilityDuration: 40 }
        ];

        // Game state
        let balls = [];
        let particles = [];
        let projectiles = [];
        let hitEffects = [];
        let lightningBolts = [];
        let divineLightning = [];
        let gameRunning = false;
        let currentRound = 1;
        let scores = {};

        // Power-up system
        let powerups = [];
        let selectedPowerup = null;
        let powerupCooldowns = {
            heal: 0,
            damage: 0,
            speed: 0,
            shield: 0,
            freeze: 0
        };
        const POWERUP_COOLDOWN = 300; // 5 seconds at 60fps

        const settings = {
            speed: 1,
            health: 100,
            rounds: 1,
            selectedBalls: [0, 1, 2, 3, 4, 5],
            weaponAssignments: {},
            teamAssignments: {},
            teamMode: false
        };

        // Initialize UI
        function initUI() {
            const ballSelection = document.getElementById('ballSelection');
            ballSelection.innerHTML = '';

            function updateAbilityInfo(index) {
                const selectEl = document.getElementById(`weapon${index}`);
                if (!selectEl) {
                    console.error(`weapon${index} select not found`);
                    return;
                }
                const weaponIndex = parseInt(selectEl.value);
                console.log(`updateAbilityInfo for ball ${index}, weaponIndex: ${weaponIndex}`);

                if (isNaN(weaponIndex) || weaponIndex < 0 || weaponIndex >= weapons.length) {
                    const abilityInfo = document.getElementById(`ability${index}`);
                    if (abilityInfo) {
                        abilityInfo.className = 'ability-info';
                        abilityInfo.innerHTML = '<div class="ability-name">Select a weapon</div>';
                    }
                    return;
                }

                const weapon = weapons[weaponIndex];
                const abilityInfo = document.getElementById(`ability${index}`);

                if (!weapon || !abilityInfo) {
                    console.error(`Missing weapon or abilityInfo for ball ${index}`);
                    return;
                }

                abilityInfo.className = `ability-info ${weapon.type}`;
                abilityInfo.innerHTML = `
                    <div class="ability-name">
                        <span class="type-badge ${weapon.type}">${weapon.type}</span>
                        ${weapon.ability || '?'}
                    </div>
                    <div class="ability-desc">${weapon.abilityDesc || '?'}</div>
                `;
            }

            function updateBallOptionStyle(index) {
                const checkbox = document.getElementById(`ball${index}`);
                const ballOption = checkbox.closest('.ball-option');
                if (checkbox.checked) {
                    ballOption.classList.remove('unchecked');
                } else {
                    ballOption.classList.add('unchecked');
                }
            }

            for (let index = 0; index < ballConfigs.length; index++) {
                const config = ballConfigs[index];
                const div = document.createElement('div');
                div.className = 'ball-option';

                // Ball header with checkbox, color dot, and name
                const header = document.createElement('div');
                header.className = 'ball-header';
                header.innerHTML = `
                    <input type="checkbox" id="ball${index}" checked>
                    <div class="ball-color-dot" style="background: ${config.color}; color: ${config.color}"></div>
                    <span class="ball-name" style="color: ${config.color}">${config.name}</span>
                `;

                // Controls container
                const controls = document.createElement('div');
                controls.className = 'ball-controls';

                // Weapon select
                const weaponSelect = document.createElement('select');
                weaponSelect.className = 'weapon-select';
                weaponSelect.id = `weapon${index}`;

                // Find the first unlocked weapon to use as default
                const swordIdx = weapons.findIndex(w => w.id === 'sword');
                const spearIdx = weapons.findIndex(w => w.id === 'spear');

                // Build dropdown with all weapons
                const weaponTypes = ['secret', 'godly', 'mythical', 'legendary', 'special', 'melee', 'magic'];
                weaponTypes.forEach(type => {
                    const typeWeapons = weapons.filter(w => w.type === type);
                    if (typeWeapons.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = type.charAt(0).toUpperCase() + type.slice(1);
                        typeWeapons.forEach(w => {
                            const weaponIdx = weapons.indexOf(w);
                            const opt = document.createElement('option');
                            opt.value = weaponIdx;
                            if (isWeaponUnlocked(w.id)) {
                                opt.textContent = w.name;
                            } else {
                                opt.textContent = '[LOCKED] ' + w.name;
                                opt.disabled = true;
                                opt.style.color = '#666';
                            }
                            optgroup.appendChild(opt);
                        });
                        weaponSelect.appendChild(optgroup);
                    }
                });

                // AFTER dropdown is built, explicitly set the value to sword or first unlocked
                let defaultIdx = -1;
                if (swordIdx >= 0 && isWeaponUnlocked('sword')) {
                    defaultIdx = swordIdx;
                } else if (spearIdx >= 0 && isWeaponUnlocked('spear')) {
                    defaultIdx = spearIdx;
                } else {
                    // Find first unlocked weapon
                    for (let i = 0; i < weapons.length; i++) {
                        if (isWeaponUnlocked(weapons[i].id)) {
                            defaultIdx = i;
                            break;
                        }
                    }
                }

                if (defaultIdx >= 0) {
                    weaponSelect.value = defaultIdx.toString();
                }

                settings.weaponAssignments[index] = defaultIdx >= 0 ? defaultIdx : 0;

                // Team select
                const teamSelect = document.createElement('select');
                teamSelect.className = 'team-select';
                teamSelect.id = `team${index}`;
                teamSelect.innerHTML = `
                    <option value="0">Solo (Free-for-all)</option>
                    <option value="1">Team 1 (Red)</option>
                    <option value="2">Team 2 (Blue)</option>
                `;
                teamSelect.style.display = 'none';

                // Ability info display
                const abilityInfo = document.createElement('div');
                abilityInfo.className = 'ability-info';
                abilityInfo.id = `ability${index}`;

                controls.appendChild(weaponSelect);
                controls.appendChild(teamSelect);
                controls.appendChild(abilityInfo);

                div.appendChild(header);
                div.appendChild(controls);
                ballSelection.appendChild(div);

                // Event listeners
                weaponSelect.addEventListener('change', () => {
                    const selectedIdx = parseInt(weaponSelect.value);
                    console.log(`Ball ${index} weapon changed to index ${selectedIdx}:`, weapons[selectedIdx]?.name);
                    settings.weaponAssignments[index] = selectedIdx;
                    updateAbilityInfo(index);
                });

                teamSelect.addEventListener('change', () => {
                    settings.teamAssignments[index] = parseInt(teamSelect.value);
                });

                document.getElementById(`ball${index}`).addEventListener('change', () => {
                    updateBallOptionStyle(index);
                });

                // weaponAssignments already set above after dropdown creation
                settings.teamAssignments[index] = 0;

                // Initialize ability info with a slight delay to ensure DOM is ready
                setTimeout(() => updateAbilityInfo(index), 10);
            }

            document.getElementById('speedSlider').addEventListener('input', e => {
                settings.speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = settings.speed + 'x';
            });

            document.getElementById('healthSlider').addEventListener('input', e => {
                settings.health = parseInt(e.target.value);
                document.getElementById('healthValue').textContent = settings.health;
            });

            document.getElementById('roundsSlider').addEventListener('input', e => {
                settings.rounds = parseInt(e.target.value);
                document.getElementById('roundsValue').textContent = settings.rounds;
            });

            document.getElementById('teamModeToggle').addEventListener('change', e => {
                settings.teamMode = e.target.checked;
                ballConfigs.forEach((_, i) => {
                    document.getElementById(`team${i}`).style.display = settings.teamMode ? 'block' : 'none';
                });
            });

            document.getElementById('startButton').addEventListener('click', startGame);

            // Setup betting system listeners
            setTimeout(() => {
                if (typeof setupBettingListeners === 'function') {
                    setupBettingListeners();
                }
            }, 200);

            // Power-up button handlers
            document.querySelectorAll('.powerup-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.dataset.type;
                    if (powerupCooldowns[type] > 0) return;

                    if (selectedPowerup === type) {
                        selectedPowerup = null;
                        btn.classList.remove('selected');
                    } else {
                        document.querySelectorAll('.powerup-btn').forEach(b => b.classList.remove('selected'));
                        selectedPowerup = type;
                        btn.classList.add('selected');
                    }
                });
            });

            // Canvas click handler for placing power-ups
            canvas.addEventListener('click', (e) => {
                if (!selectedPowerup || !gameRunning) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if click is inside arena
                const dx = x - centerX;
                const dy = y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > arenaRadius - 30) return;

                // Place power-up
                placePowerup(selectedPowerup, x, y);

                // Start cooldown
                powerupCooldowns[selectedPowerup] = POWERUP_COOLDOWN;

                // Deselect
                document.querySelectorAll('.powerup-btn').forEach(b => b.classList.remove('selected'));
                selectedPowerup = null;
            });

            ballConfigs.forEach((_, i) => {
                scores[i] = 0;
            });
            updateScoreDisplay();
        }

        function updateScoreDisplay() {
            const display = document.getElementById('scoreDisplay');
            let html = '<h3>Scores</h3>';
            ballConfigs.forEach((config, i) => {
                html += `<div class="score-item"><span style="color:${config.color}">${config.name}</span><span>${scores[i]}</span></div>`;
            });
            display.innerHTML = html;
        }

        // === SPECIAL EVENT: THE TRINITY ===
        function triggerTheTrinity() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #000; z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            const style = document.createElement('style');
            style.textContent = `
                @keyframes trinityGlow {
                    0%, 100% { filter: brightness(1) hue-rotate(0deg); }
                    33% { filter: brightness(1.5) hue-rotate(120deg); }
                    66% { filter: brightness(1.5) hue-rotate(240deg); }
                }
                @keyframes trinityOrbit {
                    from { transform: rotate(0deg) translateX(100px) rotate(0deg); }
                    to { transform: rotate(360deg) translateX(100px) rotate(-360deg); }
                }
                @keyframes cosmicPulse {
                    0%, 100% { box-shadow: 0 0 50px #fff, 0 0 100px #00ffff, 0 0 150px #ff00ff; }
                    50% { box-shadow: 0 0 80px #fff, 0 0 150px #ffd700, 0 0 200px #00ffff; }
                }
            `;
            document.head.appendChild(style);

            // Phase 1: The three powers appear
            overlay.innerHTML = `
                <div style="font-size: 30px; color: #fff; margin-bottom: 50px;">Three cosmic forces converge...</div>
                <div style="position: relative; width: 300px; height: 300px;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                width: 80px; height: 80px; border-radius: 50%;
                                background: radial-gradient(#fff, #000);
                                animation: cosmicPulse 1s infinite;"></div>
                    <div style="position: absolute; top: 50%; left: 50%; font-size: 40px;
                                animation: trinityOrbit 3s linear infinite;">
                        <span style="color: #00ffff;">&#8734;</span>
                    </div>
                    <div style="position: absolute; top: 50%; left: 50%; font-size: 40px;
                                animation: trinityOrbit 3s linear infinite 1s;">
                        <span style="color: #9932cc;">&#9733;</span>
                    </div>
                    <div style="position: absolute; top: 50%; left: 50%; font-size: 40px;
                                animation: trinityOrbit 3s linear infinite 2s;">
                        <span style="color: #ffd700;">&#10017;</span>
                    </div>
                </div>
            `;

            // Phase 2: Convergence (after 3s)
            setTimeout(() => {
                overlay.style.background = 'radial-gradient(circle, #fff 0%, #000 50%)';
                overlay.innerHTML = `
                    <div style="font-size: 60px; color: #ffd700; font-weight: bold;
                                text-shadow: 0 0 30px #fff; animation: trinityGlow 2s infinite;">
                        THE TRINITY
                    </div>
                    <div style="font-size: 24px; color: #fff; margin-top: 30px;">
                        Paradox &#8226; Magic &#8226; Divinity
                    </div>
                    <div style="font-size: 18px; color: #aaa; margin-top: 20px;">
                        Reality achieves perfect balance
                    </div>
                `;
            }, 3000);

            // Phase 3: Blessing (after 6s)
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="font-size: 50px; color: #ffd700; animation: trinityGlow 1s infinite;">
                        COSMIC BLESSING
                    </div>
                    <div style="font-size: 30px; color: #0f0; margin-top: 30px;">
                        +5000$ granted
                    </div>
                    <div style="font-size: 20px; color: #0ff; margin-top: 20px;">
                        All three warriors gain 50% bonus stats!
                    </div>
                `;

                // Grant rewards
                if (!gameData.achievements.includes('the_trinity')) {
                    gameData.achievements.push('the_trinity');
                    gameData.currency += 5000;
                    saveGameData();
                    updateCurrencyDisplay();
                }
            }, 6000);

            // Phase 4: Battle begins with buffs (after 9s)
            setTimeout(() => {
                overlay.style.transition = 'opacity 1s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                    // Set trinity buff flag
                    window.trinityBuff = true;
                    // Continue to actual game start
                    document.getElementById('startButton').click();
                }, 1000);
            }, 9000);
        }

        // === SPECIAL EVENT: DEATH PARADOX ===
        function triggerDeathParadox() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #000; z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            // Phase 1: Conflict
            overlay.innerHTML = `
                <div style="color: #ff0000; font-size: 36px; text-shadow: 0 0 20px #ff0000;">
                    Can you write the name of a Paradox?
                </div>
                <div style="display: flex; gap: 100px; margin-top: 50px;">
                    <div style="font-size: 80px; color: #00ffff;">&#8734;</div>
                    <div style="font-size: 40px; color: #fff; align-self: center;">VS</div>
                    <div style="font-size: 80px; color: #ff0000;">&#9760;</div>
                </div>
            `;

            // Phase 2: Writing attempt (after 2.5s)
            setTimeout(() => {
                overlay.innerHTML += `
                    <div style="margin-top: 40px; color: #fff; font-size: 24px;">
                        Light Yagami writes: <span style="color: #ff0000; font-family: cursive;">P...a...r...a...</span>
                    </div>
                `;
            }, 2500);

            // Phase 3: Error (after 4s)
            setTimeout(() => {
                overlay.style.animation = 'shake 0.1s infinite';
                overlay.innerHTML = `
                    <div style="font-size: 60px; color: #ff0000; text-shadow: 0 0 30px #ff0000;">
                        ERROR
                    </div>
                    <div style="font-size: 30px; color: #fff; margin-top: 20px;">
                        Cannot define the undefined
                    </div>
                    <div style="font-size: 20px; color: #00ffff; margin-top: 20px;">
                        The Death Note pages tear themselves apart
                    </div>
                `;
            }, 4000);

            // Phase 4: Resolution (after 6s)
            setTimeout(() => {
                overlay.style.animation = 'none';
                overlay.style.background = 'linear-gradient(45deg, #1a0a0a, #0a1a1a)';
                overlay.innerHTML = `
                    <div style="font-size: 50px; color: #ff00ff;">
                        DEATH PARADOX
                    </div>
                    <div style="font-size: 30px; color: #fff; margin-top: 30px;">
                        Neither can defeat the other
                    </div>
                    <div style="font-size: 60px; margin-top: 30px;">
                        <span style="color: #00ffff;">&#8734;</span>
                        <span style="color: #888;"> = </span>
                        <span style="color: #ff0000;">&#9760;</span>
                    </div>
                    <div style="font-size: 24px; color: #ffd700; margin-top: 30px;">
                        DRAW - Both transcend mortality
                    </div>
                `;

                if (!gameData.achievements.includes('death_paradox')) {
                    checkAchievement('death_paradox', 'DEATH PARADOX',
                        'Discovered that death cannot touch infinity',
                        '+3000$ for witnessing the impossible');
                    gameData.currency += 3000;
                    saveGameData();
                    updateCurrencyDisplay();
                }
            }, 6000);

            // Cleanup (after 10s)
            setTimeout(() => {
                overlay.style.transition = 'opacity 2s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    document.getElementById('startButton').disabled = false;
                }, 2000);
            }, 10000);
        }

        // === SPECIAL EVENT: DIVINE JUDGMENT ===
        function triggerDivineJudgment() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: linear-gradient(180deg, #ffd700 0%, #000 30%, #000 70%, #ff0000 100%);
                z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            // Phase 1: Confrontation
            overlay.innerHTML = `
                <div style="font-size: 40px; color: #fff; text-align: center;">
                    <div style="color: #ffd700; text-shadow: 0 0 30px #ffd700;">GOD</div>
                    <div style="font-size: 80px; margin: 20px 0;">&#10017;</div>
                </div>
                <div style="font-size: 30px; color: #fff; margin: 30px 0;">meets</div>
                <div style="font-size: 40px; color: #fff; text-align: center;">
                    <div style="color: #ff0000; text-shadow: 0 0 30px #ff0000;">DEATH</div>
                    <div style="font-size: 80px; margin: 20px 0;">&#9760;</div>
                </div>
            `;

            // Phase 2: Battle (after 3s)
            setTimeout(() => {
                overlay.style.background = '#000';
                overlay.innerHTML = `
                    <div style="font-size: 70px; color: #fff; font-weight: bold;
                                text-shadow: 0 0 20px #ffd700, 0 0 40px #ff0000;">
                        DIVINE JUDGMENT
                    </div>
                    <div style="font-size: 24px; color: #aaa; margin-top: 30px;">
                        The ultimate question: Who judges the judge?
                    </div>
                `;
            }, 3000);

            // Phase 3: Explosion of light (after 5s)
            setTimeout(() => {
                overlay.style.background = '#fff';
                setTimeout(() => {
                    overlay.style.background = '#000';
                    overlay.innerHTML = `
                        <div style="font-size: 50px; color: #ffd700;">
                            STALEMATE
                        </div>
                        <div style="font-size: 30px; color: #fff; margin-top: 30px;">
                            God cannot die. Death cannot be judged.
                        </div>
                        <div style="font-size: 24px; color: #ff00ff; margin-top: 30px;">
                            The battle echoes through eternity...
                        </div>
                    `;
                }, 200);
            }, 5000);

            // Grant achievement and close (after 8s)
            setTimeout(() => {
                if (!gameData.achievements.includes('divine_judgment')) {
                    checkAchievement('divine_judgment', 'DIVINE JUDGMENT',
                        'Witnessed God face Death itself',
                        '+2500$ for theological insights');
                    gameData.currency += 2500;
                    saveGameData();
                    updateCurrencyDisplay();
                }

                overlay.style.transition = 'opacity 2s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    document.getElementById('startButton').disabled = false;
                }, 2000);
            }, 8000);
        }

        // === SPECIAL EVENT: CLONE ARMY ===

        // KIRK VS KIRK - The Ultimate Tragedy
        function triggerKirked() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #000; z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            const style = document.createElement('style');
            style.textContent = `
                @keyframes kirkGlow {
                    0%, 100% { text-shadow: 0 0 20px #deb887, 0 0 40px #d2691e; }
                    50% { text-shadow: 0 0 40px #deb887, 0 0 80px #d2691e, 0 0 120px #8b4513; }
                }
                @keyframes fadeInUp {
                    from { opacity: 0; transform: translateY(30px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                @keyframes candleFlicker {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.7; }
                }
                @keyframes rip {
                    0% { transform: scale(0.8); opacity: 0; }
                    50% { transform: scale(1.1); }
                    100% { transform: scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);

            const quotes = [
                "Let's say, hypothetically, for the sake of argument...",
                "Facts don't care about your feelings.",
                "The bigger the government, the smaller the citizen.",
                "Truth is not mean. It's just the truth.",
                "Debate me.",
                "His face was small, but his heart was large.",
                "He mogged too close to the sun.",
                "A legend among balls.",
                "He debated his way into our hearts.",
                "Gone but never forgotten. Still mogging in heaven."
            ];

            // Phase 1: The Meeting
            overlay.innerHTML = `
                <div style="color: #fff; font-size: 32px; margin-bottom: 40px;">
                    When two Kirks meet...
                </div>
                <div style="display: flex; gap: 100px; align-items: center;">
                    <div style="width: 80px; height: 80px; border-radius: 50%;
                                background: radial-gradient(#ffdbac, #deb887, #8b4513);
                                box-shadow: 0 0 30px #deb887;"></div>
                    <div style="font-size: 40px; color: #ff0000;">VS</div>
                    <div style="width: 80px; height: 80px; border-radius: 50%;
                                background: radial-gradient(#ffdbac, #deb887, #8b4513);
                                box-shadow: 0 0 30px #deb887;"></div>
                </div>
            `;

            // Phase 2: The Debate (2s)
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="color: #deb887; font-size: 28px; animation: kirkGlow 1s infinite;">
                        "Let me debate myself..."
                    </div>
                    <div style="color: #ff6600; font-size: 24px; margin-top: 30px;">
                        Kirk uses FACTS and LOGIC on Kirk
                    </div>
                `;
            }, 2000);

            // Phase 3: KIRKED (4s)
            setTimeout(() => {
                overlay.style.background = '#ff0000';
                setTimeout(() => {
                    overlay.style.background = '#000';
                    overlay.innerHTML = `
                        <div style="font-size: 120px; color: #ff0000; font-weight: bold;
                                    text-shadow: 0 0 50px #ff0000; animation: rip 0.5s ease-out;">
                            KIRKED
                        </div>
                        <div style="font-size: 30px; color: #fff; margin-top: 30px;">
                            Both Kirks have been destroyed
                        </div>
                    `;
                }, 200);
            }, 4000);

            // Phase 4: Memorial (6s)
            setTimeout(() => {
                overlay.style.background = 'linear-gradient(180deg, #1a1a2e 0%, #0a0a0a 100%)';
                overlay.innerHTML = `
                    <div style="font-size: 60px; color: #deb887; margin-bottom: 20px;
                                animation: kirkGlow 2s infinite;">
                        In Loving Memory
                    </div>
                    <div style="font-size: 40px; color: #ffd700; margin-bottom: 30px;">
                        ðŸ•¯ï¸ KIRK BALL ðŸ•¯ï¸
                    </div>
                    <div style="width: 120px; height: 120px; border-radius: 50%;
                                background: radial-gradient(#ffdbac, #deb887, #8b4513);
                                box-shadow: 0 0 50px #deb887;
                                margin-bottom: 30px;"></div>
                    <div style="font-size: 24px; color: #aaa; font-style: italic; max-width: 600px;
                                text-align: center; animation: fadeInUp 1s ease-out;">
                        "${quotes[Math.floor(Math.random() * quotes.length)]}"
                    </div>
                `;
            }, 6000);

            // Phase 5: More quotes (9s)
            setTimeout(() => {
                const quote2 = quotes[Math.floor(Math.random() * quotes.length)];
                overlay.innerHTML += `
                    <div style="font-size: 20px; color: #888; font-style: italic; margin-top: 30px;
                                animation: fadeInUp 1s ease-out;">
                        "${quote2}"
                    </div>
                `;
            }, 9000);

            // Phase 6: Final tribute (11s)
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="display: flex; gap: 40px; margin-bottom: 40px;">
                        <div style="font-size: 40px; animation: candleFlicker 1s infinite;">ðŸ•¯ï¸</div>
                        <div style="font-size: 40px; animation: candleFlicker 1s infinite 0.3s;">ðŸ•¯ï¸</div>
                        <div style="font-size: 40px; animation: candleFlicker 1s infinite 0.6s;">ðŸ•¯ï¸</div>
                    </div>
                    <div style="font-size: 50px; color: #ffd700; font-weight: bold;
                                animation: kirkGlow 1s infinite;">
                        DRAW
                    </div>
                    <div style="font-size: 28px; color: #deb887; margin-top: 30px;">
                        Both Kirks have ascended
                    </div>
                    <div style="font-size: 22px; color: #888; margin-top: 20px; font-style: italic;">
                        "In the end, the only one who could defeat Kirk... was Kirk."
                    </div>
                    <div style="font-size: 18px; color: #666; margin-top: 40px;">
                        Press F to pay respects
                    </div>
                `;

                // Achievement
                if (!gameData.achievements.includes('kirked')) {
                    checkAchievement('kirked', 'KIRKED',
                        'Witnessed Kirk destroy himself with facts and logic',
                        '+5000$ in Kirk\'s memory');
                    gameData.currency += 5000;
                    saveGameData();
                    updateCurrencyDisplay();
                }
            }, 11000);

            // Cleanup (16s)
            setTimeout(() => {
                overlay.style.transition = 'opacity 2s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                    document.getElementById('startButton').disabled = false;
                }, 2000);
            }, 16000);
        }

        // ETERNAL FORM 6 - TRANSCENDENCE CUTSCENE
        function triggerTranscendenceCutscene() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #000; z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            const style = document.createElement('style');
            style.textContent = `
                @keyframes transcendPulse {
                    0%, 100% { transform: scale(1); filter: brightness(1); }
                    50% { transform: scale(1.2); filter: brightness(2); }
                }
                @keyframes deathGlow {
                    0%, 100% { text-shadow: 0 0 20px #ff0000, 0 0 40px #8b0000; }
                    50% { text-shadow: 0 0 60px #ff0000, 0 0 120px #ff6600, 0 0 180px #fff; }
                }
                @keyframes simonFade {
                    0% { opacity: 1; transform: scale(1); }
                    100% { opacity: 0.3; transform: scale(0.8); filter: grayscale(100%); }
                }
            `;
            document.head.appendChild(style);

            // Phase 1: Screen goes red
            overlay.style.background = 'radial-gradient(circle, #330000 0%, #000 100%)';
            overlay.innerHTML = `
                <div style="font-size: 60px; color: #ff0000; font-weight: bold; animation: deathGlow 0.5s infinite;">
                    !!!
                </div>
            `;

            // Phase 2: The Eternal speaks
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="width: 150px; height: 150px; border-radius: 50%;
                                background: radial-gradient(#fff, #ff6666, #8b0000);
                                box-shadow: 0 0 100px #ff0000, 0 0 200px #ff6600;
                                animation: transcendPulse 0.5s infinite;"></div>
                    <div style="color: #ff0000; font-size: 32px; margin-top: 40px; animation: deathGlow 1s infinite;">
                        "You have pushed me beyond death itself..."
                    </div>
                `;
            }, 1500);

            // Phase 3: TRANSCENDENCE announcement
            setTimeout(() => {
                overlay.style.background = '#fff';
                setTimeout(() => {
                    overlay.style.background = 'linear-gradient(180deg, #1a0000 0%, #000 50%, #330000 100%)';
                    overlay.innerHTML = `
                        <div style="font-size: 80px; color: #fff; font-weight: bold;
                                    text-shadow: 0 0 50px #ff0000;
                                    animation: deathGlow 0.3s infinite;">
                            TRANSCENDENCE
                        </div>
                        <div style="font-size: 30px; color: #ff6666; margin-top: 20px;">
                            HIDDEN FORM 6 UNLOCKED
                        </div>
                    `;
                }, 200);
            }, 4000);

            // Phase 4: End of the line for Simon
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="display: flex; width: 100%; justify-content: center; align-items: center; gap: 100px;">
                        <div style="text-align: center; animation: simonFade 2s forwards;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; margin: 0 auto;
                                        background: linear-gradient(135deg, #1e90ff, #00ff00);
                                        box-shadow: 0 0 20px #00ff00;"></div>
                            <div style="color: #00ff00; font-size: 24px; margin-top: 15px;">SIMON</div>
                            <div style="color: #666; font-size: 16px; margin-top: 10px;">Abilities Disabled</div>
                        </div>
                        <div style="font-size: 60px; color: #ff0000;">💀</div>
                        <div style="text-align: center;">
                            <div style="width: 120px; height: 120px; border-radius: 50%; margin: 0 auto;
                                        background: radial-gradient(#fff, #ff6666, #8b0000);
                                        box-shadow: 0 0 80px #ff0000, 0 0 150px #ff6600;
                                        animation: transcendPulse 0.5s infinite;"></div>
                            <div style="color: #ff0000; font-size: 28px; margin-top: 15px; animation: deathGlow 1s infinite;">
                                THE ETERNAL
                            </div>
                            <div style="color: #ff6600; font-size: 16px; margin-top: 10px;">TRANSCENDENCE</div>
                        </div>
                    </div>
                `;
            }, 6500);

            // Phase 5: This is the end
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="font-size: 50px; color: #ff0000; font-weight: bold;
                                text-shadow: 0 0 30px #ff0000; animation: deathGlow 0.5s infinite;">
                        "This is the end of the line, Simon."
                    </div>
                    <div style="font-size: 28px; color: #888; margin-top: 30px; font-style: italic;">
                        All enemy abilities have been sealed.
                    </div>
                    <div style="font-size: 24px; color: #ff6600; margin-top: 20px;">
                        Laser nukes incoming...
                    </div>
                `;
            }, 9000);

            // Cleanup and resume
            setTimeout(() => {
                overlay.style.transition = 'opacity 1s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                }, 1000);
            }, 12000);
        }

        // SIMON VS ETERNAL - Spiral Power vs Eternity
        function triggerSimonVsEternal() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: linear-gradient(90deg, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.9) 50%, rgba(26,0,0,0.9) 100%),
                            url('simon_bg.png') left center / 50% 100% no-repeat,
                            linear-gradient(90deg, #001a00 0%, #000 50%, #1a0000 100%);
                z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            const style = document.createElement('style');
            style.textContent = `
                @keyframes spiralGlow {
                    0%, 100% { text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00; filter: hue-rotate(0deg); }
                    50% { text-shadow: 0 0 40px #00ff00, 0 0 80px #00ffff; filter: hue-rotate(30deg); }
                }
                @keyframes eternalGlow {
                    0%, 100% { text-shadow: 0 0 20px #ffd700, 0 0 40px #ff6600; }
                    50% { text-shadow: 0 0 40px #ffd700, 0 0 80px #ff0000, 0 0 120px #ff6600; }
                }
                @keyframes drillSpin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
                @keyframes powerUp {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.3); }
                    100% { transform: scale(1); }
                }
                @keyframes clash {
                    0% { transform: translateX(0); }
                    25% { transform: translateX(50px); }
                    50% { transform: translateX(-50px); }
                    75% { transform: translateX(30px); }
                    100% { transform: translateX(0); }
                }
            `;
            document.head.appendChild(style);

            // Phase 1: Introduction
            overlay.innerHTML = `
                <div style="color: #00ff00; font-size: 28px; animation: spiralGlow 1s infinite;">
                    The one who fights against fate...
                </div>
                <div style="margin-top: 30px; display: flex; gap: 150px; align-items: center;">
                    <div style="width: 80px; height: 80px; border-radius: 50%;
                                background: linear-gradient(135deg, #1e90ff, #00ff00);
                                box-shadow: 0 0 40px #00ff00; animation: drillSpin 2s linear infinite;"></div>
                    <div style="font-size: 50px; color: #fff; font-weight: bold;">VS</div>
                    <div style="width: 80px; height: 80px; border-radius: 50%;
                                background: radial-gradient(#ffd700, #ff6600, #8b0000);
                                box-shadow: 0 0 40px #ffd700; animation: eternalGlow 1.5s infinite;"></div>
                </div>
                <div style="color: #ffd700; font-size: 28px; margin-top: 30px; animation: eternalGlow 1s infinite;">
                    ...meets the one who transcends it.
                </div>
            `;

            // Phase 2: Names
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="display: flex; width: 100%; height: 100%;">
                        <div style="flex: 1; display: flex; justify-content: center; align-items: center;
                                    background: url('simon_bg.png') center/cover no-repeat;
                                    position: relative;">
                            <div style="position: absolute; inset: 0; background: rgba(0,0,0,0.5);"></div>
                            <div style="text-align: center; position: relative; z-index: 1;">
                                <div style="font-size: 50px; color: #00ff00; font-weight: bold; animation: spiralGlow 0.5s infinite;">
                                    SIMON
                                </div>
                                <div style="font-size: 20px; color: #00ffff; margin-top: 10px;">
                                    The Digger
                                </div>
                                <div style="font-size: 16px; color: #88ff88; margin-top: 5px; font-style: italic;">
                                    "My drill is the drill<br>that creates the heavens!"
                                </div>
                            </div>
                        </div>
                        <div style="width: 100px; display: flex; justify-content: center; align-items: center;
                                    background: linear-gradient(180deg, #000 0%, #333 50%, #000 100%);">
                            <div style="font-size: 60px; color: #ff6600;">⚔️</div>
                        </div>
                        <div style="flex: 1; display: flex; justify-content: center; align-items: center;
                                    background: radial-gradient(circle at center, #2a1a00 0%, #1a0000 50%, #000 100%);">
                            <div style="text-align: center;">
                                <div style="font-size: 50px; color: #ffd700; font-weight: bold; animation: eternalGlow 0.5s infinite;">
                                    THE ETERNAL
                                </div>
                                <div style="font-size: 20px; color: #ff6600; margin-top: 10px;">
                                    Deathless One
                                </div>
                                <div style="font-size: 16px; color: #ffcc88; margin-top: 5px; font-style: italic;">
                                    "I have died<br>a thousand deaths..."
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }, 3000);

            // Phase 3: Power up sequence
            setTimeout(() => {
                overlay.style.background = '#000';
                overlay.innerHTML = `
                    <div style="font-size: 40px; color: #fff; margin-bottom: 40px;">
                        POWER RESONANCE DETECTED
                    </div>
                    <div style="display: flex; gap: 200px;">
                        <div style="text-align: center; animation: powerUp 0.5s infinite;">
                            <div style="font-size: 80px;">🌀</div>
                            <div style="color: #00ff00; font-size: 24px; margin-top: 10px;">SPIRAL POWER</div>
                            <div style="color: #00ffff; font-size: 18px;">AMPLIFYING...</div>
                        </div>
                        <div style="text-align: center; animation: powerUp 0.5s infinite 0.25s;">
                            <div style="font-size: 80px;">♾️</div>
                            <div style="color: #ffd700; font-size: 24px; margin-top: 10px;">ETERNAL POWER</div>
                            <div style="color: #ff6600; font-size: 18px;">AWAKENING...</div>
                        </div>
                    </div>
                `;
            }, 6000);

            // Phase 4: Buffs applied
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="font-size: 50px; color: #fff; margin-bottom: 30px; animation: clash 0.3s infinite;">
                        ⚡ POWERS COLLIDE ⚡
                    </div>
                    <div style="display: flex; gap: 80px; margin-top: 20px;">
                        <div style="background: rgba(0, 255, 0, 0.2); padding: 20px 30px; border-radius: 10px; border: 2px solid #00ff00;">
                            <div style="color: #00ff00; font-size: 22px; font-weight: bold;">SIMON BUFFED</div>
                            <div style="color: #88ff88; font-size: 16px; margin-top: 10px;">+500 HP</div>
                            <div style="color: #88ff88; font-size: 16px;">+50% Damage</div>
                            <div style="color: #88ff88; font-size: 16px;">+1000 Shield</div>
                            <div style="color: #88ff88; font-size: 16px;">Spiral Overdrive!</div>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.2); padding: 20px 30px; border-radius: 10px; border: 2px solid #ffd700;">
                            <div style="color: #ffd700; font-size: 22px; font-weight: bold;">ETERNAL BUFFED</div>
                            <div style="color: #ffcc88; font-size: 16px; margin-top: 10px;">Starts at Form 4!</div>
                            <div style="color: #ffcc88; font-size: 16px;">+500% Damage</div>
                            <div style="color: #ffcc88; font-size: 16px;">+1500 Shield</div>
                            <div style="color: #ffcc88; font-size: 16px;">6x HP!</div>
                            <div style="color: #ffcc88; font-size: 16px;">ETERNITY UNLEASHED!</div>
                        </div>
                    </div>
                `;

                // Award achievement
                if (!gameData.achievements.includes('spiral_eternity')) {
                    checkAchievement('spiral_eternity', 'SPIRAL VS ETERNITY',
                        'Witnessed the clash between Spiral Power and Eternal Will',
                        '+10000$ for this legendary battle!');
                    gameData.currency += 10000;
                    saveGameData();
                    updateCurrencyDisplay();
                }
            }, 8500);

            // Phase 5: LET THEM FIGHT
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="font-size: 80px; color: #fff; font-weight: bold;
                                text-shadow: 0 0 30px #00ff00, 0 0 60px #ffd700;
                                animation: powerUp 0.3s infinite;">
                        LET THEM FIGHT!
                    </div>
                    <div style="font-size: 30px; color: #aaa; margin-top: 30px;">
                        Both fighters have been empowered!
                    </div>
                `;
            }, 11000);

            // Cleanup and start fight
            setTimeout(() => {
                overlay.style.transition = 'opacity 1s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                    // Set flag for buffs
                    window.simonEternalBuff = true;
                    // Continue with the fight
                    document.getElementById('winnerDisplay').style.display = 'none';
                    currentRound = 1;
                    document.getElementById('roundDisplay').textContent = `Round ${currentRound} / ${settings.rounds}`;
                    startRound();
                }, 1000);
            }, 13000);
        }

        // ETERNAL VS PARADOX - The Ultimate Showdown
        function triggerEternalVsParadox() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #000; z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            const style = document.createElement('style');
            style.textContent = `
                @keyframes cosmicClash {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.1); }
                }
                @keyframes infinityPulse {
                    0%, 100% { filter: hue-rotate(0deg) brightness(1); }
                    50% { filter: hue-rotate(180deg) brightness(1.5); }
                }
                @keyframes goldenBlaze {
                    0%, 100% { text-shadow: 0 0 30px #ffd700; }
                    50% { text-shadow: 0 0 80px #ffd700, 0 0 150px #ff8800; }
                }
                @keyframes paradoxWarp {
                    0%, 100% { text-shadow: 0 0 30px #00ffff; }
                    50% { text-shadow: 0 0 80px #00ffff, 0 0 150px #ff00ff; }
                }
                @keyframes shatter {
                    0% { transform: scale(1); opacity: 1; }
                    100% { transform: scale(3); opacity: 0; }
                }
                @keyframes victoryGlow {
                    0%, 100% { filter: brightness(1); }
                    50% { filter: brightness(2); }
                }
            `;
            document.head.appendChild(style);

            // 50/50 chance
            const eternalWins = Math.random() < 0.5;

            // Phase 1: Introduction
            overlay.innerHTML = `
                <div style="font-size: 36px; color: #fff; margin-bottom: 40px;">
                    Two forces that should never meet...
                </div>
                <div style="display: flex; gap: 150px; align-items: center;">
                    <div style="text-align: center;">
                        <div style="width: 120px; height: 120px; border-radius: 50%;
                                    background: radial-gradient(#fff, #ffd700, #ff8800);
                                    animation: cosmicClash 1s infinite;
                                    box-shadow: 0 0 50px #ffd700;"></div>
                        <div style="color: #ffd700; font-size: 28px; margin-top: 20px;
                                    animation: goldenBlaze 1s infinite;">THE ETERNAL</div>
                    </div>
                    <div style="font-size: 60px; color: #fff;">VS</div>
                    <div style="text-align: center;">
                        <div style="width: 120px; height: 120px; border-radius: 50%;
                                    background: radial-gradient(#fff, #00ffff, #0066ff);
                                    animation: cosmicClash 1s infinite, infinityPulse 2s infinite;
                                    box-shadow: 0 0 50px #00ffff;"></div>
                        <div style="color: #00ffff; font-size: 28px; margin-top: 20px;
                                    animation: paradoxWarp 1s infinite;">PARADOXICAL</div>
                    </div>
                </div>
            `;

            // Phase 2: Dialogue
            setTimeout(() => {
                overlay.innerHTML = `
                    <div style="font-size: 28px; color: #ffd700; margin-bottom: 30px;
                                text-shadow: 0 0 20px #ffd700;">
                        "I have risen five times. I cannot be stopped."
                    </div>
                    <div style="font-size: 28px; color: #00ffff; margin-top: 30px;
                                text-shadow: 0 0 20px #00ffff;">
                        "Resurrection is meaningless when reality itself bends."
                    </div>
                `;
            }, 3000);

            // Phase 3: Clash
            setTimeout(() => {
                overlay.style.background = `radial-gradient(circle, #fff 0%, ${eternalWins ? '#ffd700' : '#00ffff'} 30%, #000 60%)`;
                overlay.innerHTML = `
                    <div style="font-size: 80px; color: #fff; font-weight: bold;
                                text-shadow: 0 0 50px #fff;">
                        CLASH!
                    </div>
                `;
            }, 6000);

            // Phase 4: Flash
            setTimeout(() => {
                overlay.style.background = '#fff';
                setTimeout(() => {
                    overlay.style.transition = 'background 0.5s';
                    overlay.style.background = '#000';
                }, 200);
            }, 8000);

            // Phase 5: Outcome
            setTimeout(() => {
                if (eternalWins) {
                    overlay.innerHTML = `
                        <div style="font-size: 70px; color: #ffd700; font-weight: bold;
                                    text-shadow: 0 0 50px #ffd700, 0 0 100px #ff8800;
                                    animation: goldenBlaze 0.5s infinite;">
                            THE ETERNAL PREVAILS
                        </div>
                        <div style="margin-top: 40px;">
                            <div style="font-size: 30px; color: #fff; margin-bottom: 20px;">
                                "Even infinity has an end."
                            </div>
                            <div style="font-size: 24px; color: #aaa;">
                                The Paradox collapses into finite existence
                            </div>
                        </div>
                        <div style="margin-top: 50px;">
                            <div style="width: 100px; height: 100px; border-radius: 50%;
                                        background: radial-gradient(#fff, #ffd700);
                                        animation: victoryGlow 0.5s infinite;"></div>
                        </div>
                    `;
                    if (!gameData.achievements.includes('eternal_conquers_infinity')) {
                        setTimeout(() => {
                            checkAchievement('eternal_conquers_infinity', 'ETERNAL CONQUERS INFINITY',
                                'The Eternal proved even infinity has limits',
                                '+7500$ for breaking the unbreakable!');
                            gameData.currency += 7500;
                            saveGameData();
                            updateCurrencyDisplay();
                        }, 1000);
                    }
                } else {
                    overlay.innerHTML = `
                        <div style="font-size: 70px; font-weight: bold;
                                    background: linear-gradient(90deg, #00ffff, #ff00ff, #00ffff);
                                    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
                                    animation: infinityPulse 0.5s infinite;">
                            PARADOX PREVAILS
                        </div>
                        <div style="margin-top: 40px;">
                            <div style="font-size: 30px; color: #fff; margin-bottom: 20px;">
                                "Eternity is just another concept I transcend."
                            </div>
                            <div style="font-size: 24px; color: #aaa;">
                                The Eternal's cycle is broken permanently
                            </div>
                        </div>
                        <div style="margin-top: 50px; font-size: 120px; color: #00ffff;
                                    text-shadow: 0 0 50px #00ffff;
                                    animation: paradoxWarp 0.5s infinite;">
                            &#8734;
                        </div>
                    `;
                    if (!gameData.achievements.includes('infinity_breaks_eternity')) {
                        setTimeout(() => {
                            checkAchievement('infinity_breaks_eternity', 'INFINITY BREAKS ETERNITY',
                                'Paradoxical proved nothing can outlast infinity',
                                '+7500$ for transcending cycles!');
                            gameData.currency += 7500;
                            saveGameData();
                            updateCurrencyDisplay();
                        }, 1000);
                    }
                }
            }, 9000);

            // Cleanup
            setTimeout(() => {
                overlay.style.transition = 'opacity 2s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                    document.getElementById('startButton').disabled = false;
                }, 2000);
            }, 14000);
        }

        // ETERNAL TRANSFORMATION CUTSCENES
        function triggerEternalTransformation(ball, newForm) {
            // Quick visual effect (no pause)

            const formNames = ['', 'SEED', 'SPARK', 'FLAME', 'NOVA', 'ETERNAL'];
            const formColors = ['', '#888888', '#00ffff', '#ff4400', '#aa00ff', '#ffd700'];
            const formDescriptions = [
                '',
                'A dormant power awaits...',
                'AWAKENING! Lightning surges through!',
                'IGNITION! Flames of rebirth!',
                'ASCENSION! Cosmic power unleashed!',
                'TRANSCENDENCE! THE ETERNAL RISES!'
            ];

            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column; pointer-events: none;
            `;
            document.body.appendChild(overlay);

            // Add animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes transformPulse {
                    0%, 100% { transform: scale(1); filter: brightness(1); }
                    50% { transform: scale(1.2); filter: brightness(2); }
                }
                @keyframes transformRays {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
                }
                @keyframes transformGlow {
                    0%, 100% { box-shadow: 0 0 50px ${formColors[newForm]}; }
                    50% { box-shadow: 0 0 150px ${formColors[newForm]}, 0 0 300px ${formColors[newForm]}; }
                }
                @keyframes laserCharge {
                    0% { width: 0; opacity: 0; }
                    50% { width: 400px; opacity: 1; }
                    100% { width: 800px; opacity: 0; }
                }
            `;
            document.head.appendChild(style);

            // Form-specific cutscenes
            switch(newForm) {
                case 2: // SPARK awakening
                    overlay.innerHTML = `
                        <div style="position: relative;">
                            <div style="width: 100px; height: 100px; border-radius: 50%;
                                        background: radial-gradient(#fff, ${formColors[2]}, #000);
                                        animation: transformPulse 0.5s infinite, transformGlow 0.5s infinite;">
                            </div>
                        </div>
                        <div style="color: ${formColors[2]}; font-size: 48px; font-weight: bold;
                                    margin-top: 30px; text-shadow: 0 0 30px ${formColors[2]};">
                            ${formNames[2]}
                        </div>
                        <div style="color: #fff; font-size: 24px; margin-top: 20px;">
                            ${formDescriptions[2]}
                        </div>
                    `;
                    break;

                case 3: // FLAME ignition
                    overlay.style.background = 'radial-gradient(circle, rgba(255,68,0,0.3) 0%, rgba(0,0,0,0.95) 70%)';
                    overlay.innerHTML = `
                        <div style="position: relative;">
                            <div style="width: 120px; height: 120px; border-radius: 50%;
                                        background: radial-gradient(#fff, #ffff00, #ff4400, #880000);
                                        animation: transformPulse 0.3s infinite, transformGlow 0.3s infinite;">
                            </div>
                            <div style="position: absolute; top: 50%; left: 50%; width: 200px; height: 200px;
                                        margin-left: -100px; margin-top: -100px;
                                        border: 3px solid #ff4400; border-radius: 50%; opacity: 0.5;
                                        animation: transformRays 1s linear infinite;">
                            </div>
                        </div>
                        <div style="color: ${formColors[3]}; font-size: 56px; font-weight: bold;
                                    margin-top: 30px; text-shadow: 0 0 50px #ff0000;">
                            ${formNames[3]}
                        </div>
                        <div style="color: #ffaa00; font-size: 28px; margin-top: 20px;">
                            ${formDescriptions[3]}
                        </div>
                    `;
                    break;

                case 4: // NOVA ascension
                    overlay.style.background = 'radial-gradient(circle, rgba(170,0,255,0.4) 0%, rgba(0,0,0,0.95) 60%)';
                    overlay.innerHTML = `
                        <div style="position: relative;">
                            <div style="width: 150px; height: 150px; border-radius: 50%;
                                        background: radial-gradient(#fff, #ff88ff, #aa00ff, #330066);
                                        animation: transformPulse 0.4s infinite, transformGlow 0.4s infinite;">
                            </div>
                            <!-- Orbiting elements -->
                            <div style="position: absolute; top: 50%; left: 50%; width: 300px; height: 300px;
                                        margin-left: -150px; margin-top: -150px;
                                        animation: transformRays 2s linear infinite;">
                                <div style="position: absolute; top: 0; left: 50%; width: 15px; height: 15px;
                                            background: #fff; border-radius: 50%; margin-left: -7px;"></div>
                                <div style="position: absolute; bottom: 0; left: 50%; width: 15px; height: 15px;
                                            background: #fff; border-radius: 50%; margin-left: -7px;"></div>
                                <div style="position: absolute; left: 0; top: 50%; width: 15px; height: 15px;
                                            background: #fff; border-radius: 50%; margin-top: -7px;"></div>
                                <div style="position: absolute; right: 0; top: 50%; width: 15px; height: 15px;
                                            background: #fff; border-radius: 50%; margin-top: -7px;"></div>
                            </div>
                        </div>
                        <div style="color: ${formColors[4]}; font-size: 64px; font-weight: bold;
                                    margin-top: 40px; text-shadow: 0 0 60px #ff00ff;">
                            ${formNames[4]}
                        </div>
                        <div style="color: #cc88ff; font-size: 30px; margin-top: 25px;">
                            ${formDescriptions[4]}
                        </div>
                    `;
                    break;

                case 5: // ETERNAL transcendence - the big one!
                    overlay.style.background = '#000';

                    // Multi-phase cutscene for final form
                    overlay.innerHTML = `
                        <div style="color: #fff; font-size: 30px;">The cycle completes...</div>
                    `;

                    setTimeout(() => {
                        overlay.style.background = 'radial-gradient(circle, #ffd700 0%, #ff8800 20%, #000 50%)';
                        overlay.innerHTML = `
                            <div style="position: relative;">
                                <div style="width: 200px; height: 200px; border-radius: 50%;
                                            background: radial-gradient(#fff, #ffd700, #ff8800);
                                            animation: transformPulse 0.2s infinite;">
                                </div>
                                <!-- Multiple rings -->
                                <div style="position: absolute; top: 50%; left: 50%; width: 400px; height: 400px;
                                            margin-left: -200px; margin-top: -200px;
                                            border: 4px solid #ffd700; border-radius: 50%; opacity: 0.7;
                                            animation: transformRays 3s linear infinite;">
                                </div>
                                <div style="position: absolute; top: 50%; left: 50%; width: 500px; height: 500px;
                                            margin-left: -250px; margin-top: -250px;
                                            border: 2px solid #ffaa00; border-radius: 50%; opacity: 0.5;
                                            animation: transformRays 4s linear infinite reverse;">
                                </div>
                            </div>
                        `;
                    }, 500);

                    setTimeout(() => {
                        // Flash
                        overlay.style.background = '#fff';
                        setTimeout(() => {
                            overlay.style.background = 'radial-gradient(circle, rgba(255,215,0,0.5) 0%, #000 40%)';
                            overlay.innerHTML = `
                                <div style="font-size: 100px; color: #ffd700; font-weight: bold;
                                            text-shadow: 0 0 50px #ffd700, 0 0 100px #ff8800;">
                                    THE ETERNAL
                                </div>
                                <div style="font-size: 36px; color: #fff; margin-top: 30px;">
                                    ${formDescriptions[5]}
                                </div>
                                <div style="margin-top: 40px; display: flex; gap: 20px;">
                                    <div style="width: 20px; height: 300px; background: linear-gradient(0deg, transparent, #ffd700);
                                                animation: laserCharge 1s ease-out forwards;"></div>
                                    <div style="width: 20px; height: 300px; background: linear-gradient(0deg, transparent, #ff8800);
                                                animation: laserCharge 1s ease-out 0.2s forwards;"></div>
                                    <div style="width: 20px; height: 300px; background: linear-gradient(0deg, transparent, #ffd700);
                                                animation: laserCharge 1s ease-out 0.4s forwards;"></div>
                                </div>
                                <div style="font-size: 28px; color: #ffaa00; margin-top: 40px;">
                                    ALL STATS MAXIMIZED
                                </div>
                            `;
                        }, 100);
                    }, 1500);
                    break;
            }

            // Duration based on form
            const duration = newForm === 5 ? 1500 : 800;

            setTimeout(() => {
                overlay.style.transition = 'opacity 0.5s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                    gameRunning = true;

                    // Achievement for reaching final form
                    if (newForm === 5 && !gameData.achievements.includes('eternal_transcendence')) {
                        checkAchievement('eternal_transcendence', 'ETERNAL TRANSCENDENCE',
                            'Witnessed The Eternal reach its final form',
                            '+10000$ for witnessing true power!');
                        gameData.currency += 10000;
                        saveGameData();
                        updateCurrencyDisplay();
                    }
                }, 500);
            }, duration);
        }

        function triggerCloneArmy(weapon) {
            // This one doesn't stop the game, just adds epic intro
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
                animation: fadeIn 0.5s ease-out;
            `;
            document.body.appendChild(overlay);

            overlay.innerHTML = `
                <div style="font-size: 50px; color: #ff6600; font-weight: bold;
                            text-shadow: 0 0 20px #ff6600;">
                    CLONE ARMY DETECTED
                </div>
                <div style="font-size: 30px; color: #fff; margin-top: 20px;">
                    ${weapon ? weapon.name : 'Unknown'} x${settings.selectedBalls.length}
                </div>
                <div style="font-size: 24px; color: #aaa; margin-top: 30px;">
                    Prepare for CHAOS
                </div>
                <div style="font-size: 100px; margin-top: 20px;">
                    ${'&#9876; '.repeat(Math.min(settings.selectedBalls.length, 6))}
                </div>
            `;

            // Quick intro then start battle
            setTimeout(() => {
                overlay.style.transition = 'opacity 0.5s';
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 500);
            }, 2000);
        }

        function triggerCashParadox() {
            // Create cash flood overlay
            const overlay = document.createElement('div');
            overlay.id = 'cashParadoxOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: linear-gradient(180deg, #000 0%, #1a472a 50%, #000 100%);
                z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column; overflow: hidden;
            `;
            document.body.appendChild(overlay);

            // Add styles
            const style = document.createElement('style');
            style.id = 'cashParadoxStyles';
            style.textContent = `
                @keyframes moneyFall {
                    0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
                    100% { transform: translateY(120vh) rotate(720deg); opacity: 0.8; }
                }
                @keyframes moneyShake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-10px); }
                    75% { transform: translateX(10px); }
                }
                @keyframes goldPulse {
                    0%, 100% { text-shadow: 0 0 20px #ffd700, 0 0 40px #ffaa00; }
                    50% { text-shadow: 0 0 40px #ffd700, 0 0 80px #ffaa00, 0 0 120px #ff8800; }
                }
                @keyframes cashWave {
                    0% { background-position: 0% 50%; }
                    100% { background-position: 200% 50%; }
                }
                .money-bill {
                    position: absolute;
                    font-size: 40px;
                    animation: moneyFall linear forwards;
                    pointer-events: none;
                    text-shadow: 0 0 10px #00ff00;
                }
                .cash-explosion {
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    background: radial-gradient(circle, rgba(0,255,0,0.3) 0%, transparent 70%);
                    animation: cashWave 0.5s infinite;
                }
            `;
            document.head.appendChild(style);

            // Phase 1: Detection
            overlay.innerHTML = `
                <div style="color: #00ff00; font-size: 36px; font-weight: bold;
                            text-shadow: 0 0 20px #00ff00; animation: moneyShake 0.2s infinite;">
                    ECONOMIC ANOMALY DETECTED
                </div>
                <div style="color: #ffd700; font-size: 24px; margin-top: 20px;">
                    Paradoxical meets Infinite Wealth...
                </div>
            `;

            // Start spawning money bills
            let billInterval = setInterval(() => {
                const bill = document.createElement('div');
                bill.className = 'money-bill';
                bill.textContent = ['$', '$$', '$$$', 'ðŸ’µ', 'ðŸ’°', 'ðŸ’Ž'][Math.floor(Math.random() * 6)];
                bill.style.left = Math.random() * 100 + '%';
                bill.style.top = '-50px';
                bill.style.fontSize = (20 + Math.random() * 40) + 'px';
                bill.style.animationDuration = (2 + Math.random() * 3) + 's';
                overlay.appendChild(bill);
                setTimeout(() => bill.remove(), 5000);
            }, 50);

            // Phase 2: Realization (after 2s)
            setTimeout(() => {
                overlay.innerHTML += `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                                color: #ffd700; font-size: 50px; font-weight: bold;
                                animation: goldPulse 0.5s infinite; z-index: 10;">
                        CASH PARADOX
                    </div>
                `;
            }, 2000);

            // Phase 3: The Flood (after 4s)
            setTimeout(() => {
                // Intensify money rain
                clearInterval(billInterval);
                billInterval = setInterval(() => {
                    for (let i = 0; i < 5; i++) {
                        const bill = document.createElement('div');
                        bill.className = 'money-bill';
                        bill.textContent = ['$$$', 'ðŸ’µ', 'ðŸ’°', 'ðŸ’Ž', 'ðŸ¤‘'][Math.floor(Math.random() * 5)];
                        bill.style.left = Math.random() * 100 + '%';
                        bill.style.fontSize = (30 + Math.random() * 50) + 'px';
                        bill.style.animationDuration = (1 + Math.random() * 2) + 's';
                        overlay.appendChild(bill);
                        setTimeout(() => bill.remove(), 3000);
                    }
                }, 30);

                // Green flash
                overlay.style.background = '#00ff00';
                setTimeout(() => {
                    overlay.style.background = 'linear-gradient(180deg, #0a2a0a 0%, #1a5a2a 30%, #2a8a3a 50%, #1a5a2a 70%, #0a2a0a 100%)';
                }, 100);

            }, 4000);

            // Phase 4: Universe Flooded (after 6s)
            setTimeout(() => {
                clearInterval(billInterval);

                // Rising money level effect
                const moneyLevel = document.createElement('div');
                moneyLevel.style.cssText = `
                    position: absolute; bottom: 0; left: 0; width: 100%;
                    height: 0; background: linear-gradient(0deg,
                        #ffd700 0%, #ffaa00 20%, #00aa00 40%,
                        rgba(0,170,0,0.5) 70%, transparent 100%);
                    transition: height 3s ease-out;
                    z-index: 5;
                `;
                overlay.appendChild(moneyLevel);
                setTimeout(() => moneyLevel.style.height = '100%', 100);

                // Spawn floating money symbols
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const symbol = document.createElement('div');
                        symbol.style.cssText = `
                            position: absolute;
                            left: ${Math.random() * 100}%;
                            bottom: ${Math.random() * 100}%;
                            font-size: ${40 + Math.random() * 60}px;
                            color: #ffd700;
                            text-shadow: 0 0 20px #ffaa00;
                            z-index: 6;
                            animation: goldPulse 1s infinite;
                        `;
                        symbol.textContent = '$';
                        overlay.appendChild(symbol);
                    }, i * 50);
                }

            }, 6000);

            // Phase 5: Result (after 9s)
            setTimeout(() => {
                overlay.innerHTML = '';
                overlay.style.background = 'radial-gradient(circle, #2a5a2a 0%, #0a2a0a 50%, #000 100%)';

                // Floating money background
                for (let i = 0; i < 30; i++) {
                    const bill = document.createElement('div');
                    bill.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        font-size: ${30 + Math.random() * 40}px;
                        opacity: 0.3;
                        animation: goldPulse 2s infinite;
                    `;
                    bill.textContent = '$';
                    overlay.appendChild(bill);
                }

                const msg = document.createElement('div');
                msg.style.cssText = `
                    position: absolute; top: 50%; left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center; z-index: 10;
                `;
                msg.innerHTML = `
                    <div style="font-size: 70px; color: #ffd700; font-weight: bold;
                                text-shadow: 0 0 30px #ffaa00, 0 0 60px #ff8800;
                                animation: goldPulse 1s infinite;">
                        UNIVERSE FLOODED
                    </div>
                    <div style="font-size: 40px; color: #00ff00; margin-top: 20px;
                                text-shadow: 0 0 20px #00ff00;">
                        INFINITE WEALTH OVERFLOW
                    </div>
                    <div style="font-size: 80px; color: #ffd700; margin-top: 30px;
                                animation: goldPulse 0.5s infinite;">
                        $$$ DRAW $$$
                    </div>
                    <div style="font-size: 20px; color: #aaffaa; margin-top: 40px;">
                        When infinite money meets infinite paradox...
                    </div>
                    <div style="font-size: 18px; color: #88ff88; margin-top: 10px;">
                        Everyone wins. Everyone loses. Everyone is rich.
                    </div>
                `;
                overlay.appendChild(msg);

            }, 9000);

            // Phase 6: Cleanup (after 13s)
            setTimeout(() => {
                overlay.style.transition = 'opacity 2s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                    document.getElementById('startButton').disabled = false;

                    // Grant achievement + 1 MILLION
                    if (!gameData.achievements.includes('cash_paradox')) {
                        checkAchievement('cash_paradox', 'CASH PARADOX',
                            'Flooded the universe with infinite wealth',
                            '+$1,000,000 !!!');
                        gameData.currency += 1000000;
                        saveGameData();
                        updateCurrencyDisplay();
                    }
                }, 2000);
            }, 13000);
        }

        // THE ETERNAL - Form-based abilities
        function useEternalPulse() {
            const form = this.eternalForm || 1;

            switch(form) {
                case 1: // SEED - Weak pulse
                    particles.push({
                        x: this.x, y: this.y, vx: 0, vy: 0,
                        life: 20, color: '#888', size: 30, type: 'ring'
                    });
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.hypot(b.x - this.x, b.y - this.y);
                            if (dist < 80) {
                                b.takeDamage(3, this);
                            }
                        }
                    });
                    break;

                case 2: // SPARK - Chain lightning
                    let targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                    let lastPos = {x: this.x, y: this.y};
                    targets.sort((a,b) => Math.hypot(a.x-this.x, a.y-this.y) - Math.hypot(b.x-this.x, b.y-this.y));
                    targets.slice(0, 4).forEach(target => {
                        const dist = Math.hypot(target.x - lastPos.x, target.y - lastPos.y);
                        if (dist < 300) {
                            for (let i = 0; i < 10; i++) {
                                particles.push({
                                    x: lastPos.x + (target.x - lastPos.x) * i / 10,
                                    y: lastPos.y + (target.y - lastPos.y) * i / 10 + (Math.random()-0.5) * 20,
                                    vx: 0, vy: 0, life: 15, color: '#00ffff', size: 4
                                });
                            }
                            target.takeDamage(12, this);
                            target.stunned = 30;
                            lastPos = {x: target.x, y: target.y};
                        }
                    });
                    break;

                case 3: // FLAME - Fire nova
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        for (let r = 0; r < 150; r += 20) {
                            particles.push({
                                x: this.x + Math.cos(angle) * r,
                                y: this.y + Math.sin(angle) * r,
                                vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
                                life: 30, color: r < 75 ? '#ffff00' : '#ff4400', size: 8
                            });
                        }
                    }
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.hypot(b.x - this.x, b.y - this.y);
                            if (dist < 180) {
                                b.takeDamage(25, this);
                                b.burning = 180;
                            }
                        }
                    });
                    break;

                case 4: // NOVA - Gravity well
                    balls.forEach(b => {
                        if (b !== this && b.alive) {
                            const dx = this.x - b.x;
                            const dy = this.y - b.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist < 250 && dist > 30) {
                                const force = 8 / dist;
                                b.vx += dx * force;
                                b.vy += dy * force;
                                if (!this.isTeammate(b)) {
                                    b.takeDamage(15, this);
                                }
                            }
                        }
                    });
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 50 + Math.random() * 200;
                        particles.push({
                            x: this.x + Math.cos(angle) * dist,
                            y: this.y + Math.sin(angle) * dist,
                            vx: -Math.cos(angle) * 5, vy: -Math.sin(angle) * 5,
                            life: 40, color: '#aa00ff', size: 5
                        });
                    }
                    break;

                case 5: // ETERNAL - MEGA LASER BARRAGE
                    this.firingEternalLaser = true;
                    this.laserAngle = 0;
                    this.laserDuration = 180;
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                        projectiles.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15,
                            damage: 40, owner: this, size: 12,
                            color: '#ffd700', trail: true, piercing: true,
                            life: 120
                        });
                    }
                    break;
            }
        }

        function triggerParadoxClash() {
            // Create universe rip overlay
            const overlay = document.createElement('div');
            overlay.id = 'paradoxClashOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: #000; z-index: 100000;
                display: flex; justify-content: center; align-items: center;
                flex-direction: column;
            `;
            document.body.appendChild(overlay);

            // Add styles for the effect
            const style = document.createElement('style');
            style.id = 'paradoxClashStyles';
            style.textContent = `
                @keyframes universeShake {
                    0%, 100% { transform: translate(0, 0); }
                    10% { transform: translate(-10px, -10px); }
                    20% { transform: translate(10px, 10px); }
                    30% { transform: translate(-15px, 5px); }
                    40% { transform: translate(15px, -5px); }
                    50% { transform: translate(-5px, 15px); }
                    60% { transform: translate(5px, -15px); }
                    70% { transform: translate(-20px, 0); }
                    80% { transform: translate(20px, 0); }
                    90% { transform: translate(-10px, 10px); }
                }
                @keyframes ripTear {
                    0% { clip-path: polygon(50% 0%, 50% 0%, 50% 100%, 50% 100%); }
                    100% { clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
                }
                @keyframes glitchText {
                    0%, 100% { transform: translate(0, 0) skew(0deg); filter: hue-rotate(0deg); }
                    20% { transform: translate(-5px, 2px) skew(5deg); filter: hue-rotate(90deg); }
                    40% { transform: translate(5px, -2px) skew(-5deg); filter: hue-rotate(180deg); }
                    60% { transform: translate(-3px, -3px) skew(3deg); filter: hue-rotate(270deg); }
                    80% { transform: translate(3px, 3px) skew(-3deg); filter: hue-rotate(360deg); }
                }
                @keyframes voidPulse {
                    0%, 100% { opacity: 0.3; }
                    50% { opacity: 0.8; }
                }
                @keyframes fadeInUp {
                    from { opacity: 0; transform: translateY(50px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                .rip-line {
                    position: absolute;
                    background: linear-gradient(90deg, transparent, #fff, #00ffff, #ff00ff, #fff, transparent);
                    height: 4px;
                    animation: ripExpand 0.5s ease-out forwards;
                }
                @keyframes ripExpand {
                    from { width: 0; opacity: 1; }
                    to { width: 120%; opacity: 0; }
                }
                .void-crack {
                    position: absolute;
                    background: linear-gradient(to bottom,
                        transparent 0%,
                        rgba(255,0,255,0.5) 20%,
                        rgba(0,255,255,0.8) 40%,
                        #fff 50%,
                        rgba(0,255,255,0.8) 60%,
                        rgba(255,0,255,0.5) 80%,
                        transparent 100%
                    );
                    width: 8px;
                    filter: blur(2px);
                    box-shadow: 0 0 30px #00ffff, 0 0 60px #ff00ff;
                }
            `;
            document.head.appendChild(style);

            // Phase 1: Warning
            overlay.innerHTML = `
                <div style="color: #ff0000; font-size: 40px; font-weight: bold;
                            animation: glitchText 0.1s infinite; text-shadow: 0 0 20px #ff0000;">
                    âš  PARADOX DETECTED âš 
                </div>
                <div style="color: #fff; font-size: 24px; margin-top: 20px; opacity: 0.8;">
                    Two Paradoxicals cannot exist in the same reality...
                </div>
            `;

            // Phase 2: Reality cracking (after 1.5s)
            setTimeout(() => {
                overlay.style.animation = 'universeShake 0.3s infinite';
                overlay.innerHTML = `
                    <div style="color: #00ffff; font-size: 60px; font-weight: bold;
                                animation: glitchText 0.05s infinite;
                                text-shadow: 0 0 30px #00ffff, 0 0 60px #ff00ff;">
                        REALITY FRACTURING
                    </div>
                `;

                // Add crack lines
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const crack = document.createElement('div');
                        crack.className = 'void-crack';
                        crack.style.left = Math.random() * 100 + '%';
                        crack.style.top = '0';
                        crack.style.height = '100%';
                        crack.style.opacity = Math.random() * 0.5 + 0.5;
                        crack.style.transform = `rotate(${(Math.random() - 0.5) * 20}deg)`;
                        overlay.appendChild(crack);
                    }, i * 100);
                }
            }, 1500);

            // Phase 3: The Rip (after 3.5s)
            setTimeout(() => {
                overlay.style.animation = 'universeShake 0.1s infinite';

                // Central rip
                const rip = document.createElement('div');
                rip.style.cssText = `
                    position: absolute; top: 0; left: 50%;
                    transform: translateX(-50%);
                    width: 20px; height: 100%;
                    background: linear-gradient(90deg,
                        #000 0%,
                        #ff00ff 20%,
                        #00ffff 35%,
                        #fff 50%,
                        #00ffff 65%,
                        #ff00ff 80%,
                        #000 100%
                    );
                    box-shadow: 0 0 100px #fff, 0 0 200px #00ffff;
                    animation: tearOpen 1s ease-out forwards;
                `;
                overlay.appendChild(rip);

                // Add tear animation
                const tearStyle = document.createElement('style');
                tearStyle.textContent = `
                    @keyframes tearOpen {
                        0% { width: 0; opacity: 1; }
                        50% { width: 200px; opacity: 1; }
                        100% { width: 100%; opacity: 1; }
                    }
                `;
                document.head.appendChild(tearStyle);

                // Flash
                overlay.style.background = '#fff';
                setTimeout(() => {
                    overlay.style.background = '#000';
                }, 100);

            }, 3500);

            // Phase 4: Void (after 5s)
            setTimeout(() => {
                overlay.style.animation = 'none';
                overlay.innerHTML = '';
                overlay.style.background = 'radial-gradient(circle at center, #000 0%, #0a0010 50%, #000 100%)';

                // Void particles
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.style.cssText = `
                        position: absolute;
                        width: ${5 + Math.random() * 10}px;
                        height: ${5 + Math.random() * 10}px;
                        background: ${Math.random() > 0.5 ? '#00ffff' : '#ff00ff'};
                        border-radius: 50%;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        opacity: ${Math.random() * 0.5 + 0.2};
                        animation: voidPulse ${1 + Math.random() * 2}s infinite;
                        filter: blur(2px);
                    `;
                    overlay.appendChild(particle);
                }

                // Central message
                const msg = document.createElement('div');
                msg.style.cssText = `
                    position: absolute; top: 50%; left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center;
                    z-index: 10;
                `;
                msg.innerHTML = `
                    <div style="font-size: 80px; color: #fff; font-weight: bold;
                                text-shadow: 0 0 30px #00ffff, 0 0 60px #ff00ff;
                                animation: fadeInUp 1s ease-out;">
                        UNIVERSE TORN
                    </div>
                    <div style="font-size: 40px; color: #ff00ff; margin-top: 30px;
                                animation: fadeInUp 1s ease-out 0.3s both;">
                        REALITY COLLAPSED
                    </div>
                    <div style="font-size: 60px; color: #00ffff; margin-top: 40px;
                                animation: fadeInUp 1s ease-out 0.6s both;
                                text-shadow: 0 0 20px #00ffff;">
                        âˆž DRAW âˆž
                    </div>
                    <div style="font-size: 20px; color: #888; margin-top: 50px;
                                animation: fadeInUp 1s ease-out 0.9s both;">
                        Two paradoxes cannot coexist...
                    </div>
                `;
                overlay.appendChild(msg);

            }, 5000);

            // Phase 5: Cleanup (after 9s)
            setTimeout(() => {
                overlay.style.transition = 'opacity 2s';
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                    // Re-enable start button
                    document.getElementById('startButton').disabled = false;

                    // Grant achievement
                    if (!gameData.achievements.includes('reality_breaker')) {
                        checkAchievement('reality_breaker', 'REALITY BREAKER',
                            'Witnessed the universe tear itself apart',
                            '+2000$ and eternal bragging rights!');
                        gameData.currency += 2000;
                        saveGameData();
                        updateCurrencyDisplay();
                    }
                }, 2000);
            }, 9000);
        }

        function startGame() {
            // Check if bet is placed but game starting would be invalid
            if (currentBet && currentBet.active) {
                const betBallChecked = document.getElementById(`ball${currentBet.ballIndex}`)?.checked;
                if (!betBallChecked) {
                    alert('Your bet is on a ball that is not selected! Clear your bet or select that ball.');
                    return;
                }
            }

            settings.selectedBalls = [];
            lastBattleWeapons = []; // Reset battle tracking
            const swordIdx = weapons.findIndex(w => w.id === 'sword');

            ballConfigs.forEach((_, i) => {
                if (document.getElementById(`ball${i}`).checked) {
                    settings.selectedBalls.push(i);

                    let weaponIdx = parseInt(document.getElementById(`weapon${i}`).value);

                    // Validate weapon is unlocked
                    if (isNaN(weaponIdx) || weaponIdx < 0 || weaponIdx >= weapons.length) {
                        weaponIdx = swordIdx;
                    } else {
                        const weapon = weapons[weaponIdx];
                        if (!weapon || !isWeaponUnlocked(weapon.id)) {
                            console.warn(`Weapon ${weapon?.name || weaponIdx} not unlocked for ball ${i}, using Sword`);
                            weaponIdx = swordIdx;
                        }
                    }

                    settings.weaponAssignments[i] = weaponIdx;
                    settings.teamAssignments[i] = parseInt(document.getElementById(`team${i}`).value);
                    console.log(`Ball ${i} starting with weapon:`, weapons[weaponIdx]?.name);
                    if (weapons[weaponIdx]) {
                        lastBattleWeapons.push(weapons[weaponIdx].id);
                    }
                }
            });

            // Lock betting once game starts
            document.getElementById('placeBetBtn').disabled = true;
            document.getElementById('clearBetBtn').disabled = true;
            document.getElementById('betBallSelect').disabled = true;
            document.getElementById('betAmount').disabled = true;

            if (settings.selectedBalls.length < 2) {
                alert('Select at least 2 balls!');
                return;
            }

            // Check for PARADOX CLASH - two Paradoxicals fighting causes universe rip!
            const paradoxicalBalls = settings.selectedBalls.filter(i => {
                const weaponIdx = settings.weaponAssignments[i];
                return weapons[weaponIdx] && weapons[weaponIdx].id === 'paradoxical';
            });

            if (paradoxicalBalls.length >= 2) {
                if (!gameData.achievements.includes('paradox_clash')) {
                    triggerParadoxClash();
                    return;
                }
                // Achievement already earned - let them fight!
            }

            // Check for CASH PARADOX - Paradoxical + Money Ball
            const hasParadoxical = settings.selectedBalls.some(i => {
                const weaponIdx = settings.weaponAssignments[i];
                return weapons[weaponIdx] && weapons[weaponIdx].id === 'paradoxical';
            });
            const hasMoney = settings.selectedBalls.some(i => {
                const weaponIdx = settings.weaponAssignments[i];
                return weapons[weaponIdx] && weapons[weaponIdx].id === 'money';
            });

            if (hasParadoxical && hasMoney) {
                if (!gameData.achievements.includes('cash_paradox')) {
                    triggerCashParadox();
                    return;
                }
                // Achievement already earned - let them fight!
            }

            // THE TRINITY - Paradoxical + Archmage + Divinity
            const hasDivinity = settings.selectedBalls.some(i => weapons[settings.weaponAssignments[i]]?.id === 'divinity');
            const hasArchmage = settings.selectedBalls.some(i => weapons[settings.weaponAssignments[i]]?.id === 'archmage');
            if (hasParadoxical && hasDivinity && hasArchmage) {
                if (!gameData.achievements.includes('the_trinity')) {
                    triggerTheTrinity();
                    return;
                }
                // Achievement already earned - let them fight!
            }

            // DEATH PARADOX - Light Yagami + Paradoxical
            const hasLightYagami = settings.selectedBalls.some(i => weapons[settings.weaponAssignments[i]]?.id === 'lightyagami');
            if (hasParadoxical && hasLightYagami) {
                if (!gameData.achievements.includes('death_paradox')) {
                    triggerDeathParadox();
                    return;
                }
                // Achievement already earned - let them fight!
            }

            // DIVINE JUDGMENT - Light Yagami vs Divinity (exactly 2 balls)
            if (hasLightYagami && hasDivinity && settings.selectedBalls.length === 2) {
                if (!gameData.achievements.includes('divine_judgment')) {
                    triggerDivineJudgment();
                    return;
                }
                // Achievement already earned - let them fight!
            }

            // CLONE ARMY - All balls have same weapon (4+ balls)
            if (settings.selectedBalls.length >= 4) {
                const firstWeapon = settings.weaponAssignments[settings.selectedBalls[0]];
                const allSame = settings.selectedBalls.every(i => settings.weaponAssignments[i] === firstWeapon);
                if (allSame) {
                    triggerCloneArmy(weapons[firstWeapon]);
                    // Don't return - let the battle happen with a special effect!
                }
            }

            // KIRK VS KIRK - The Ultimate Tragedy (always plays!)
            const kirkBalls = settings.selectedBalls.filter(i => weapons[settings.weaponAssignments[i]]?.id === 'kirk');
            if (kirkBalls.length >= 2) {
                triggerKirked();
                return;
            }

            // ETERNAL VS PARADOX - The Ultimate Showdown
            const hasEternal = settings.selectedBalls.some(i => weapons[settings.weaponAssignments[i]]?.id === 'eternal');
            if (hasEternal && hasParadoxical && settings.selectedBalls.length === 2) {
                if (!gameData.achievements.includes('eternal_conquers_infinity') &&
                    !gameData.achievements.includes('infinity_breaks_eternity')) {
                    triggerEternalVsParadox();
                    return;
                }
                // Achievement already earned - let them fight!
            }

            // SIMON VS ETERNAL - Spiral Power vs Eternity (always plays!)
            const hasSimon = settings.selectedBalls.some(i => weapons[settings.weaponAssignments[i]]?.id === 'simon');
            if (hasSimon && hasEternal && settings.selectedBalls.length === 2) {
                triggerSimonVsEternal();
                return;
            }

            document.getElementById('winnerDisplay').style.display = 'none';
            currentRound = 1;
            document.getElementById('roundDisplay').textContent = `Round ${currentRound} / ${settings.rounds}`;
            startRound();
        }

        function startRound() {
            balls = [];
            particles = [];
            projectiles = [];
            hitEffects = [];
            lightningBolts = [];
            divineLightning = [];
            powerups = [];
            if (window.floorTraps) window.floorTraps = [];
            // Reset powerup cooldowns
            for (let type in powerupCooldowns) {
                powerupCooldowns[type] = 0;
            }

            settings.selectedBalls.forEach((configIndex, i) => {
                const angle = (i / settings.selectedBalls.length) * Math.PI * 2;
                const dist = 150;
                const x = centerX + Math.cos(angle) * dist;
                const y = centerY + Math.sin(angle) * dist;
                let weaponIdx = settings.weaponAssignments[configIndex];
                // Validate weapon index
                if (weaponIdx === undefined || isNaN(weaponIdx) || weaponIdx < 0 || weaponIdx >= weapons.length) {
                    weaponIdx = weapons.findIndex(w => w.id === 'sword');
                    if (weaponIdx < 0) weaponIdx = 0;
                }
                const weapon = weapons[weaponIdx];
                const team = settings.teamAssignments[configIndex];
                balls.push(new Ball(x, y, ballConfigs[configIndex], weapon, i, configIndex, team));
            });

            // SIMON VS ETERNAL - Apply buffs to both fighters
            if (window.simonEternalBuff) {
                balls.forEach(ball => {
                    if (ball.weapon.id === 'simon') {
                        // Simon buffs: +500 HP, +50% damage, +1000 shield
                        ball.maxHealth += 500;
                        ball.health += 500;
                        ball.damageMultiplier = 1.5;
                        ball.shield = 1000;
                        ball.spiralOverdrive = true;
                        // Visual indicator
                        for (let i = 0; i < 30; i++) {
                            const angle = (i / 30) * Math.PI * 2;
                            particles.push({
                                x: ball.x + Math.cos(angle) * 50,
                                y: ball.y + Math.sin(angle) * 50,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                life: 60, color: '#00ff00', size: 10
                            });
                        }
                    }
                    if (ball.weapon.id === 'eternal') {
                        // Eternal buffs: Start at Form 4, +500% damage, +1500 shield, 6x HP
                        ball.eternalForm = 4;
                        ball.damageMultiplier = 6.0;
                        ball.shield = 1500;
                        ball.maxHealth *= 6;
                        ball.health = ball.maxHealth;
                        // Visual indicator
                        for (let i = 0; i < 30; i++) {
                            const angle = (i / 30) * Math.PI * 2;
                            particles.push({
                                x: ball.x + Math.cos(angle) * 50,
                                y: ball.y + Math.sin(angle) * 50,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                life: 60, color: '#ffd700', size: 10
                            });
                        }
                    }
                });
                // Reset the flag after applying
                window.simonEternalBuff = false;
            }

            gameRunning = true;
            document.getElementById('startButton').disabled = true;
            requestAnimationFrame(gameLoop);
        }

        class Ball {
            constructor(x, y, config, weapon, index, configIndex, team) {
                this.x = x; this.y = y;
                this.config = config;
                this.weapon = weapon;
                this.configIndex = configIndex;
                this.team = team;
                this.baseSize = 25 * (weapon.size || 1);
                this.radius = this.baseSize;
                this.health = settings.health;
                this.maxHealth = settings.health;
                this.angle = Math.random() * Math.PI * 2;
                this.baseRotationSpeed = 0.02 * (weapon.speed || 1);
                this.rotationSpeed = this.baseRotationSpeed;
                this.alive = true;
                const baseSpeed = 1 + Math.random() * 1;
                const speed = baseSpeed * settings.speed;
                const moveAngle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(moveAngle) * speed;
                this.vy = Math.sin(moveAngle) * speed;
                this.index = index;
                this.hitCooldown = 0;

                // Ability system
                this.abilityCooldown = 0;
                this.abilityActive = false;
                this.abilityTimer = 0;

                // Legendary abilities
                this.archangelAbilityIndex = 0;
                this.currentAbility = null;
                this.isInvulnerable = false;

                // Stats tracking for currency rewards
                this.kills = 0;
                this.totalDamageDealt = 0;
                this.lowestHpPercent = 1;
                this.isSoulbound = false;

                // Unarmed
                this.unarmedSpeed = weapon.id === 'unarmed' ? 3 : 0;

                // Status effects
                this.burning = 0;
                this.frozen = 0;
                this.stunned = 0;
                this.damageMultiplier = 1;
            }

            useAbility() {
                // SEALED - Eternal Form 6 disables all enemy abilities
                if (this.abilitiesSealed) return;
                if (this.abilityCooldown > 0 || this.stunned > 0 || this.silenced > 0) return;

                this.abilityCooldown = this.weapon.abilityCooldown;
                this.abilityActive = true;
                this.abilityTimer = this.weapon.abilityDuration;

                switch(this.weapon.id) {
                    case 'firestaff': this.shootFireball(); break;
                    case 'lightning': this.chainLightning(); break;
                    case 'sunstaff': this.solarFlare(); break;
                    case 'dagger': this.shadowStep(); break;
                    case 'spear': this.charge(); break;
                    case 'hammer': this.groundSlam(); break;
                    case 'pickaxe': this.damageMultiplier = 3; break;
                    case 'axe': this.rotationSpeed = this.baseRotationSpeed * 5; break;
                    case 'icewand': this.freezeNearby(); break;
                    case 'archangel': this.useArchangelAbility(); break;
                    case 'solans': this.useSolansAbility(); break;
                    case 'superman': this.useSupermanAbility(); break;
                    case 'gojo': this.useGojoAbility(); break;
                    case 'sukuna': this.useSukunaAbility(); break;
                    case 'jobapp': this.useJobAppAbility(); break;
                    case 'dio': this.useDioAbility(); break;
                    case 'blackhole': this.useBlackholeAbility(); break;
                    case 'ninja': this.useNinjaAbility(); break;
                    case 'money': this.useMoneyAbility(); break;
                    case 'kirk': this.useKirkAbility(); break;
                    case 'simon': this.useSimonAbility(); break;
                    case 'casino': this.useCasinoAbility(); break;
                    case 'american': this.useAmericanAbility(); break;
                    case 'divinity': this.useDivinityAbility(); break;
                    case 'archmage': this.useArchmageAbility(); break;
                    case 'paradoxical': this.useParadoxicalAbility(); break;
                    case 'lightyagami': this.useLightYagamiAbility(); break;
                    case 'looksmaxxing': this.useLooksmaxxingAbility(); break;
                    case 'gabe': this.useGabeAbility(); break;
                    case 'lamp': this.useLampAbility(); break;
                    case 'wacky': this.useWackyAbility(); break;
                    case 'shadowmana': this.useShadowmanaAbility(); break;
                    case 'sebastian': this.useSebastianAbility(); break;
                    case 'oofer': this.useOoferAbility(); break;
                    case 'leonitas': this.useLeonitasAbility(); break;
                    case 'killswitch': this.useKillswitchAbility(); break;
                    case 'britishdemon': this.useBritishDemonAbility(); break;
                    case 'abachan': this.useAbaChanAbility(); break;
                    case 'bow': this.useBowAbility(); break;
                    case 'longsword': this.useLongswordAbility(); break;
                    case 'chainsaw': this.useChainsawAbility(); break;
                    case 'crossbow': this.useCrossbowAbility(); break;
                    case 'flail': this.useFlailAbility(); break;
                    case 'pickaxe': this.usePickaxeAbility(); break;
                    case 'whip': this.useWhipAbility(); break;
                    case 'slingshot': this.useSlingshotAbility(); break;
                    case 'boomerang': this.useBoomerangAbility(); break;
                    case 'torch': this.useTorchAbility(); break;
                    case 'eternal': this.useEternalAbility(); break;
                }
            }

            useArchangelAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'smite': this.divineSmite(); break;
                    case 'holyshield': this.holyShield(); break;
                    case 'divinedash': this.divineDash(); break;
                    case 'resurrection': this.resurrection(); break;
                }
            }

            useSolansAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'whiteflamecharge': this.whiteFlameCharge(); break;
                    case 'chargedblow': this.chargedBlow(); break;
                    case 'soulbound': this.soulBound(); break;
                }
            }

            divineSmite() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const startX = b.x + (Math.random() - 0.5) * 50;
                        const startY = centerY - arenaRadius;
                        createDivineLightning(startX, startY, b.x, b.y);
                        b.takeDamage(35, this);
                        b.stunned = 40;
                    }
                });
                hitEffects.push({ x: centerX, y: centerY, radius: 10, maxRadius: 350, color: '#ffd700' });
            }

            holyShield() {
                this.isInvulnerable = true;
                this.abilityTimer = 90;
            }

            divineDash() {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;
                let nearest = targets[0], nearestDist = Infinity;
                targets.forEach(t => {
                    const dist = Math.sqrt((t.x - this.x) ** 2 + (t.y - this.y) ** 2);
                    if (dist < nearestDist) { nearestDist = dist; nearest = t; }
                });
                const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                this.vx = Math.cos(angle) * 15;
                this.vy = Math.sin(angle) * 15;
                this.damageMultiplier = 3;
                this.isInvulnerable = true;
                for (let i = 0; i < 10; i++) {
                    particles.push({ x: this.x - Math.cos(angle) * i * 5, y: this.y - Math.sin(angle) * i * 5,
                        vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, life: 30, color: '#00ffff', size: 8 });
                }
            }

            resurrection() {
                this.health = this.maxHealth;
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 180) {
                            b.takeDamage(20, this);
                            const angle = Math.atan2(b.y - this.y, b.x - this.x);
                            b.vx += Math.cos(angle) * 4;
                            b.vy += Math.sin(angle) * 4;
                        }
                    }
                });
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y, vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8,
                        life: 40, color: i % 2 === 0 ? '#ffd700' : '#ffffff', size: 8 });
                }
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#ffd700' });
            }

            whiteFlameCharge() {
                this.damageMultiplier = 2;
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,
                        life: 30, color: i % 2 === 0 ? '#ffffff' : '#e0ffff', size: 6 });
                }
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 120) { b.burning = 120; b.takeDamage(10, this); }
                    }
                });
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 120, color: '#e0ffff' });
            }

            chargedBlow() {
                const tip = this.getWeaponTip();
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    particles.push({ x: tip.x, y: tip.y, vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
                        life: 25, color: '#00ffff', size: 5 });
                }
                for (let i = -2; i <= 2; i++) {
                    const spreadAngle = this.angle + (i * 0.2);
                    projectiles.push({ x: tip.x, y: tip.y, vx: Math.cos(spreadAngle) * 7, vy: Math.sin(spreadAngle) * 7,
                        radius: 10, damage: 18, owner: this, type: 'whiteflame', life: 100 });
                }
            }

            soulBound() {
                this.stunned = 0;
                this.frozen = 0;
                this.isSoulbound = true;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    particles.push({ x: this.x + Math.cos(angle) * 30, y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2, life: 60, color: '#c8ffff', size: 4 });
                }
                hitEffects.push({ x: this.x, y: this.y, radius: 20, maxRadius: 80, color: '#88ffff' });
            }

            // === SUPERMAN ABILITIES ===
            useSupermanAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'flight': this.supermanFlight(); break;
                    case 'heatvision': this.heatVision(); break;
                    case 'superstrength': this.superStrength(); break;
                    case 'freezebreath': this.freezeBreath(); break;
                }
            }

            supermanFlight() {
                const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                if (speed > 0) { this.vx = (this.vx / speed) * 8; this.vy = (this.vy / speed) * 8; }
                for (let i = 0; i < 15; i++) {
                    particles.push({ x: this.x, y: this.y, vx: -this.vx * 0.3 + (Math.random() - 0.5) * 2,
                        vy: -this.vy * 0.3 + (Math.random() - 0.5) * 2, life: 25, color: '#ff0000', size: 5 });
                }
            }

            heatVision() {
                const tip = this.getWeaponTip();
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dx = b.x - this.x, dy = b.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const angleDiff = Math.abs(Math.atan2(dy, dx) - this.angle);
                        if (dist < 200 && angleDiff < 0.5) { b.takeDamage(30, this); b.burning = 60; createLightningBolt(tip.x, tip.y, b.x, b.y); }
                    }
                });
            }

            superStrength() { this.damageMultiplier = 3; hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 60, color: '#ffe100' }); }

            freezeBreath() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dx = b.x - this.x, dy = b.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 150 && Math.abs(Math.atan2(dy, dx) - this.angle) < 0.7) { b.frozen = 80; b.takeDamage(10, this); }
                    }
                });
            }

            // === GOJO ABILITIES ===
            useGojoAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'infinity': this.infinityBarrier(); break;
                    case 'domain': this.unlimitedVoid(); break;
                    case 'hollowpurple': this.hollowPurple(); break;
                    case 'reversal': this.reversalRed(); break;
                }
            }

            infinityBarrier() {
                this.isInvulnerable = true;
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({ x: this.x + Math.cos(angle) * 40, y: this.y + Math.sin(angle) * 40,
                        vx: Math.cos(angle) * 0.5, vy: Math.sin(angle) * 0.5, life: 60, color: '#00bfff', size: 3 });
                }
            }

            unlimitedVoid() {
                balls.forEach(b => { if (b !== this && b.alive && !this.isTeammate(b)) { b.stunned = 100; b.takeDamage(15, this); } });
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#4444ff' });
            }

            hollowPurple() {
                const tip = this.getWeaponTip();
                projectiles.push({ x: tip.x, y: tip.y, vx: Math.cos(this.angle) * 5, vy: Math.sin(this.angle) * 5,
                    radius: 20, damage: 50, owner: this, type: 'hollowpurple', life: 150 });
                for (let i = 0; i < 20; i++) { particles.push({ x: tip.x, y: tip.y, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, life: 30, color: '#9932cc', size: 6 }); }
            }

            reversalRed() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 120) { const angle = Math.atan2(b.y - this.y, b.x - this.x); b.vx += Math.cos(angle) * 6; b.vy += Math.sin(angle) * 6; b.takeDamage(20, this); }
                    }
                });
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 120, color: '#ff3333' });
            }

            // === SUKUNA ABILITIES ===
            useSukunaAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'cleave': this.cleave(); break;
                    case 'dismantle': this.dismantle(); break;
                    case 'shrine': this.malevolentShrine(); break;
                    case 'openflame': this.openFlame(); break;
                }
            }

            cleave() {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length > 0) {
                    let nearest = targets.reduce((a, b) => Math.sqrt((a.x-this.x)**2+(a.y-this.y)**2) < Math.sqrt((b.x-this.x)**2+(b.y-this.y)**2) ? a : b);
                    const dist = Math.sqrt((nearest.x - this.x) ** 2 + (nearest.y - this.y) ** 2);
                    if (dist < 150) {
                        nearest.takeDamage(40, this);
                        for (let i = 0; i < 10; i++) { particles.push({ x: nearest.x, y: nearest.y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 20, color: '#ff0000', size: 5 }); }
                    }
                }
            }

            dismantle() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 130) { for (let i = 0; i < 5; i++) { setTimeout(() => { if (b.alive) b.takeDamage(8, this); }, i * 100); } }
                    }
                });
            }

            malevolentShrine() {
                this.damageMultiplier = 2;
                balls.forEach(b => { if (b !== this && b.alive && !this.isTeammate(b)) { b.takeDamage(25, this); b.stunned = 40; } });
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#8b0000' });
            }

            openFlame() {
                const tip = this.getWeaponTip();
                for (let i = -1; i <= 1; i++) {
                    const spreadAngle = this.angle + (i * 0.3);
                    projectiles.push({ x: tip.x, y: tip.y, vx: Math.cos(spreadAngle) * 6, vy: Math.sin(spreadAngle) * 6, radius: 10, damage: 20, owner: this, type: 'fireball', life: 80 });
                }
            }

            // === JOB APPLICATION ABILITIES ===
            useJobAppAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'reject': this.rejected(); break;
                    case 'ghost': this.ghosted(); break;
                    case 'overqualified': this.overqualified(); break;
                    case 'experience': this.needExperience(); break;
                }
            }

            // === DIO ABILITIES ===
            useDioAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'timestop': this.timeStop(); break;
                    case 'knives': this.throwKnives(); break;
                    case 'roadroller': this.roadRoller(); break;
                    case 'mudamuda': this.mudaMuda(); break;
                }
            }

            // === BLACKHOLE ABILITIES ===
            useBlackholeAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'singularity': this.singularity(); break;
                    case 'eventhorizon': this.eventHorizon(); break;
                    case 'hawking': this.hawkingRadiation(); break;
                    case 'collapse': this.collapse(); break;
                }
            }

            // === NINJA ABILITIES ===
            useNinjaAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'shadowclone': this.shadowCloneJutsu(); break;
                    case 'rasengan': this.rasengan(); break;
                    case 'chakram': this.chakramTrap(); break;
                    case 'fireballjutsu': this.fireballJutsu(); break;
                }
            }

            shadowCloneJutsu() {
                // Create shadow clones that confuse enemies and deal damage
                const cloneCount = 3;
                for (let i = 0; i < cloneCount; i++) {
                    const angle = (i / cloneCount) * Math.PI * 2;
                    const dist = 60;
                    const cloneX = this.x + Math.cos(angle) * dist;
                    const cloneY = this.y + Math.sin(angle) * dist;

                    // Clone explosion after delay
                    setTimeout(() => {
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dx = b.x - cloneX;
                                const dy = b.y - cloneY;
                                const d = Math.sqrt(dx * dx + dy * dy);
                                if (d < 50) {
                                    b.takeDamage(12, this);
                                    b.stunned = 20;
                                }
                            }
                        });
                        // Poof particles
                        for (let j = 0; j < 15; j++) {
                            particles.push({ x: cloneX, y: cloneY,
                                vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                                life: 25, color: '#ffffff', size: 8 });
                        }
                        hitEffects.push({ x: cloneX, y: cloneY, radius: 5, maxRadius: 50, color: '#cccccc' });
                    }, 500 + i * 200);

                    // Initial poof
                    for (let j = 0; j < 10; j++) {
                        particles.push({ x: cloneX, y: cloneY,
                            vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                            life: 30, color: '#ffffff', size: 10 });
                    }
                }
            }

            rasengan() {
                // Powerful close-range burst attack
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length > 0) {
                    let nearest = targets.reduce((a, b) =>
                        Math.sqrt((a.x-this.x)**2+(a.y-this.y)**2) < Math.sqrt((b.x-this.x)**2+(b.y-this.y)**2) ? a : b);
                    const dist = Math.sqrt((nearest.x - this.x) ** 2 + (nearest.y - this.y) ** 2);

                    if (dist < 120) {
                        // Dash to target
                        const dx = nearest.x - this.x;
                        const dy = nearest.y - this.y;
                        this.x = nearest.x - (dx / dist) * 30;
                        this.y = nearest.y - (dy / dist) * 30;

                        // Big damage
                        nearest.takeDamage(45, this);
                        nearest.stunned = 40;

                        // Knockback
                        nearest.vx += (dx / dist) * 10;
                        nearest.vy += (dy / dist) * 10;

                        // Spiral particles
                        for (let i = 0; i < 30; i++) {
                            const angle = (i / 30) * Math.PI * 6;
                            const r = i * 1.5;
                            particles.push({ x: nearest.x + Math.cos(angle) * r, y: nearest.y + Math.sin(angle) * r,
                                vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
                                life: 30, color: i % 2 === 0 ? '#00bfff' : '#ffffff', size: 5 });
                        }
                        hitEffects.push({ x: nearest.x, y: nearest.y, radius: 10, maxRadius: 80, color: '#00bfff' });
                    }
                }
            }

            chakramTrap() {
                // Place chakrams on the floor that damage enemies who walk over them
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const dist = 40 + Math.random() * 60;
                    const trapX = this.x + Math.cos(angle) * dist;
                    const trapY = this.y + Math.sin(angle) * dist;

                    // Add to floor traps array
                    if (!window.floorTraps) window.floorTraps = [];
                    window.floorTraps.push({
                        x: trapX, y: trapY, radius: 25, damage: 18, owner: this,
                        life: 300, type: 'chakram', rotation: Math.random() * Math.PI * 2
                    });

                    // Placement particles
                    for (let j = 0; j < 8; j++) {
                        particles.push({ x: trapX, y: trapY,
                            vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                            life: 20, color: '#ff6600', size: 4 });
                    }
                }
            }

            fireballJutsu() {
                // Large fireball AoE attack
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 150) {
                            b.takeDamage(30, this);
                            b.burning = 90;
                            // Push away
                            const dx = b.x - this.x;
                            const dy = b.y - this.y;
                            b.vx += (dx / dist) * 5;
                            b.vy += (dy / dist) * 5;
                        }
                    }
                });

                // Fire explosion
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    const dist = Math.random() * 100;
                    particles.push({ x: this.x + Math.cos(angle) * dist, y: this.y + Math.sin(angle) * dist,
                        vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,
                        life: 40, color: i % 3 === 0 ? '#ff4400' : (i % 3 === 1 ? '#ff8800' : '#ffcc00'), size: 8 });
                }
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#ff4400' });
            }

            // === MONEY BALL ABILITIES ===
            useMoneyAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'factory': this.buildFactory(); break;
                    case 'moneythrow': this.throwMoney(); break;
                    case 'bodyguard': this.hireBodyguards(); break;
                    case 'bailout': this.bailout(); break;
                }
            }

            buildFactory() {
                // Place polluting factories on the map
                for (let i = 0; i < 3; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 80 + Math.random() * 100;
                    const fx = this.x + Math.cos(angle) * dist;
                    const fy = this.y + Math.sin(angle) * dist;

                    // Add factory as floor trap (pollution zone)
                    if (!window.floorTraps) window.floorTraps = [];
                    window.floorTraps.push({
                        x: fx, y: fy, radius: 70, damage: 8, owner: this,
                        life: 999999, type: 'factory', rotation: 0, shootTimer: 0
                    });

                    // Smoke particles
                    for (let j = 0; j < 10; j++) {
                        particles.push({ x: fx, y: fy - 20,
                            vx: (Math.random() - 0.5) * 2, vy: -Math.random() * 3,
                            life: 50, color: '#555555', size: 10 });
                    }
                }
            }

            throwMoney() {
                // Throw money projectiles in all directions
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    projectiles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 6, vy: Math.sin(angle) * 6,
                        radius: 8, damage: 12, owner: this, type: 'money', life: 80
                    });
                }
                // Money particles
                for (let i = 0; i < 30; i++) {
                    particles.push({ x: this.x, y: this.y,
                        vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                        life: 30, color: '#00aa00', size: 6 });
                }
            }

            hireBodyguards() {
                // Summon bodyguards that orbit and damage enemies
                this.bodyguards = [];
                for (let i = 0; i < 3; i++) {
                    this.bodyguards.push({
                        angle: (i / 3) * Math.PI * 2,
                        dist: 50
                    });
                }
                this.bodyguardTimer = 180;
            }

            bailout() {
                // Heal self and gain shield
                this.health = Math.min(this.maxHealth, this.health + 50);
                this.isInvulnerable = true;
                this.powerupShield = 120;

                // Golden particles
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y,
                        vx: Math.cos(angle) * 5, vy: Math.sin(angle) * 5,
                        life: 40, color: '#ffd700', size: 8 });
                }
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#ffd700' });
            }

            // === KIRK BALL ABILITIES ===
            useKirkAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'wingflap': this.wingFlap(); break;
                    case 'shrinkface': this.shrinkFace(); break;
                    case 'tpusa': this.tpusa(); break;
                    case 'debate': this.debate(); break;
                    case 'sing': this.kirkSing(); break;
                    case 'mog': this.kirkMog(); break;
                }
            }

            wingFlap() {
                // Speed boost and knockback all nearby enemies
                const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                if (speed > 0) {
                    this.vx = (this.vx / speed) * 12;
                    this.vy = (this.vy / speed) * 12;
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    this.vx = Math.cos(angle) * 12;
                    this.vy = Math.sin(angle) * 12;
                }

                // Knockback nearby enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dx = b.x - this.x;
                        const dy = b.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 120) {
                            b.vx += (dx / dist) * 8;
                            b.vy += (dy / dist) * 8;
                            b.takeDamage(10, this);
                        }
                    }
                });

                // Wind particles
                for (let i = 0; i < 20; i++) {
                    particles.push({ x: this.x + (Math.random() - 0.5) * 60, y: this.y + (Math.random() - 0.5) * 60,
                        vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                        life: 25, color: '#cccccc', size: 5 });
                }
            }

            shrinkFace() {
                // Become hard to hit (smaller hitbox effect via invulnerability frames)
                this.isInvulnerable = true;
                this.shrinkTimer = 60;

                // Shrink particles
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    particles.push({ x: this.x + Math.cos(angle) * 30, y: this.y + Math.sin(angle) * 30,
                        vx: -Math.cos(angle) * 2, vy: -Math.sin(angle) * 2,
                        life: 30, color: '#ffdbac', size: 4 });
                }
            }

            tpusa() {
                // Buff self - damage and speed boost
                this.damageMultiplier = 2.5;
                this.powerupDamageBuff = 150;

                const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                if (speed > 0 && speed < 8) {
                    this.vx *= 1.5;
                    this.vy *= 1.5;
                }

                // USA colored particles
                for (let i = 0; i < 20; i++) {
                    const colors = ['#ff0000', '#ffffff', '#0000ff'];
                    particles.push({ x: this.x, y: this.y,
                        vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                        life: 35, color: colors[i % 3], size: 6 });
                }
            }

            debate() {
                // MYTHICAL DEBATE - Freeze enemies and coin flip for instakill!
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 200) {
                            // FREEZE in place
                            b.stunned = 180; // 3 seconds frozen
                            b.vx = 0;
                            b.vy = 0;

                            // COIN FLIP - 50% chance of instakill!
                            const coinFlip = Math.random() < 0.5;
                            if (coinFlip) {
                                // DESTROYED BY FACTS AND LOGIC
                                b.takeDamage(9999, this);

                                // Destruction effect
                                for (let j = 0; j < 30; j++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    particles.push({
                                        x: b.x, y: b.y,
                                        vx: Math.cos(angle) * 8,
                                        vy: Math.sin(angle) * 8,
                                        life: 50, color: '#ff0000', size: 10
                                    });
                                }

                                // Victory text effect
                                for (let j = 0; j < 8; j++) {
                                    particles.push({
                                        x: b.x, y: b.y - 30 - j * 10,
                                        vx: (Math.random() - 0.5) * 2, vy: -3,
                                        life: 60, color: '#ffff00', size: 12
                                    });
                                }
                            } else {
                                // Survived but damaged
                                b.takeDamage(40, this);

                                // Freeze particles
                                for (let j = 0; j < 15; j++) {
                                    particles.push({
                                        x: b.x + (Math.random() - 0.5) * 40,
                                        y: b.y + (Math.random() - 0.5) * 40,
                                        vx: 0, vy: -1,
                                        life: 40, color: '#88ccff', size: 6
                                    });
                                }
                            }
                        }
                    }
                });

                // Debate shockwave
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ff4444' });

                // "FACTS" particles
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 50,
                        y: this.y + Math.sin(angle) * 50,
                        vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,
                        life: 40, color: '#ff0000', size: 8
                    });
                }
            }

            kirkSing() {
                // HEAL BY SINGING - heals self and nearby allies
                const healAmount = 40;

                // Heal self
                this.health = Math.min(this.maxHealth, this.health + healAmount);

                // Heal nearby allies
                balls.forEach(b => {
                    if (b !== this && b.alive && this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 180) {
                            b.health = Math.min(b.maxHealth, b.health + healAmount * 0.5);

                            // Healing particles to ally
                            for (let j = 0; j < 5; j++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: 0, vy: -2,
                                    life: 30, color: '#00ff00', size: 6
                                });
                            }
                        }
                    }
                });

                // Musical note particles around Kirk
                const noteColors = ['#ff69b4', '#ffd700', '#00ffff', '#ff6600'];
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const dist = 40 + Math.random() * 30;
                    particles.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        vx: Math.cos(angle) * 2,
                        vy: -3 - Math.random() * 2,
                        life: 50,
                        color: noteColors[i % noteColors.length],
                        size: 8
                    });
                }

                // Green healing aura
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#00ff00' });
            }

            kirkMog() {
                // MOG - Ultimate flex ability (10 second cooldown)
                if (this.mogCooldown && this.mogCooldown > 0) {
                    // On cooldown, do a different ability instead
                    this.wingFlap();
                    return;
                }

                // Set 10 second cooldown (600 frames)
                this.mogCooldown = 600;

                // FULL HEAL
                this.health = this.maxHealth;

                // 1000 SHIELD
                if (!this.shield) this.shield = 0;
                this.shield += 1000;

                // 50 DEFLECTS
                if (!this.deflects) this.deflects = 0;
                this.deflects += 50;

                // EMOTE - Kirk does a flex pose (stop moving briefly and show effect)
                this.stunned = 45; // Brief pause for emote
                this.isInvulnerable = true;
                this.emoteTimer = 45;

                // Massive MOG effect - golden aura explosion
                for (let ring = 0; ring < 3; ring++) {
                    setTimeout(() => {
                        for (let i = 0; i < 24; i++) {
                            const angle = (i / 24) * Math.PI * 2;
                            const dist = 30 + ring * 40;
                            particles.push({
                                x: this.x + Math.cos(angle) * dist,
                                y: this.y + Math.sin(angle) * dist,
                                vx: Math.cos(angle) * 6,
                                vy: Math.sin(angle) * 6,
                                life: 50,
                                color: ring === 0 ? '#ffd700' : ring === 1 ? '#ff8c00' : '#ff4500',
                                size: 12
                            });
                        }
                    }, ring * 100);
                }

                // Crown/flex particles above head
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: this.x + (Math.random() - 0.5) * 30,
                        y: this.y - 40 - Math.random() * 30,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -2 - Math.random() * 2,
                        life: 60,
                        color: '#ffd700',
                        size: 10
                    });
                }

                // "MOG" text effect - sparkles
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    particles.push({
                        x: this.x,
                        y: this.y - 50,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4 - 2,
                        life: 45,
                        color: i % 2 === 0 ? '#ffffff' : '#ffd700',
                        size: 8
                    });
                }

                // Shield visual
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#ffd700' });
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#ff8c00' });
            }

            // === SIMON THE DIGGER (GODLY) ABILITIES ===
            useSimonAbility() {
                // GODLY SIMON - Uses 2 abilities simultaneously!
                const abilities = this.weapon.abilities;
                if (!this.simonIndex) this.simonIndex = 0;

                // Brief iframes when using abilities
                this.isInvulnerable = true;
                this.simonIframeTimer = 45; // 0.75 sec iframes per ability use

                // Use 2 abilities at once!
                for (let a = 0; a < 2; a++) {
                    const ability = abilities[(this.simonIndex + a) % abilities.length];
                    this.executeSimonAbility(ability);
                }
                this.simonIndex = (this.simonIndex + 2) % abilities.length;

                // Small bonus shield
                if (!this.shield) this.shield = 0;
                this.shield += 75;
            }

            executeSimonAbility(ability) {
                switch(ability) {
                    case 'gigadrill': this.gigaDrillBreak(); break;
                    case 'spiralpower': this.spiralPower(); break;
                    case 'whothehell': this.whoTheHell(); break;
                    case 'piercetheheavens': this.pierceTheHeavens(); break;
                    case 'combine': this.combine(); break;
                    case 'lagannimpact': this.lagannImpact(); break;
                    case 'tengentoppa': this.tengenToppa(); break;
                    case 'infinitybigbang': this.infinityBigBang(); break;
                }
            }

            gigaDrillBreak() {
                // GIGA DRILL BREAK - Launch MULTIPLE massive spinning drill projectiles
                for (let d = 0; d < 3; d++) {
                    const baseAngle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                    const angle = baseAngle + (d - 1) * 0.4;

                    projectiles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 22,
                        vy: Math.sin(angle) * 22,
                        damage: 200,
                        owner: this,
                        radius: 45,
                        type: 'drill',
                        life: 150,
                        pierce: true,
                        spin: 0
                    });
                }

                // Spiral energy burst
                for (let i = 0; i < 40; i++) {
                    const a = (i / 40) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(a) * 25,
                        y: this.y + Math.sin(a) * 25,
                        vx: Math.cos(a) * 10,
                        vy: Math.sin(a) * 10,
                        life: 50, color: i % 2 === 0 ? '#00ff00' : '#ff6600', size: 10
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 250, color: '#00ff00' });
            }

            spiralPower() {
                // SPIRAL POWER - Massive power up
                if (!this.shield) this.shield = 0;
                this.shield += 600;
                this.spiralPowerTimer = 400; // Extended duration
                this.spiralSpeedBoost = true;
                this.damageMultiplier = 2.0;

                // Heal from spiral energy
                this.health = Math.min(this.maxHealth, this.health + 150);

                // Epic spiral aura effect
                for (let ring = 0; ring < 8; ring++) {
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2 + ring * 0.4;
                        const dist = 25 + ring * 20;
                        particles.push({
                            x: this.x + Math.cos(angle) * dist,
                            y: this.y + Math.sin(angle) * dist,
                            vx: Math.cos(angle + Math.PI/2) * 5,
                            vy: Math.sin(angle + Math.PI/2) * 5,
                            life: 60 + ring * 10,
                            color: ring % 3 === 0 ? '#00ff00' : ring % 3 === 1 ? '#ffff00' : '#00ffff',
                            size: 12 - ring
                        });
                    }
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#00ff00' });
            }

            whoTheHell() {
                // WHO THE HELL DO YOU THINK I AM?! - Massive AOE stun + damage
                if (!this.deflects) this.deflects = 0;
                this.deflects += 25;
                this.isInvulnerable = true;
                this.simonIframeTimer = Math.max(this.simonIframeTimer || 0, 120);

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 350) { // Huge range
                            b.stunned = 150; // Long stun
                            b.takeDamage(120, this);
                            const angle = Math.atan2(b.y - this.y, b.x - this.x);
                            b.vx = Math.cos(angle) * 25;
                            b.vy = Math.sin(angle) * 25;
                        }
                    }
                });

                // Multiple shockwave rings
                for (let ring = 0; ring < 6; ring++) {
                    hitEffects.push({ x: this.x, y: this.y, radius: 10 + ring * 30, maxRadius: 350,
                        color: ring % 3 === 0 ? '#ff0000' : ring % 3 === 1 ? '#ff6600' : '#ffff00' });
                }

                // Tons of epic particles
                for (let i = 0; i < 80; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * (8 + Math.random() * 15),
                        vy: Math.sin(angle) * (8 + Math.random() * 15),
                        life: 60, color: i % 3 === 0 ? '#ff0000' : i % 3 === 1 ? '#ff6600' : '#ffff00', size: 14
                    });
                }
            }

            pierceTheHeavens() {
                // PIERCE THE HEAVENS - Fire TONS of drills in all directions
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 16; i++) {
                            const angle = (i / 16) * Math.PI * 2 + wave * 0.2;
                            projectiles.push({
                                x: this.x + Math.cos(angle) * 30,
                                y: this.y + Math.sin(angle) * 30,
                                vx: Math.cos(angle) * (16 + wave * 3),
                                vy: Math.sin(angle) * (16 + wave * 3),
                                damage: 100 + wave * 30,
                                owner: this,
                                radius: 22 + wave * 4,
                                type: 'drill',
                                life: 100,
                                pierce: wave === 2,
                                spin: i * 30
                            });
                        }
                    }, wave * 150);
                }

                // Massive spiral burst
                for (let i = 0; i < 80; i++) {
                    const angle = (i / 80) * Math.PI * 6;
                    const dist = 10 + (i / 80) * 100;
                    particles.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        life: 50, color: i % 3 === 0 ? '#00ff00' : i % 3 === 1 ? '#00ffff' : '#ffffff', size: 9
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 350, color: '#00ffff' });
            }

            combine() {
                // COMBINE - Heal, shield, and invulnerability
                this.health = Math.min(this.maxHealth, this.health + 200);
                if (!this.shield) this.shield = 0;
                this.shield += 300;
                this.isInvulnerable = true;
                this.combineTimer = 90; // 1.5 second invuln
                if (!this.deflects) this.deflects = 0;
                this.deflects += 10;

                // Mecha combination effect - concentric rings
                for (let ring = 0; ring < 6; ring++) {
                    setTimeout(() => {
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2;
                            const dist = 150 - ring * 25;
                            particles.push({
                                x: this.x + Math.cos(angle) * dist,
                                y: this.y + Math.sin(angle) * dist,
                                vx: -Math.cos(angle) * 6,
                                vy: -Math.sin(angle) * 6,
                                life: 45,
                                color: ring % 3 === 0 ? '#ff0000' : ring % 3 === 1 ? '#ffff00' : '#00ff00',
                                size: 15
                            });
                        }
                        hitEffects.push({ x: this.x, y: this.y, radius: dist, maxRadius: dist + 20, color: '#ff6600' });
                    }, ring * 60);
                }
            }

            lagannImpact() {
                // LAGANN IMPACT - Charge forward dealing massive damage
                const angle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * 30;
                this.vy = Math.sin(angle) * 30;
                this.isInvulnerable = true;
                this.lagannChargeTimer = 60;

                // Damage everything in path
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 200) {
                            b.takeDamage(180, this);
                            b.stunned = 60;
                            // Vampirism - heal on hit
                            this.health = Math.min(this.maxHealth, this.health + 50);
                        }
                    }
                });

                // Trail of spiral energy
                for (let i = 0; i < 30; i++) {
                    const trailAngle = angle + Math.PI + (Math.random() - 0.5) * 0.8;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(trailAngle) * (10 + Math.random() * 10),
                        vy: Math.sin(trailAngle) * (10 + Math.random() * 10),
                        life: 40, color: i % 2 === 0 ? '#00ff00' : '#ff6600', size: 12
                    });
                }

                // Launch drill ahead
                projectiles.push({
                    x: this.x + Math.cos(angle) * 50,
                    y: this.y + Math.sin(angle) * 50,
                    vx: Math.cos(angle) * 25,
                    vy: Math.sin(angle) * 25,
                    damage: 250,
                    owner: this,
                    radius: 50,
                    type: 'drill',
                    life: 120,
                    pierce: true
                });

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#00ff00' });
            }

            tengenToppa() {
                // TENGEN TOPPA GURREN LAGANN - Become powerful temporarily
                this.tengenToppaTimer = 180; // 3 seconds of power
                this.isInvulnerable = true;
                this.simonIframeTimer = 180;
                this.damageMultiplier = 2.0;

                // Grow larger temporarily
                this.tengenSizeBoost = true;

                // Heal 50%
                this.health = Math.min(this.maxHealth, this.health + this.maxHealth * 0.5);
                if (!this.shield) this.shield = 0;
                this.shield += 500;
                if (!this.deflects) this.deflects = 0;
                this.deflects += 15;

                // Massive galaxy-spiral effect
                for (let ring = 0; ring < 10; ring++) {
                    setTimeout(() => {
                        for (let i = 0; i < 24; i++) {
                            const angle = (i / 24) * Math.PI * 2 + ring * 0.3;
                            const dist = 30 + ring * 30;
                            particles.push({
                                x: this.x + Math.cos(angle) * dist,
                                y: this.y + Math.sin(angle) * dist,
                                vx: Math.cos(angle + Math.PI/2) * 4,
                                vy: Math.sin(angle + Math.PI/2) * 4,
                                life: 80,
                                color: ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#00ffff', '#ff00ff'][ring % 6],
                                size: 18 - ring
                            });
                        }
                        hitEffects.push({ x: this.x, y: this.y, radius: dist - 20, maxRadius: dist + 50,
                            color: ['#ff0000', '#00ff00', '#00ffff'][ring % 3] });
                    }, ring * 50);
                }

                // Damage nearby enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 400) {
                            b.takeDamage(200, this);
                            b.stunned = 120;
                        }
                    }
                });
            }

            infinityBigBang() {
                // INFINITY BIG BANG STORM - Ultimate attack
                this.isInvulnerable = true;
                this.simonIframeTimer = 60;

                // Fire drills in multiple waves
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2 + wave * 0.2;
                            projectiles.push({
                                x: this.x,
                                y: this.y,
                                vx: Math.cos(angle) * (10 + wave * 3),
                                vy: Math.sin(angle) * (10 + wave * 3),
                                damage: 80,
                                owner: this,
                                radius: 22,
                                type: 'drill',
                                life: 100,
                                pierce: wave === 2
                            });
                        }

                        // Explosion effect each wave
                        hitEffects.push({ x: this.x, y: this.y, radius: wave * 50, maxRadius: 400 + wave * 50,
                            color: ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#00ffff'][wave] });

                        // Massive particle burst
                        for (let j = 0; j < 50; j++) {
                            const a = Math.random() * Math.PI * 2;
                            particles.push({
                                x: this.x, y: this.y,
                                vx: Math.cos(a) * (15 + Math.random() * 20),
                                vy: Math.sin(a) * (15 + Math.random() * 20),
                                life: 60,
                                color: ['#ff0000', '#ff6600', '#ffff00', '#00ff00', '#00ffff', '#ff00ff'][Math.floor(Math.random() * 6)],
                                size: 15
                            });
                        }
                    }, wave * 200);
                }

                // Heal from the cosmic energy
                this.health = Math.min(this.maxHealth, this.health + 100);
                if (!this.shield) this.shield = 0;
                this.shield += 200;
            }

            // === LOOKSMAXXING BALL ABILITIES ===
            useLooksmaxxingAbility() {
                const abilities = this.weapon.abilities;
                if (!this.looksmaxxIndex) this.looksmaxxIndex = 0;
                const ability = abilities[this.looksmaxxIndex];
                this.looksmaxxIndex = (this.looksmaxxIndex + 1) % abilities.length;

                switch(ability) {
                    case 'bonesmash': this.bonesmash(); break;
                    case 'mewing': this.mewing(); break;
                    case 'carrotmaxx': this.carrotmaxx(); break;
                    case 'mogging': this.mogging(); break;
                    case 'dogpill': this.dogpill(); break;
                }
            }

            bonesmash() {
                // BONESMASHING - Smash into enemies for massive damage and stun
                const angle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * 18;
                this.vy = Math.sin(angle) * 18;
                this.bonesmashActive = true;
                this.bonesmashTimer = 40;

                // Damage and stun all enemies hit
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 100) {
                            b.takeDamage(45, this);
                            b.stunned = 60;
                            b.vx += (b.x - this.x) / dist * 15;
                            b.vy += (b.y - this.y) / dist * 15;

                            // Bone crack particles
                            for (let i = 0; i < 15; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 10,
                                    vy: (Math.random() - 0.5) * 10,
                                    life: 30, color: '#ffffff', size: 6
                                });
                            }
                        }
                    }
                });

                // Impact particles
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 5 + (Math.random() - 0.5) * 5,
                        vy: Math.sin(angle) * 5 + (Math.random() - 0.5) * 5,
                        life: 25, color: '#ffaa00', size: 8
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#ffaa00' });
            }

            mewing() {
                // MEWING - Defensive stance, reduces damage taken, heals over time
                this.mewingActive = true;
                this.mewingTimer = 180; // 3 seconds
                this.isInvulnerable = true;

                // Heal 30% HP
                this.health = Math.min(this.maxHealth, this.health + this.maxHealth * 0.3);

                // Jaw enhancement particles
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI + Math.PI / 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 20,
                        y: this.y + 10 + Math.sin(angle) * 15,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2,
                        life: 40, color: '#00ffff', size: 5
                    });
                }
            }

            carrotmaxx() {
                // CARROTMAXXING - Enhanced vision, reveals and damages all enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        // Mark enemy (they glow orange)
                        b.carrotMarked = 120;

                        // Vision beam to each enemy
                        const dx = b.x - this.x;
                        const dy = b.y - this.y;
                        const dist = Math.hypot(dx, dy);

                        for (let i = 0; i < dist; i += 20) {
                            particles.push({
                                x: this.x + (dx / dist) * i,
                                y: this.y + (dy / dist) * i,
                                vx: 0, vy: 0,
                                life: 20, color: '#ff8c00', size: 4
                            });
                        }

                        // Damage from intense eye contact
                        b.takeDamage(20, this);
                    }
                });

                // Carrot particles around eyes
                for (let i = 0; i < 10; i++) {
                    particles.push({
                        x: this.x + (Math.random() - 0.5) * 20,
                        y: this.y - 10,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -3,
                        life: 35, color: '#ff6600', size: 6
                    });
                }
            }

            mogging() {
                // MOGGING - Intimidate enemies, reduce their damage and slow them
                this.moggingActive = true;
                this.moggingTimer = 150;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 250) {
                            // Mogged - slowed and weakened
                            b.mogged = 150;
                            b.vx *= 0.3;
                            b.vy *= 0.3;

                            // Intimidation particles
                            for (let i = 0; i < 8; i++) {
                                particles.push({
                                    x: b.x, y: b.y - 30,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: -2,
                                    life: 40, color: '#ffff00', size: 5
                                });
                            }
                        }
                    }
                });

                // Golden mog aura
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 250, color: '#ffd700' });

                // Crown particles
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y - 20 + Math.sin(angle) * 10,
                        vx: Math.cos(angle) * 3,
                        vy: -2,
                        life: 45, color: '#ffd700', size: 8
                    });
                }
            }

            dogpill() {
                // DOGPILL - Summon loyal dogs to attack enemies
                const numDogs = 3;

                for (let d = 0; d < numDogs; d++) {
                    const angle = (d / numDogs) * Math.PI * 2 + Math.random() * 0.5;
                    const spawnDist = 50;

                    // Create dog projectile - aggressive tracking
                    projectiles.push({
                        x: this.x + Math.cos(angle) * spawnDist,
                        y: this.y + Math.sin(angle) * spawnDist,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        damage: 30,
                        owner: this,
                        radius: 15,
                        type: 'dog',
                        life: 300,
                        homing: true,
                        homingStrength: 0.35
                    });

                    // Spawn particles
                    for (let i = 0; i < 8; i++) {
                        particles.push({
                            x: this.x + Math.cos(angle) * spawnDist,
                            y: this.y + Math.sin(angle) * spawnDist,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 20, color: '#8b4513', size: 5
                        });
                    }
                }
            }

            // === GABE BALL ABILITIES ===
            useGabeAbility() {
                const abilities = this.weapon.abilities;
                if (!this.gabeIndex) this.gabeIndex = 0;
                this.currentAbility = abilities[this.gabeIndex];
                this.gabeIndex = (this.gabeIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'steamsale': this.steamSale(); break;
                    case 'valvetime': this.valveTime(); break;
                    case 'gabenblessing': this.gabenBlessing(); break;
                    case 'halflife3': this.halfLife3(); break;
                }
            }

            steamSale() {
                // STEAM SALE - Massive damage boost and discount damage to self
                this.damageMultiplier = 3;
                this.steamSaleActive = true;
                this.steamSaleTimer = 180;

                // Reduce incoming damage by 75%
                this.steamSaleDefense = true;

                // Green money explosion
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 8 + (Math.random() - 0.5) * 3,
                        vy: Math.sin(angle) * 8 + (Math.random() - 0.5) * 3,
                        life: 50, color: '#00ff00', size: 8
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#00ff00' });

                // Damage all enemies with "sale prices"
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 200) {
                            b.takeDamage(35, this);
                            // Push them back
                            const dx = b.x - this.x;
                            const dy = b.y - this.y;
                            b.vx += (dx / dist) * 8;
                            b.vy += (dy / dist) * 8;
                        }
                    }
                });
            }

            valveTime() {
                // VALVE TIME - Slow all enemies dramatically
                this.valveTimeActive = true;
                this.valveTimeTimer = 200;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.valveTimeSlowed = 200;
                        b.vx *= 0.2;
                        b.vy *= 0.2;
                        b.stunned = 30;

                        // Clock particles around slowed enemies
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            particles.push({
                                x: b.x + Math.cos(angle) * 30,
                                y: b.y + Math.sin(angle) * 30,
                                vx: 0, vy: 0,
                                life: 40, color: '#ff6600', size: 6
                            });
                        }
                    }
                });

                // Orange time-warp effect
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 300, color: '#ff6600' });
            }

            gabenBlessing() {
                // GABEN BLESSING - Full heal + shield + speed boost
                this.health = this.maxHealth;
                this.maxHealth += 100;
                this.health += 100;
                this.gabenBlessingActive = true;
                this.gabenBlessingTimer = 150;

                // Temporary invulnerability
                this.isInvulnerable = true;
                setTimeout(() => { if (this.alive) this.isInvulnerable = false; }, 2000);

                // Speed boost
                this.vx *= 1.5;
                this.vy *= 1.5;

                // Golden blessing particles
                for (let ring = 0; ring < 3; ring++) {
                    setTimeout(() => {
                        if (!this.alive) return;
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2;
                            particles.push({
                                x: this.x + Math.cos(angle) * (30 + ring * 20),
                                y: this.y + Math.sin(angle) * (30 + ring * 20),
                                vx: Math.cos(angle) * 4,
                                vy: Math.sin(angle) * 4,
                                life: 50, color: '#ffd700', size: 10
                            });
                        }
                    }, ring * 100);
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 120, color: '#ffd700' });
            }

            halfLife3() {
                // HALF-LIFE 3 - The legendary ultimate attack!
                this.halfLife3Active = true;
                this.halfLife3Timer = 180;

                // Massive damage to ALL enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        // 3x the damage because HL3
                        b.takeDamage(100, this);
                        b.stunned = 90;
                        b.burning = 120;

                        // Lambda particle trail
                        const dx = b.x - this.x;
                        const dy = b.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        for (let i = 0; i < dist; i += 15) {
                            particles.push({
                                x: this.x + (dx / dist) * i,
                                y: this.y + (dy / dist) * i,
                                vx: (Math.random() - 0.5) * 2,
                                vy: (Math.random() - 0.5) * 2,
                                life: 40, color: '#ff6600', size: 8
                            });
                        }
                    }
                });

                // Orange lambda explosion
                for (let i = 0; i < 50; i++) {
                    const angle = (i / 50) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 12,
                        vy: Math.sin(angle) * 12,
                        life: 60, color: i % 3 === 0 ? '#ff6600' : '#ffffff', size: 10
                    });
                }

                // Multiple expanding rings
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 250 + i * 50, color: '#ff6600' });
                    }, i * 150);
                }
            }

            // === LAMP BALL ABILITIES ===
            useLampAbility() {
                const abilities = this.weapon.abilities;
                if (!this.lampIndex) this.lampIndex = 0;
                this.currentAbility = abilities[this.lampIndex];
                this.lampIndex = (this.lampIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'flicker': this.flicker(); break;
                    case 'mothbeacon': this.mothBeacon(); break;
                    case 'blindinglight': this.blindingLight(); break;
                    case 'lamppost': this.lamppost(); break;
                }
            }

            flicker() {
                // FLICKER - Confuse enemies, make them attack randomly
                this.flickerActive = true;
                this.flickerTimer = 120;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 250) {
                            b.confused = 150;
                            // Randomize their direction
                            const randAngle = Math.random() * Math.PI * 2;
                            b.vx = Math.cos(randAngle) * 5;
                            b.vy = Math.sin(randAngle) * 5;

                            // Flashing light particles
                            for (let i = 0; i < 6; i++) {
                                particles.push({
                                    x: b.x + (Math.random() - 0.5) * 30,
                                    y: b.y + (Math.random() - 0.5) * 30,
                                    vx: 0, vy: -2,
                                    life: 20, color: i % 2 === 0 ? '#ffff00' : '#ffffff', size: 8
                                });
                            }
                        }
                    }
                });

                // Flickering light effect
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        if (!this.alive) return;
                        hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ffff88' });
                    }, i * 50);
                }
            }

            mothBeacon() {
                // MOTH BEACON - Summon homing moth projectiles
                const numMoths = 6;

                for (let i = 0; i < numMoths; i++) {
                    const angle = (i / numMoths) * Math.PI * 2;
                    projectiles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        damage: 20,
                        owner: this,
                        radius: 10,
                        type: 'moth',
                        life: 250,
                        homing: true,
                        homingStrength: 0.25
                    });

                    // Spawn particles
                    particles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 30, color: '#d2b48c', size: 6
                    });
                }

                // Light beam effect
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#ffffaa' });
            }

            blindingLight() {
                // BLINDING LIGHT - Stun and damage all nearby enemies
                this.blindingLightActive = true;
                this.blindingLightTimer = 100;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 200) {
                            b.takeDamage(40, this);
                            b.stunned = 90;
                            b.blinded = 120;

                            // White flash on enemy
                            for (let i = 0; i < 10; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 30, color: '#ffffff', size: 10
                                });
                            }
                        }
                    }
                });

                // Massive white flash
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 15,
                        vy: Math.sin(angle) * 15,
                        life: 40, color: '#ffffff', size: 12
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 250, color: '#ffffff' });
            }

            lamppost() {
                // LAMPPOST - Create an illuminated zone that damages enemies inside
                this.lamppostActive = true;
                this.lamppostTimer = 200;

                // Create a damage zone
                const zoneX = this.x;
                const zoneY = this.y;
                const zoneRadius = 120;

                // DoT effect for enemies in zone
                const lamppostInterval = setInterval(() => {
                    if (!this.alive || !this.lamppostActive || !gameRunning) {
                        clearInterval(lamppostInterval);
                        this.lamppostActive = false;
                        return;
                    }

                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.hypot(b.x - zoneX, b.y - zoneY);
                            if (dist < zoneRadius) {
                                b.takeDamage(8, this);
                                b.burning = Math.max(b.burning, 30);

                                // Light burn particles
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 3,
                                    vy: -3,
                                    life: 20, color: '#ffff00', size: 5
                                });
                            }
                        }
                    });

                    // Zone particles
                    for (let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * zoneRadius;
                        particles.push({
                            x: zoneX + Math.cos(angle) * dist,
                            y: zoneY + Math.sin(angle) * dist,
                            vx: 0, vy: -2,
                            life: 25, color: '#ffffaa', size: 4
                        });
                    }
                }, 200);

                // Initial zone indicator
                hitEffects.push({ x: zoneX, y: zoneY, radius: 10, maxRadius: zoneRadius, color: '#ffff88' });
            }

            // === WACKY BALL ABILITIES ===
            useWackyAbility() {
                const abilities = this.weapon.abilities;
                if (!this.wackyIndex) this.wackyIndex = 0;
                this.currentAbility = abilities[this.wackyIndex];
                this.wackyIndex = (this.wackyIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'bonkers': this.bonkersAbility(); break;
                    case 'zany': this.zanyAbility(); break;
                    case 'silly': this.sillyAbility(); break;
                    case 'chaos': this.chaosAbility(); break;
                }
            }

            bonkersAbility() {
                // BONKERS - Random damage to random enemies, unpredictable bouncing
                this.bonkersActive = true;
                this.bonkersTimer = 150;

                // Go absolutely bonkers - random velocity
                const randomAngle = Math.random() * Math.PI * 2;
                const randomSpeed = 10 + Math.random() * 15;
                this.vx = Math.cos(randomAngle) * randomSpeed;
                this.vy = Math.sin(randomAngle) * randomSpeed;

                // Damage random enemies with random amounts
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        if (Math.random() < 0.7) { // 70% chance to hit each enemy
                            const randomDamage = 10 + Math.random() * 50;
                            b.takeDamage(randomDamage, this);

                            // Random colored particles
                            for (let i = 0; i < 8; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 10,
                                    vy: (Math.random() - 0.5) * 10,
                                    life: 30, color: `hsl(${Math.random() * 360}, 100%, 50%)`, size: 6
                                });
                            }
                        }
                    }
                });

                // Spinning X marks everywhere
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 100;
                    particles.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 40, color: `hsl(${Math.random() * 360}, 100%, 50%)`, size: 8
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#ff69b4' });
            }

            zanyAbility() {
                // ZANY - Confuse enemies and apply random status effects
                this.zanyActive = true;
                this.zanyTimer = 120;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 200) {
                            // Random status effect
                            const effect = Math.floor(Math.random() * 5);
                            switch(effect) {
                                case 0: b.stunned = 60 + Math.random() * 60; break;
                                case 1: b.burning = 90 + Math.random() * 60; break;
                                case 2: b.frozen = 60 + Math.random() * 60; break;
                                case 3: b.silenced = 120 + Math.random() * 60; break;
                                case 4: b.confused = 120; break;
                            }

                            // Randomize their movement
                            b.vx = (Math.random() - 0.5) * 15;
                            b.vy = (Math.random() - 0.5) * 15;

                            // Question marks and symbols
                            for (let i = 0; i < 6; i++) {
                                particles.push({
                                    x: b.x + (Math.random() - 0.5) * 40,
                                    y: b.y + (Math.random() - 0.5) * 40,
                                    vx: (Math.random() - 0.5) * 3,
                                    vy: -3,
                                    life: 50, color: '#ffff00', size: 10
                                });
                            }
                        }
                    }
                });

                // Rainbow explosion
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        life: 45, color: `hsl(${i * 18}, 100%, 50%)`, size: 7
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ffff00' });
            }

            sillyAbility() {
                // SILLY - Buff self with random positive effects
                this.sillyActive = true;
                this.sillyTimer = 200;

                // Random buffs
                const buffs = Math.floor(Math.random() * 4) + 2; // 2-5 buffs
                for (let i = 0; i < buffs; i++) {
                    const buff = Math.floor(Math.random() * 5);
                    switch(buff) {
                        case 0: this.damageMultiplier += 0.5; break;
                        case 1: this.health = Math.min(this.maxHealth * 1.5, this.health + 50); break;
                        case 2: this.vx *= 1.3; this.vy *= 1.3; break;
                        case 3: this.isInvulnerable = true; setTimeout(() => { this.isInvulnerable = false; }, 1500); break;
                        case 4: this.maxHealth += 30; this.health += 30; break;
                    }
                }

                // Stars circling animation
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 40,
                        y: this.y + Math.sin(angle) * 40,
                        vx: Math.cos(angle + Math.PI / 2) * 5,
                        vy: Math.sin(angle + Math.PI / 2) * 5,
                        life: 60, color: '#ffff00', size: 10
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80, color: '#00ff00' });
            }

            chaosAbility() {
                // CHAOS - EVERYTHING IS RANDOM! Maximum wackiness!
                this.chaosActive = true;
                this.chaosTimer = 180;

                // Random effects on EVERYONE including self
                balls.forEach(b => {
                    if (b.alive) {
                        // Random teleport
                        if (Math.random() < 0.5) {
                            b.x = 100 + Math.random() * (canvas.width - 200);
                            b.y = 100 + Math.random() * (canvas.height - 200);
                        }

                        // Random velocity
                        b.vx = (Math.random() - 0.5) * 20;
                        b.vy = (Math.random() - 0.5) * 20;

                        // Random health change (can heal or damage!)
                        const healthChange = (Math.random() - 0.3) * 60; // Slightly biased toward damage
                        if (b !== this || healthChange > 0) { // Don't damage self
                            b.health = Math.max(1, Math.min(b.maxHealth, b.health + healthChange));
                        }

                        // Random status
                        if (Math.random() < 0.4 && b !== this) {
                            const statuses = ['stunned', 'burning', 'frozen', 'confused'];
                            b[statuses[Math.floor(Math.random() * statuses.length)]] = 60;
                        }
                    }
                });

                // CHAOS PARTICLES EVERYWHERE
                for (let i = 0; i < 50; i++) {
                    particles.push({
                        x: this.x + (Math.random() - 0.5) * 200,
                        y: this.y + (Math.random() - 0.5) * 200,
                        vx: (Math.random() - 0.5) * 15,
                        vy: (Math.random() - 0.5) * 15,
                        life: 50, color: `hsl(${Math.random() * 360}, 100%, 50%)`, size: 5 + Math.random() * 10
                    });
                }

                // Multiple random hit effects
                for (let i = 0; i < 5; i++) {
                    hitEffects.push({
                        x: this.x + (Math.random() - 0.5) * 150,
                        y: this.y + (Math.random() - 0.5) * 150,
                        radius: 10,
                        maxRadius: 50 + Math.random() * 100,
                        color: `hsl(${Math.random() * 360}, 100%, 50%)`
                    });
                }
            }

            // === SHADOWMANA BALL ABILITIES ===
            useShadowmanaAbility() {
                const abilities = this.weapon.abilities;
                if (!this.shadowmanaIndex) this.shadowmanaIndex = 0;
                this.currentAbility = abilities[this.shadowmanaIndex];
                this.shadowmanaIndex = (this.shadowmanaIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'manadrain': this.manaDrain(); break;
                    case 'shadowstep': this.shadowStep(); break;
                    case 'darkpulse': this.darkPulse(); break;
                    case 'voidrift': this.voidRift(); break;
                }
            }

            manaDrain() {
                // MANA DRAIN - Steal HP from enemies and silence them
                this.manaDrainActive = true;
                this.manaDrainTimer = 120;

                let totalDrained = 0;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 200) {
                            // Drain HP
                            const drainAmount = Math.min(b.health, 25);
                            b.takeDamage(drainAmount, this);
                            totalDrained += drainAmount;

                            // Silence them
                            b.silenced = 180;

                            // Purple drain tendrils
                            const dx = b.x - this.x;
                            const dy = b.y - this.y;
                            for (let i = 0; i < dist; i += 15) {
                                const progress = i / dist;
                                particles.push({
                                    x: this.x + dx * progress,
                                    y: this.y + dy * progress,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: (Math.random() - 0.5) * 2,
                                    life: 30, color: '#9932cc', size: 5
                                });
                            }
                        }
                    }
                });

                // Heal self with drained HP
                this.health = Math.min(this.maxHealth, this.health + totalDrained);

                // Purple energy absorption effect
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const dist = 60;
                    particles.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        vx: -Math.cos(angle) * 4,
                        vy: -Math.sin(angle) * 4,
                        life: 35, color: '#da70d6', size: 7
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#9932cc' });
            }

            shadowStep() {
                // SHADOW STEP - Teleport behind the nearest enemy, brief invulnerability
                this.shadowStepActive = true;
                this.shadowStepTimer = 60;

                // Find nearest enemy
                let nearest = null;
                let nearestDist = Infinity;
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = b;
                        }
                    }
                });

                // Leave shadow afterimage
                for (let i = 0; i < 5; i++) {
                    particles.push({
                        x: this.x, y: this.y,
                        vx: 0, vy: 0,
                        life: 40 - i * 5, color: `rgba(75, 0, 130, ${0.5 - i * 0.1})`, size: 25 - i * 3
                    });
                }

                if (nearest) {
                    // Teleport behind them
                    const angle = Math.atan2(nearest.vy, nearest.vx) || Math.random() * Math.PI * 2;
                    this.x = nearest.x - Math.cos(angle) * 60;
                    this.y = nearest.y - Math.sin(angle) * 60;

                    // Deal backstab damage
                    nearest.takeDamage(35, this);
                    nearest.stunned = 30;

                    // Appear effect
                    for (let i = 0; i < 15; i++) {
                        const pAngle = (i / 15) * Math.PI * 2;
                        particles.push({
                            x: this.x + Math.cos(pAngle) * 30,
                            y: this.y + Math.sin(pAngle) * 30,
                            vx: -Math.cos(pAngle) * 5,
                            vy: -Math.sin(pAngle) * 5,
                            life: 25, color: '#4b0082', size: 8
                        });
                    }
                }

                // Brief invulnerability
                this.isInvulnerable = true;
                setTimeout(() => { if (this.alive) this.isInvulnerable = false; }, 800);

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 60, color: '#4b0082' });
            }

            darkPulse() {
                // DARK PULSE - AoE damage that expands outward
                this.darkPulseActive = true;
                this.darkPulseTimer = 100;

                // Multiple waves of damage
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        if (!this.alive) return;

                        const waveRadius = 80 + wave * 60;

                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dist = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dist < waveRadius && dist > waveRadius - 80) {
                                    b.takeDamage(20, this);
                                    // Push outward
                                    const dx = b.x - this.x;
                                    const dy = b.y - this.y;
                                    b.vx += (dx / dist) * 6;
                                    b.vy += (dy / dist) * 6;
                                }
                            }
                        });

                        // Dark ring effect
                        hitEffects.push({ x: this.x, y: this.y, radius: waveRadius - 60, maxRadius: waveRadius, color: '#8b008b' });

                        // Dark particles on the ring
                        for (let i = 0; i < 16; i++) {
                            const angle = (i / 16) * Math.PI * 2;
                            particles.push({
                                x: this.x + Math.cos(angle) * waveRadius,
                                y: this.y + Math.sin(angle) * waveRadius,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                life: 30, color: '#9400d3', size: 8
                            });
                        }
                    }, wave * 300);
                }
            }

            voidRift() {
                // VOID RIFT - Create a massive damage zone that tears reality
                this.voidRiftActive = true;
                this.voidRiftTimer = 250;

                const riftX = this.x;
                const riftY = this.y;
                const riftRadius = 150;

                // Initial rift opening effect
                for (let i = 0; i < 30; i++) {
                    particles.push({
                        x: riftX + (Math.random() - 0.5) * 60,
                        y: riftY + (Math.random() - 0.5) * 100,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 50, color: i % 2 === 0 ? '#000000' : '#ff00ff', size: 8
                    });
                }

                // Continuous damage in the rift
                const riftInterval = setInterval(() => {
                    if (!this.alive || !this.voidRiftActive || !gameRunning) {
                        clearInterval(riftInterval);
                        this.voidRiftActive = false;
                        return;
                    }

                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.hypot(b.x - riftX, b.y - riftY);
                            if (dist < riftRadius) {
                                // Heavy damage
                                b.takeDamage(15, this);

                                // Pull toward center
                                const dx = riftX - b.x;
                                const dy = riftY - b.y;
                                b.vx += (dx / dist) * 2;
                                b.vy += (dy / dist) * 2;

                                // Void corruption particles
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: (Math.random() - 0.5) * 5,
                                    life: 20, color: '#4b0082', size: 6
                                });
                            }
                        }
                    });

                    // Rift particles
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * riftRadius;
                        particles.push({
                            x: riftX + Math.cos(angle) * dist,
                            y: riftY + Math.sin(angle) * dist,
                            vx: (Math.random() - 0.5) * 3,
                            vy: -2 - Math.random() * 3,
                            life: 30, color: Math.random() < 0.5 ? '#000000' : '#9932cc', size: 5
                        });
                    }
                }, 150);

                // Rift zone indicator
                hitEffects.push({ x: riftX, y: riftY, radius: 10, maxRadius: riftRadius, color: '#4b0082' });

                // Closing effect after duration
                setTimeout(() => {
                    for (let i = 0; i < 40; i++) {
                        const angle = (i / 40) * Math.PI * 2;
                        particles.push({
                            x: riftX + Math.cos(angle) * riftRadius,
                            y: riftY + Math.sin(angle) * riftRadius,
                            vx: -Math.cos(angle) * 8,
                            vy: -Math.sin(angle) * 8,
                            life: 40, color: '#ff00ff', size: 10
                        });
                    }
                }, 3500);
            }

            // === SEBASTIAN BALL ABILITIES ===
            useSebastianAbility() {
                const abilities = this.weapon.abilities;
                if (!this.sebastianIndex) this.sebastianIndex = 0;
                this.currentAbility = abilities[this.sebastianIndex];
                this.sebastianIndex = (this.sebastianIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'butlerstrike': this.butlerStrike(); break;
                    case 'teatime': this.teaTime(); break;
                    case 'silverware': this.silverwareStorm(); break;
                    case 'hellfire': this.hellfireAbility(); break;
                }
            }

            butlerStrike() {
                // BUTLER STRIKE - Throw silverware projectiles at enemies
                this.butlerStrikeActive = true;
                this.butlerStrikeTimer = 100;

                // Throw 8 silverware projectiles
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    projectiles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 12,
                        vy: Math.sin(angle) * 12,
                        damage: 18,
                        owner: this,
                        radius: 8,
                        type: 'silverware',
                        life: 150
                    });
                }

                // Silver flash
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        life: 30, color: '#c0c0c0', size: 5
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80, color: '#c0c0c0' });
            }

            teaTime() {
                // TEA TIME - Heal self and nearby teammates
                this.teaTimeActive = true;
                this.teaTimeTimer = 120;

                // Heal self significantly
                this.health = Math.min(this.maxHealth, this.health + 60);

                // Heal nearby teammates
                balls.forEach(b => {
                    if (b !== this && b.alive && this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 150) {
                            b.health = Math.min(b.maxHealth, b.health + 40);

                            // Tea steam particles to ally
                            for (let i = 0; i < 5; i++) {
                                particles.push({
                                    x: b.x, y: b.y - 20,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: -2,
                                    life: 30, color: '#ffffff', size: 4
                                });
                            }
                        }
                    }
                });

                // Elegant tea steam particles
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: this.x + (Math.random() - 0.5) * 30,
                        y: this.y - 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -3 - Math.random() * 2,
                        life: 40, color: '#ffffff', size: 5
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#90ee90' });
            }

            silverwareStorm() {
                // SILVERWARE STORM - Continuous damage to all nearby enemies
                this.silverwareActive = true;
                this.silverwareTimer = 150;

                // Deal immediate damage
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 120) {
                            b.takeDamage(30, this);
                            b.burning = 60;

                            // Silverware hitting them
                            for (let i = 0; i < 4; i++) {
                                particles.push({
                                    x: b.x + (Math.random() - 0.5) * 20,
                                    y: b.y + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: (Math.random() - 0.5) * 5,
                                    life: 25, color: '#c0c0c0', size: 6
                                });
                            }
                        }
                    }
                });

                // Swirling silverware particles
                for (let i = 0; i < 24; i++) {
                    const angle = (i / 24) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 50,
                        y: this.y + Math.sin(angle) * 50,
                        vx: Math.cos(angle + Math.PI / 2) * 6,
                        vy: Math.sin(angle + Math.PI / 2) * 6,
                        life: 40, color: '#c0c0c0', size: 7
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 120, color: '#c0c0c0' });
            }

            hellfireAbility() {
                // HELLFIRE - Demon butler reveals true form
                this.hellfireActive = true;
                this.hellfireTimer = 200;
                this.damageMultiplier = 2.5;

                // Burn ALL enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.takeDamage(25, this);
                        b.burning = 180;

                        // Hellfire trail
                        const dx = b.x - this.x;
                        const dy = b.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        for (let i = 0; i < dist; i += 20) {
                            particles.push({
                                x: this.x + (dx / dist) * i,
                                y: this.y + (dy / dist) * i,
                                vx: (Math.random() - 0.5) * 3,
                                vy: -2,
                                life: 35, color: i % 2 === 0 ? '#ff4500' : '#ff0000', size: 8
                            });
                        }
                    }
                });

                // Massive hellfire explosion
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        life: 50, color: i % 3 === 0 ? '#ffff00' : (i % 3 === 1 ? '#ff4500' : '#ff0000'), size: 10
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ff4500' });
            }

            // === OOFER BALL ABILITIES ===
            useOoferAbility() {
                const abilities = this.weapon.abilities;
                if (!this.ooferIndex) this.ooferIndex = 0;
                this.currentAbility = abilities[this.ooferIndex];
                this.ooferIndex = (this.ooferIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'bigoof': this.bigOof(); break;
                    case 'robloxian': this.robloxianPower(); break;
                    case 'noobattack': this.noobAttack(); break;
                    case 'buildmode': this.buildMode(); break;
                }
            }

            bigOof() {
                // BIG OOF - Massive damage to nearest enemy
                this.bigOofActive = true;
                this.bigOofTimer = 60;

                // Find nearest enemy
                let nearest = null;
                let nearestDist = Infinity;
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = b;
                        }
                    }
                });

                if (nearest && nearestDist < 200) {
                    nearest.takeDamage(50, this);
                    nearest.stunned = 45;

                    // OOF particles
                    for (let i = 0; i < 10; i++) {
                        particles.push({
                            x: nearest.x + (Math.random() - 0.5) * 40,
                            y: nearest.y + (Math.random() - 0.5) * 40,
                            vx: (Math.random() - 0.5) * 8,
                            vy: -5,
                            life: 40, color: '#ff0000', size: 12
                        });
                    }

                    hitEffects.push({ x: nearest.x, y: nearest.y, radius: 10, maxRadius: 80, color: '#ff0000' });
                }

                // Self OOF effect
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        life: 35, color: '#f3b700', size: 8
                    });
                }
            }

            robloxianPower() {
                // ROBLOXIAN POWER - Power up with blocky aura
                this.robloxianActive = true;
                this.robloxianTimer = 180;
                this.damageMultiplier = 2;
                this.isInvulnerable = true;
                setTimeout(() => { if (this.alive) this.isInvulnerable = false; }, 1500);

                // Speed boost
                const angle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * 12;
                this.vy = Math.sin(angle) * 12;

                // Blocky green aura
                for (let i = 0; i < 16; i++) {
                    particles.push({
                        x: this.x + (Math.random() - 0.5) * 60,
                        y: this.y + (Math.random() - 0.5) * 60,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 45, color: '#00ff00', size: 10
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#00ff00' });
            }

            noobAttack() {
                // NOOB ATTACK - Launch yellow noob cube projectiles
                this.noobAttackActive = true;
                this.noobAttackTimer = 100;

                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    projectiles.push({
                        x: this.x + Math.cos(angle) * 25,
                        y: this.y + Math.sin(angle) * 25,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        damage: 15,
                        owner: this,
                        radius: 12,
                        type: 'noob',
                        life: 180,
                        homing: true,
                        homingStrength: 0.15
                    });

                    particles.push({
                        x: this.x + Math.cos(angle) * 25,
                        y: this.y + Math.sin(angle) * 25,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 25, color: '#ffff00', size: 8
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 60, color: '#ffff00' });
            }

            buildMode() {
                // BUILD MODE - Create barrier blocks that damage enemies
                this.buildModeActive = true;
                this.buildModeTimer = 200;

                // Spawn brick barriers around self
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const dist = 80;

                    // Barrier projectile that stays in place
                    projectiles.push({
                        x: this.x + Math.cos(angle) * dist,
                        y: this.y + Math.sin(angle) * dist,
                        vx: 0,
                        vy: 0,
                        damage: 20,
                        owner: this,
                        radius: 15,
                        type: 'brick',
                        life: 300,
                        color: colors[i % colors.length]
                    });

                    // Build particles
                    for (let j = 0; j < 4; j++) {
                        particles.push({
                            x: this.x + Math.cos(angle) * dist,
                            y: this.y + Math.sin(angle) * dist,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 25, color: colors[i % colors.length], size: 6
                        });
                    }
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#00ff00' });
            }

            // === LEONITAS BALL ABILITIES ===
            useLeonitasAbility() {
                const abilities = this.weapon.abilities;
                if (!this.leonitasIndex) this.leonitasIndex = 0;
                this.currentAbility = abilities[this.leonitasIndex];
                this.leonitasIndex = (this.leonitasIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'thisssparta': this.thisSpartaKick(); break;
                    case 'phalanx': this.phalanxFormation(); break;
                    case 'shieldbash': this.shieldBash(); break;
                    case 'warcry': this.warCry(); break;
                }
            }

            thisSpartaKick() {
                // THIS IS SPARTA - Massive kick attack
                this.spartaActive = true;
                this.spartaTimer = 90;

                // Find nearest enemy
                let nearest = null;
                let nearestDist = Infinity;
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = b;
                        }
                    }
                });

                if (nearest && nearestDist < 150) {
                    // KICK THEM INTO THE PIT
                    nearest.takeDamage(60, this);
                    nearest.stunned = 90;

                    // Launch them away
                    const dx = nearest.x - this.x;
                    const dy = nearest.y - this.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    nearest.vx = (dx / dist) * 25;
                    nearest.vy = (dy / dist) * 25;

                    // Impact particles
                    for (let i = 0; i < 20; i++) {
                        particles.push({
                            x: nearest.x, y: nearest.y,
                            vx: (dx / dist) * 10 + (Math.random() - 0.5) * 8,
                            vy: (dy / dist) * 10 + (Math.random() - 0.5) * 8,
                            life: 40, color: '#8b0000', size: 8
                        });
                    }

                    hitEffects.push({ x: nearest.x, y: nearest.y, radius: 10, maxRadius: 100, color: '#8b0000' });
                }

                // War cry effect
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        life: 35, color: '#ffd700', size: 7
                    });
                }
            }

            phalanxFormation() {
                // PHALANX - Create a shield wall that blocks damage
                this.phalanxActive = true;
                this.phalanxTimer = 200;
                this.isInvulnerable = true;

                // Also protect nearby teammates
                balls.forEach(b => {
                    if (b !== this && b.alive && this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 100) {
                            b.phalanxProtected = 200;
                        }
                    }
                });

                // Shield wall particles
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI - Math.PI / 2;
                    const dist = 50;
                    for (let j = 0; j < 6; j++) {
                        particles.push({
                            x: this.x + Math.cos(angle) * dist,
                            y: this.y + Math.sin(angle) * dist,
                            vx: 0, vy: 0,
                            life: 60, color: '#8b4513', size: 12
                        });
                    }
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#ffd700' });

                setTimeout(() => { if (this.alive) this.isInvulnerable = false; }, 3000);
            }

            shieldBash() {
                // SHIELD BASH - Charge forward and stun
                this.shieldBashActive = true;
                this.shieldBashTimer = 60;

                // Charge in current direction
                const angle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * 18;
                this.vy = Math.sin(angle) * 18;

                // Damage and stun enemies in path
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 80) {
                            b.takeDamage(35, this);
                            b.stunned = 75;

                            // Push them
                            const dx = b.x - this.x;
                            const dy = b.y - this.y;
                            b.vx += (dx / dist) * 10;
                            b.vy += (dy / dist) * 10;
                        }
                    }
                });

                // Shield impact particles
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: this.x + Math.cos(angle) * 30,
                        y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 6 + (Math.random() - 0.5) * 4,
                        vy: Math.sin(angle) * 6 + (Math.random() - 0.5) * 4,
                        life: 30, color: '#ffd700', size: 8
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80, color: '#ffd700' });
            }

            warCry() {
                // WAR CRY - Buff self and fear enemies
                this.warCryActive = true;
                this.warCryTimer = 180;
                this.damageMultiplier = 2;
                this.health = Math.min(this.maxHealth, this.health + 30);

                // Fear nearby enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 180) {
                            // Push them away in fear
                            const dx = b.x - this.x;
                            const dy = b.y - this.y;
                            b.vx = (dx / dist) * 12;
                            b.vy = (dy / dist) * 12;
                            b.feared = 120;
                            b.damageMultiplier = 0.5;
                        }
                    }
                });

                // War cry sound waves
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        if (!this.alive) return;
                        hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#ff4500' });
                    }, wave * 150);
                }

                // Spartan particles
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        life: 45, color: '#8b0000', size: 8
                    });
                }
            }

            // === KILLSWITCH BALL ABILITIES ===
            useKillswitchAbility() {
                const abilities = this.weapon.abilities;
                if (!this.killswitchIndex) this.killswitchIndex = 0;
                this.currentAbility = abilities[this.killswitchIndex];
                this.killswitchIndex = (this.killswitchIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'shutdown': this.shutdownAbility(); break;
                    case 'overload': this.overloadAbility(); break;
                    case 'virus': this.virusAbility(); break;
                    case 'reboot': this.rebootAbility(); break;
                }
            }

            shutdownAbility() {
                // SHUTDOWN - Disable enemy abilities
                this.shutdownActive = true;
                this.shutdownTimer = 150;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 200) {
                            // Silence them hard
                            b.silenced = 300;
                            b.stunned = 30;

                            // Shutdown X particles
                            for (let i = 0; i < 6; i++) {
                                particles.push({
                                    x: b.x + (Math.random() - 0.5) * 30,
                                    y: b.y + (Math.random() - 0.5) * 30,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 40, color: '#ff0000', size: 8
                                });
                            }
                        }
                    }
                });

                // Red shutdown wave
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ff0000' });

                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        life: 35, color: '#ff0000', size: 7
                    });
                }
            }

            overloadAbility() {
                // OVERLOAD - Electric burst damage
                this.overloadActive = true;
                this.overloadTimer = 120;

                // Chain lightning to all enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 250) {
                            b.takeDamage(40, this);
                            b.stunned = 45;

                            // Lightning bolt effect
                            const dx = b.x - this.x;
                            const dy = b.y - this.y;
                            for (let i = 0; i < dist; i += 20) {
                                particles.push({
                                    x: this.x + (dx / dist) * i + (Math.random() - 0.5) * 15,
                                    y: this.y + (dy / dist) * i + (Math.random() - 0.5) * 15,
                                    vx: (Math.random() - 0.5) * 3,
                                    vy: (Math.random() - 0.5) * 3,
                                    life: 20, color: '#ffff00', size: 6
                                });
                            }
                        }
                    }
                });

                // Electric explosion
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 12,
                        vy: Math.sin(angle) * 12,
                        life: 35, color: i % 2 === 0 ? '#ffff00' : '#00ffff', size: 8
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 250, color: '#ffff00' });
            }

            virusAbility() {
                // VIRUS - Infect enemies with spreading DoT
                this.virusActive = true;
                this.virusTimer = 200;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 180) {
                            b.infected = 300;
                            b.burning = 200;

                            // Virus particles
                            for (let i = 0; i < 8; i++) {
                                particles.push({
                                    x: b.x + (Math.random() - 0.5) * 30,
                                    y: b.y + (Math.random() - 0.5) * 30,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: (Math.random() - 0.5) * 4,
                                    life: 45, color: '#ff00ff', size: 6
                                });
                            }
                        }
                    }
                });

                // Virus spread effect
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 7,
                        vy: Math.sin(angle) * 7,
                        life: 50, color: '#ff00ff', size: 5
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#ff00ff' });
            }

            rebootAbility() {
                // REBOOT - Full heal and cleanse all debuffs
                this.rebootActive = true;
                this.rebootTimer = 60;

                // Full heal
                this.health = this.maxHealth;

                // Cleanse all debuffs
                this.burning = 0;
                this.frozen = 0;
                this.stunned = 0;
                this.silenced = 0;
                this.confused = 0;
                this.infected = 0;

                // Temporary shield
                this.isInvulnerable = true;
                setTimeout(() => { if (this.alive) this.isInvulnerable = false; }, 1500);

                // Reboot animation
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 40,
                        y: this.y + Math.sin(angle) * 40,
                        vx: -Math.cos(angle) * 5,
                        vy: -Math.sin(angle) * 5,
                        life: 40, color: '#00ffff', size: 8
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80, color: '#00ffff' });
            }

            // === BIG BRITISH DEMON ABILITIES ===
            useBritishDemonAbility() {
                const abilities = this.weapon.abilities;
                if (!this.britishDemonIndex) this.britishDemonIndex = 0;
                this.currentAbility = abilities[this.britishDemonIndex];
                this.britishDemonIndex = (this.britishDemonIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'teaandhell': this.teaAndHell(); break;
                    case 'queuewrath': this.queueWrath(); break;
                    case 'bloodyhell': this.bloodyHell(); break;
                    case 'godsaveme': this.godSaveMe(); break;
                }
            }

            teaAndHell() {
                // TEA AND HELL - Heal self and burn enemies
                this.teaAndHellActive = true;
                this.teaAndHellTimer = 150;

                // Heal with demonic tea
                this.health = Math.min(this.maxHealth, this.health + 80);

                // Burn all enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.burning = 180;
                        b.takeDamage(15, this);
                    }
                });

                // Tea and hellfire particles
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: this.x - 30 + (Math.random() - 0.5) * 20,
                        y: this.y - 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -4,
                        life: 40, color: i % 2 === 0 ? '#ffffff' : '#ff4500', size: 6
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#ff4500' });
            }

            queueWrath() {
                // QUEUE WRATH - Orderly but deadly damage
                this.queueWrathActive = true;
                this.queueWrathTimer = 120;

                // Damage enemies in order of distance
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                enemies.sort((a, b) => {
                    const distA = Math.hypot(a.x - this.x, a.y - this.y);
                    const distB = Math.hypot(b.x - this.x, b.y - this.y);
                    return distA - distB;
                });

                enemies.forEach((b, index) => {
                    setTimeout(() => {
                        if (b.alive && this.alive) {
                            b.takeDamage(25 + index * 5, this);
                            b.stunned = 30;

                            // Orderly hit effect
                            hitEffects.push({ x: b.x, y: b.y, radius: 5, maxRadius: 40, color: '#ff0000' });

                            for (let i = 0; i < 5; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 25, color: '#ff0000', size: 6
                                });
                            }
                        }
                    }, index * 200);
                });

                // Queue line particles
                for (let i = 0; i < 12; i++) {
                    particles.push({
                        x: this.x, y: this.y,
                        vx: 0, vy: 0,
                        life: 60, color: '#ff0000', size: 8
                    });
                }
            }

            bloodyHell() {
                // BLOODY HELL - Massive AoE blood damage
                this.bloodyHellActive = true;
                this.bloodyHellTimer = 150;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 180) {
                            b.takeDamage(45, this);
                            b.burning = 90;

                            // Blood splatter
                            for (let i = 0; i < 8; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 10,
                                    vy: (Math.random() - 0.5) * 10,
                                    life: 40, color: '#8b0000', size: 8
                                });
                            }
                        }
                    }
                });

                // Blood explosion
                for (let i = 0; i < 35; i++) {
                    const angle = (i / 35) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 12,
                        vy: Math.sin(angle) * 12,
                        life: 45, color: '#8b0000', size: 10
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#8b0000' });
            }

            godSaveMe() {
                // GOD SAVE ME - Ultimate divine/demonic attack
                this.godSaveMeActive = true;
                this.godSaveMeTimer = 200;

                // Full heal
                this.health = this.maxHealth;
                this.maxHealth += 50;
                this.health += 50;

                // Damage ALL enemies heavily
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.takeDamage(70, this);
                        b.stunned = 60;
                        b.burning = 120;

                        // Divine/demonic beam
                        const dx = b.x - this.x;
                        const dy = b.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        for (let i = 0; i < dist; i += 15) {
                            particles.push({
                                x: this.x + (dx / dist) * i,
                                y: this.y + (dy / dist) * i,
                                vx: 0, vy: 0,
                                life: 35, color: i % 2 === 0 ? '#ffd700' : '#ff0000', size: 7
                            });
                        }
                    }
                });

                // Divine/demonic explosion
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 15,
                        vy: Math.sin(angle) * 15,
                        life: 50, color: i % 2 === 0 ? '#ffd700' : '#ff0000', size: 12
                    });
                }

                // Two-tone effect
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 250, color: '#ffd700' });
                setTimeout(() => {
                    hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ff0000' });
                }, 150);
            }

            // === ABA CHAN ABILITIES ===
            useAbaChanAbility() {
                const abilities = this.weapon.abilities;
                if (!this.abaIndex) this.abaIndex = 0;
                this.currentAbility = abilities[this.abaIndex];
                this.abaIndex = (this.abaIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'modeswitch': this.modeSwitch(); break;
                    case 'comboattack': this.comboAttack(); break;
                    case 'awakening': this.abaAwakening(); break;
                    case 'abaultimate': this.abaUltimate(); break;
                }
            }

            modeSwitch() {
                // MODE SWITCH - Toggle between normal and rage mode
                this.abaRageMode = !this.abaRageMode;
                this.modeSwitchActive = true;
                this.modeSwitchTimer = 60;

                if (this.abaRageMode) {
                    // Enter rage mode - boost stats
                    this.damageMultiplier = 2;
                    this.health = Math.min(this.maxHealth, this.health + 30);

                    // Rage activation particles
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * Math.PI * 2;
                        particles.push({
                            x: this.x + Math.cos(angle) * 30,
                            y: this.y + Math.sin(angle) * 30,
                            vx: Math.cos(angle) * 8,
                            vy: Math.sin(angle) * 8,
                            life: 40, color: '#ff6600', size: 8
                        });
                    }

                    hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#ff4500' });
                } else {
                    // Exit rage mode - restore defense
                    this.damageMultiplier = 1;
                    this.isInvulnerable = true;
                    setTimeout(() => { if (this.alive) this.isInvulnerable = false; }, 1000);

                    // Calm particles
                    for (let i = 0; i < 15; i++) {
                        particles.push({
                            x: this.x + (Math.random() - 0.5) * 40,
                            y: this.y + (Math.random() - 0.5) * 40,
                            vx: 0, vy: -2,
                            life: 35, color: '#87ceeb', size: 6
                        });
                    }

                    hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80, color: '#87ceeb' });
                }
            }

            comboAttack() {
                // COMBO ATTACK - Multi-hit attack sequence
                this.comboAttackActive = true;
                this.comboAttackTimer = 120;

                const rageBonus = this.abaRageMode ? 1.5 : 1;

                // 5-hit combo
                for (let hit = 0; hit < 5; hit++) {
                    setTimeout(() => {
                        if (!this.alive) return;

                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dist = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dist < 100) {
                                    b.takeDamage(12 * rageBonus, this);

                                    // Slash effect
                                    for (let i = 0; i < 3; i++) {
                                        particles.push({
                                            x: b.x + (Math.random() - 0.5) * 20,
                                            y: b.y + (Math.random() - 0.5) * 20,
                                            vx: (Math.random() - 0.5) * 8,
                                            vy: (Math.random() - 0.5) * 8,
                                            life: 20, color: '#ffffff', size: 5
                                        });
                                    }
                                }
                            }
                        });

                        // Slash particle
                        const slashAngle = (hit / 5) * Math.PI + Math.PI / 4;
                        particles.push({
                            x: this.x + Math.cos(slashAngle) * 40,
                            y: this.y + Math.sin(slashAngle) * 40,
                            vx: Math.cos(slashAngle) * 10,
                            vy: Math.sin(slashAngle) * 10,
                            life: 15, color: this.abaRageMode ? '#ff6600' : '#c0c0c0', size: 10
                        });
                    }, hit * 80);
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: this.abaRageMode ? '#ff6600' : '#c0c0c0' });
            }

            abaAwakening() {
                // AWAKENING - Power boost and aura
                this.awakeningActive = true;
                this.awakeningTimer = 200;

                // Massive stat boost
                this.damageMultiplier = this.abaRageMode ? 3 : 2;
                this.health = Math.min(this.maxHealth * 1.5, this.health + 50);

                // Speed boost
                const angle = Math.atan2(this.vy, this.vx) || Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * 10;
                this.vy = Math.sin(angle) * 10;

                // Power aura
                for (let ring = 0; ring < 3; ring++) {
                    setTimeout(() => {
                        if (!this.alive) return;
                        for (let i = 0; i < 16; i++) {
                            const angle = (i / 16) * Math.PI * 2;
                            particles.push({
                                x: this.x + Math.cos(angle) * (30 + ring * 15),
                                y: this.y + Math.sin(angle) * (30 + ring * 15),
                                vx: Math.cos(angle) * 5,
                                vy: Math.sin(angle) * 5,
                                life: 45, color: '#ff4500', size: 9
                            });
                        }
                        hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80 + ring * 20, color: '#ff4500' });
                    }, ring * 100);
                }
            }

            abaUltimate() {
                // ABA ULTIMATE - Devastating burst attack
                this.abaUltimateActive = true;
                this.abaUltimateTimer = 180;

                const rageBonus = this.abaRageMode ? 2 : 1;

                // Massive damage to all enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.takeDamage(80 * rageBonus, this);
                        b.stunned = 90;

                        // Energy beam to enemy
                        const dx = b.x - this.x;
                        const dy = b.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        for (let i = 0; i < dist; i += 12) {
                            particles.push({
                                x: this.x + (dx / dist) * i,
                                y: this.y + (dy / dist) * i,
                                vx: (Math.random() - 0.5) * 3,
                                vy: (Math.random() - 0.5) * 3,
                                life: 30, color: '#ff0000', size: 8
                            });
                        }

                        // Impact on enemy
                        for (let i = 0; i < 12; i++) {
                            particles.push({
                                x: b.x, y: b.y,
                                vx: (Math.random() - 0.5) * 12,
                                vy: (Math.random() - 0.5) * 12,
                                life: 35, color: '#ff4500', size: 10
                            });
                        }
                    }
                });

                // Massive explosion
                for (let i = 0; i < 50; i++) {
                    const angle = (i / 50) * Math.PI * 2;
                    particles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 15,
                        vy: Math.sin(angle) * 15,
                        life: 50, color: i % 3 === 0 ? '#ff0000' : (i % 3 === 1 ? '#ff6600' : '#ffff00'), size: 12
                    });
                }

                // Multiple shockwaves
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200 + i * 50, color: '#ff0000' });
                    }, i * 150);
                }
            }

            // === CASINO BALL ABILITIES ===
            useCasinoAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'slotroll': this.slotRoll(); break;
                    case 'chipbarrage': this.chipBarrage(); break;
                    case 'cardshark': this.cardShark(); break;
                    case 'housewins': this.houseWins(); break;
                }
            }

            slotRoll() {
                // Roll the slot machine - chance for JACKPOT!
                const roll = Math.random();

                if (roll < 0.25) { // 25% chance for JACKPOT!
                    // JACKPOT - Massive buffs for the rest of the round!
                    this.jackpotActive = true;
                    this.maxHealth = 500;
                    this.health = 500;
                    this.damageMultiplier = 3;
                    this.cashTrailActive = true;

                    // Jackpot explosion effect
                    for (let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        particles.push({ x: this.x, y: this.y,
                            vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10,
                            life: 60, color: i % 2 === 0 ? '#ffd700' : '#ffff00', size: 10 });
                    }
                    hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ffd700' });

                    // Spawn money everywhere
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * 150;
                        particles.push({ x: this.x + Math.cos(angle) * dist, y: this.y + Math.sin(angle) * dist,
                            vx: (Math.random() - 0.5) * 5, vy: -Math.random() * 5,
                            life: 80, color: '#00ff00', size: 8 });
                    }
                } else if (roll < 0.5) { // 25% - Good prize
                    this.health = Math.min(this.maxHealth, this.health + 100);
                    this.damageMultiplier = 2;
                    this.powerupDamageBuff = 300;
                    for (let i = 0; i < 20; i++) {
                        particles.push({ x: this.x, y: this.y,
                            vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                            life: 40, color: '#00ff00', size: 6 });
                    }
                } else if (roll < 0.75) { // 25% - Small prize
                    this.health = Math.min(this.maxHealth, this.health + 30);
                    for (let i = 0; i < 10; i++) {
                        particles.push({ x: this.x, y: this.y,
                            vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                            life: 30, color: '#ffff00', size: 5 });
                    }
                } else { // 25% - Bust! Damage nearby enemies in frustration
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                            if (dist < 100) {
                                b.takeDamage(25, this);
                            }
                        }
                    });
                    for (let i = 0; i < 15; i++) {
                        particles.push({ x: this.x, y: this.y,
                            vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                            life: 25, color: '#ff0000', size: 5 });
                    }
                }
            }

            chipBarrage() {
                // Throw casino chips in waves - multi-hit!
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2 + wave * 0.2;
                            projectiles.push({
                                x: this.x, y: this.y,
                                vx: Math.cos(angle) * 7, vy: Math.sin(angle) * 7,
                                radius: 8, damage: 10, owner: this, type: 'chip', life: 80
                            });
                        }
                        // Chip particles
                        for (let j = 0; j < 12; j++) {
                            particles.push({ x: this.x, y: this.y,
                                vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                                life: 20, color: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'][j % 4], size: 5 });
                        }
                    }, wave * 150);
                }
            }

            cardShark() {
                // Rapid fire playing cards - 5 bursts of damage
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));

                for (let burst = 0; burst < 5; burst++) {
                    setTimeout(() => {
                        // Throw cards at all enemies
                        targets.forEach(target => {
                            if (target.alive) {
                                const dx = target.x - this.x;
                                const dy = target.y - this.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 250) {
                                    projectiles.push({
                                        x: this.x, y: this.y,
                                        vx: (dx / dist) * 10, vy: (dy / dist) * 10,
                                        radius: 6, damage: 8, owner: this, type: 'card', life: 60
                                    });
                                }
                            }
                        });
                        // Card particles
                        for (let j = 0; j < 8; j++) {
                            particles.push({ x: this.x, y: this.y,
                                vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                                life: 25, color: '#ffffff', size: 4 });
                        }
                    }, burst * 100);
                }
            }

            houseWins() {
                // The house always wins - massive damage burst + steal health
                let totalDamage = 0;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 180) {
                            const damage = 40;
                            b.takeDamage(damage, this);
                            totalDamage += damage;

                            // Money flying from enemy to you
                            for (let j = 0; j < 5; j++) {
                                setTimeout(() => {
                                    particles.push({ x: b.x, y: b.y,
                                        vx: (this.x - b.x) * 0.05, vy: (this.y - b.y) * 0.05,
                                        life: 30, color: '#00ff00', size: 6 });
                                }, j * 50);
                            }
                        }
                    }
                });

                // Heal based on damage dealt
                this.health = Math.min(this.maxHealth, this.health + totalDamage * 0.5);

                // Victory effect
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#00ff00' });
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y,
                        vx: Math.cos(angle) * 6, vy: Math.sin(angle) * 6,
                        life: 40, color: i % 3 === 0 ? '#ffd700' : '#00ff00', size: 7 });
                }
            }

            // === AMERICAN BALL ABILITIES ===
            useAmericanAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;
                switch(this.currentAbility) {
                    case 'shotgun': this.shotgunBlast(); break;
                    case 'assaultrifle': this.assaultRifle(); break;
                    case 'grenadelauncher': this.grenadeLauncher(); break;
                    case 'airstrike': this.callAirstrike(); break;
                }
            }

            shotgunBlast() {
                // Wide spread of pellets
                const baseAngle = this.angle;
                for (let i = 0; i < 12; i++) {
                    const spread = (i - 6) * 0.15;
                    const angle = baseAngle + spread;
                    projectiles.push({
                        x: this.x + Math.cos(baseAngle) * 25,
                        y: this.y + Math.sin(baseAngle) * 25,
                        vx: Math.cos(angle) * 12 + (Math.random() - 0.5) * 2,
                        vy: Math.sin(angle) * 12 + (Math.random() - 0.5) * 2,
                        radius: 5, damage: 8, owner: this, type: 'bullet', life: 40
                    });
                }
                // Muzzle flash
                for (let i = 0; i < 15; i++) {
                    particles.push({ x: this.x + Math.cos(baseAngle) * 30, y: this.y + Math.sin(baseAngle) * 30,
                        vx: Math.cos(baseAngle) * 8 + (Math.random() - 0.5) * 5,
                        vy: Math.sin(baseAngle) * 8 + (Math.random() - 0.5) * 5,
                        life: 15, color: '#ffff00', size: 6 });
                }
            }

            assaultRifle() {
                // Rapid fire burst - 10 shots
                const baseAngle = this.angle;
                for (let shot = 0; shot < 10; shot++) {
                    setTimeout(() => {
                        const angle = baseAngle + (Math.random() - 0.5) * 0.2;
                        projectiles.push({
                            x: this.x + Math.cos(baseAngle) * 25,
                            y: this.y + Math.sin(baseAngle) * 25,
                            vx: Math.cos(angle) * 15,
                            vy: Math.sin(angle) * 15,
                            radius: 4, damage: 10, owner: this, type: 'bullet', life: 50
                        });
                        // Small muzzle flash
                        particles.push({ x: this.x + Math.cos(baseAngle) * 35, y: this.y + Math.sin(baseAngle) * 35,
                            vx: Math.cos(baseAngle) * 5, vy: Math.sin(baseAngle) * 5,
                            life: 8, color: '#ffaa00', size: 5 });
                    }, shot * 50);
                }
            }

            grenadeLauncher() {
                // Launch explosive grenades
                for (let i = 0; i < 3; i++) {
                    const angle = this.angle + (i - 1) * 0.4;
                    setTimeout(() => {
                        projectiles.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8,
                            radius: 12, damage: 35, owner: this, type: 'grenade', life: 60,
                            explosive: true, explosionRadius: 80
                        });
                    }, i * 200);
                }
            }

            callAirstrike() {
                // Regular airstrike ability (can also be triggered as ultimate)
                this.triggerAirSupport(false);
            }

            // Check for low HP air support trigger (called from update)
            checkAirSupportTrigger() {
                if (this.weapon.id === 'american' &&
                    this.health < this.maxHealth * 0.1 &&
                    this.health > 0 &&
                    !this.airSupportUsed &&
                    this.alive) {
                    this.airSupportUsed = true;
                    this.triggerAirSupport(true);
                }
            }

            triggerAirSupport(isUltimate) {
                this.airSupportActive = true;
                setTimeout(() => { this.airSupportActive = false; }, 3000);

                const roll = Math.random();
                let supportType;

                if (roll < 0.01) { // 1% - HYDROGEN BOMB
                    supportType = 'nuke';
                } else if (roll < 0.25) { // 24% - Supply drop
                    supportType = 'supply';
                } else if (roll < 0.50) { // 25% - A-10 Warthog
                    supportType = 'warthog';
                } else if (roll < 0.75) { // 25% - Mortar strike
                    supportType = 'mortar';
                } else { // 25% - Drone bomb
                    supportType = 'drone';
                }

                switch(supportType) {
                    case 'nuke':
                        this.hydrogenBomb();
                        break;
                    case 'supply':
                        this.supplyDrop();
                        break;
                    case 'warthog':
                        this.a10Warthog();
                        break;
                    case 'mortar':
                        this.mortarStrike();
                        break;
                    case 'drone':
                        this.droneBomb();
                        break;
                }
            }

            hydrogenBomb() {
                // 1% chance - DEVASTATING NUKE
                // Warning effect
                hitEffects.push({ x: centerX, y: centerY, radius: 10, maxRadius: arenaRadius, color: '#ffffff' });

                setTimeout(() => {
                    // Kill/massively damage ALL enemies
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            b.takeDamage(500, this); // Basically instant kill
                            b.burning = 300;
                        }
                    });
                    // Heal self to full
                    this.health = this.maxHealth;

                    // MASSIVE explosion effect
                    for (let wave = 0; wave < 5; wave++) {
                        setTimeout(() => {
                            hitEffects.push({ x: centerX, y: centerY, radius: wave * 50, maxRadius: arenaRadius, color: wave % 2 === 0 ? '#ffffff' : '#ff8800' });
                            for (let i = 0; i < 100; i++) {
                                const angle = (i / 100) * Math.PI * 2;
                                const dist = wave * 60;
                                particles.push({ x: centerX + Math.cos(angle) * dist, y: centerY + Math.sin(angle) * dist,
                                    vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15,
                                    life: 80, color: ['#ffffff', '#ffff00', '#ff8800', '#ff0000'][i % 4], size: 12 });
                            }
                        }, wave * 100);
                    }
                }, 1000);
            }

            supplyDrop() {
                // Healing supply drop
                this.health = Math.min(this.maxHealth, this.health + 150);
                this.isInvulnerable = true;
                this.powerupShield = 180;

                // Parachute particles falling
                for (let i = 0; i < 30; i++) {
                    particles.push({ x: this.x + (Math.random() - 0.5) * 80, y: this.y - 100,
                        vx: (Math.random() - 0.5) * 2, vy: 3,
                        life: 60, color: '#00ff00', size: 8 });
                }
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 100, color: '#00ff00' });
            }

            a10Warthog() {
                // BRRRRT gun run across the arena
                const startX = -50;
                const startY = this.y;

                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        const bulletX = startX + i * 30;
                        // Spray bullets downward
                        for (let j = 0; j < 5; j++) {
                            projectiles.push({
                                x: bulletX + (Math.random() - 0.5) * 40,
                                y: startY - 100,
                                vx: (Math.random() - 0.5) * 3,
                                vy: 12,
                                radius: 6, damage: 15, owner: this, type: 'bullet', life: 80
                            });
                        }
                        // Tracer particles
                        particles.push({ x: bulletX, y: startY - 80,
                            vx: 0, vy: 8, life: 20, color: '#ffff00', size: 4 });
                    }, i * 30);
                }

                // BRRRT sound effect particles
                for (let i = 0; i < 20; i++) {
                    particles.push({ x: this.x, y: this.y - 50,
                        vx: (Math.random() - 0.5) * 5, vy: -3,
                        life: 40, color: '#888888', size: 6 });
                }
            }

            mortarStrike() {
                // Multiple mortar explosions around enemies
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));

                for (let mortar = 0; mortar < 8; mortar++) {
                    setTimeout(() => {
                        let targetX, targetY;
                        if (targets.length > 0 && Math.random() < 0.7) {
                            const target = targets[Math.floor(Math.random() * targets.length)];
                            targetX = target.x + (Math.random() - 0.5) * 60;
                            targetY = target.y + (Math.random() - 0.5) * 60;
                        } else {
                            targetX = centerX + (Math.random() - 0.5) * arenaRadius * 1.5;
                            targetY = centerY + (Math.random() - 0.5) * arenaRadius * 1.5;
                        }

                        // Explosion at target
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dist = Math.sqrt((b.x - targetX) ** 2 + (b.y - targetY) ** 2);
                                if (dist < 60) {
                                    b.takeDamage(30, this);
                                    b.stunned = 30;
                                }
                            }
                        });

                        hitEffects.push({ x: targetX, y: targetY, radius: 10, maxRadius: 60, color: '#ff4400' });
                        for (let p = 0; p < 15; p++) {
                            particles.push({ x: targetX, y: targetY,
                                vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                                life: 30, color: p % 2 === 0 ? '#ff4400' : '#ffaa00', size: 7 });
                        }
                    }, mortar * 150);
                }
            }

            droneBomb() {
                // Precision drone strike on nearest enemy
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;

                const target = targets.reduce((a, b) =>
                    Math.sqrt((a.x-this.x)**2+(a.y-this.y)**2) < Math.sqrt((b.x-this.x)**2+(b.y-this.y)**2) ? a : b);

                // Drone approach
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        particles.push({ x: target.x, y: target.y - 150 + i * 5,
                            vx: 0, vy: 3, life: 15, color: '#333333', size: 5 });
                    }, i * 30);
                }

                // Explosion after delay
                setTimeout(() => {
                    target.takeDamage(80, this);
                    target.stunned = 60;

                    hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 100, color: '#ff0000' });
                    for (let p = 0; p < 25; p++) {
                        particles.push({ x: target.x, y: target.y,
                            vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12,
                            life: 40, color: ['#ff0000', '#ff4400', '#ffaa00'][p % 3], size: 8 });
                    }

                    // Damage nearby enemies too
                    balls.forEach(b => {
                        if (b !== this && b !== target && b.alive && !this.isTeammate(b)) {
                            const dist = Math.sqrt((b.x - target.x) ** 2 + (b.y - target.y) ** 2);
                            if (dist < 80) {
                                b.takeDamage(40, this);
                            }
                        }
                    });
                }, 600);
            }

            // === DIVINITY BALL ABILITIES (MYTHICAL) ===
            useDivinityAbility() {
                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'heal': this.divineHeal(); break;
                    case 'omnipotence': this.omnipotence(); break;
                    case 'steal': this.abilitySteal(); break;
                    case 'stun': this.divineStun(); break;
                    case 'silence': this.divineSilence(); break;
                    case 'charm': this.divineCharm(); break;
                    case 'smite': this.divineSmite(); break;
                    case 'resurrect': this.divineResurrect(); break;
                    case 'shield': this.divineShield(); break;
                    case 'judgment': this.divineJudgment(); break;
                    case 'blessing': this.divineBlessing(); break;
                    case 'curse': this.divineCurse(); break;
                    case 'ascend': this.divineAscend(); break;
                    case 'holyfire': this.holyFire(); break;
                    case 'miracle': this.divineMiracle(); break;
                    case 'rapture': this.divineRapture(); break;
                }
            }

            // 1. Divine Heal - Massive self heal
            divineHeal() {
                const healAmount = this.maxHealth * 0.5;
                this.health = Math.min(this.maxHealth, this.health + healAmount);

                // Golden healing particles rising
                for (let i = 0; i < 30; i++) {
                    particles.push({ x: this.x + (Math.random() - 0.5) * 40, y: this.y,
                        vx: (Math.random() - 0.5) * 2, vy: -3 - Math.random() * 2,
                        life: 50, color: '#ffd700', size: 8 });
                }
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80, color: '#00ff00' });
            }

            // 2. Omnipotence - Use 10 random abilities at once!
            omnipotence() {
                this.omnipotentActive = true;
                setTimeout(() => { this.omnipotentActive = false; }, 3000);

                const allAbilities = ['smite', 'stun', 'holyfire', 'judgment', 'blessing', 'curse'];

                // Fire 10 abilities rapidly
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const ability = allAbilities[Math.floor(Math.random() * allAbilities.length)];
                        switch(ability) {
                            case 'smite': this.divineSmite(); break;
                            case 'stun': this.divineStun(); break;
                            case 'holyfire': this.holyFire(); break;
                            case 'judgment': this.divineJudgment(); break;
                            case 'blessing': this.divineBlessing(); break;
                            case 'curse': this.divineCurse(); break;
                        }
                    }, i * 100);
                }

                // Massive power effect
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#ffffff' });
            }

            // 3. Ability Steal - Copy a random enemy's weapon ability
            abilitySteal() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b) && b.weapon);
                if (enemies.length === 0) return;

                const target = enemies[Math.floor(Math.random() * enemies.length)];
                const stolenWeapon = target.weapon;

                // Temporarily gain their weapon's power
                this.stolenAbility = stolenWeapon;
                this.damageMultiplier = (this.damageMultiplier || 1) + 0.5;

                // Steal effect - energy beam to target
                for (let i = 0; i < 20; i++) {
                    const t = i / 20;
                    const px = this.x + (target.x - this.x) * t;
                    const py = this.y + (target.y - this.y) * t;
                    particles.push({ x: px, y: py,
                        vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                        life: 30, color: '#9932cc', size: 6 });
                }

                // Damage and weaken target
                target.takeDamage(25, this);
                target.damageMultiplier = Math.max(0.5, (target.damageMultiplier || 1) - 0.3);

                hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 50, color: '#9932cc' });
            }

            // 4. Divine Stun - Stun ALL enemies
            divineStun() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.stunned = 120; // 2 seconds

                        // Lightning bolt effect
                        for (let i = 0; i < 15; i++) {
                            particles.push({ x: b.x + (Math.random() - 0.5) * 30, y: b.y + (Math.random() - 0.5) * 30,
                                vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                                life: 25, color: '#ffff00', size: 5 });
                        }
                        hitEffects.push({ x: b.x, y: b.y, radius: 5, maxRadius: 40, color: '#ffff00' });
                    }
                });
            }

            // 5. Silence - Disable enemy abilities
            divineSilence() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.silenced = 300; // 5 seconds - can't use abilities
                        b.abilityCooldown = 999; // Max out their cooldown

                        // Purple silence effect
                        for (let i = 0; i < 10; i++) {
                            particles.push({ x: b.x, y: b.y - 20,
                                vx: (Math.random() - 0.5) * 3, vy: -2,
                                life: 40, color: '#800080', size: 6 });
                        }
                    }
                });

                hitEffects.push({ x: this.x, y: this.y, radius: 20, maxRadius: 200, color: '#800080' });
            }

            // 6. Divine Charm - Make enemies attack themselves
            divineCharm() {
                this.charmActive = true;
                setTimeout(() => { this.charmActive = false; }, 2000);

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.charmed = 180; // 3 seconds
                        b.charmSource = this;

                        // Self-damage over time
                        const charmDamage = setInterval(() => {
                            if (b.charmed > 0 && b.alive) {
                                b.takeDamage(15, this);
                                particles.push({ x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 4, vy: -2,
                                    life: 20, color: '#ff69b4', size: 5 });
                            } else {
                                clearInterval(charmDamage);
                            }
                        }, 200);

                        // Heart particles
                        for (let i = 0; i < 10; i++) {
                            particles.push({ x: b.x + (Math.random() - 0.5) * 30, y: b.y,
                                vx: (Math.random() - 0.5) * 2, vy: -2 - Math.random(),
                                life: 40, color: '#ff1493', size: 7 });
                        }
                    }
                });
            }

            // 7. Divine Smite - Massive single target damage
            divineSmite() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;

                // Target lowest HP enemy
                const target = enemies.reduce((a, b) => a.health < b.health ? a : b);

                // Smite from above!
                target.takeDamage(100, this);
                target.stunned = 60;

                // Lightning pillar effect
                for (let y = -200; y < 0; y += 10) {
                    particles.push({ x: target.x + (Math.random() - 0.5) * 20, y: target.y + y,
                        vx: 0, vy: 5,
                        life: 20, color: '#ffffff', size: 8 });
                }
                hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 100, color: '#ffd700' });
            }

            // 8. Divine Resurrect - Auto-revive when killed (or heal to full if alive)
            divineResurrect() {
                this.hasResurrect = true;
                this.health = this.maxHealth;
                this.isInvulnerable = true;
                this.powerupShield = 120;

                // Resurrection glow
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y,
                        vx: Math.cos(angle) * 5, vy: Math.sin(angle) * 5,
                        life: 50, color: '#ffffff', size: 8 });
                }
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 120, color: '#ffffff' });
            }

            // 9. Divine Shield - Complete invulnerability
            divineShield() {
                this.isInvulnerable = true;
                this.powerupShield = 300; // 5 seconds
                this.divineShieldActive = true;
                setTimeout(() => { this.divineShieldActive = false; }, 5000);

                // Shield bubble effect
                hitEffects.push({ x: this.x, y: this.y, radius: 30, maxRadius: 60, color: '#00ffff' });
            }

            // 10. Divine Judgment - Damage ALL enemies based on their sins (missing HP)
            divineJudgment() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        // More damage to enemies with more missing HP
                        const missingHpPercent = 1 - (b.health / b.maxHealth);
                        const damage = 30 + missingHpPercent * 70; // 30-100 damage
                        b.takeDamage(damage, this);

                        // Judgment beam from above
                        for (let i = 0; i < 10; i++) {
                            particles.push({ x: b.x, y: b.y - 100 + i * 10,
                                vx: 0, vy: 8,
                                life: 15, color: '#ffd700', size: 6 });
                        }
                        hitEffects.push({ x: b.x, y: b.y, radius: 5, maxRadius: 50, color: '#ffd700' });
                    }
                });
            }

            // 11. Divine Blessing - Buff self massively
            divineBlessing() {
                this.damageMultiplier = (this.damageMultiplier || 1) + 1;
                this.speed = (this.speed || 1) * 1.5;
                this.blessed = 300;

                // Blessing aura
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({ x: this.x + Math.cos(angle) * 30, y: this.y + Math.sin(angle) * 30,
                        vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2,
                        life: 40, color: '#87ceeb', size: 6 });
                }
            }

            // 12. Divine Curse - Debuff all enemies
            divineCurse() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.damageMultiplier = Math.max(0.3, (b.damageMultiplier || 1) * 0.5);
                        b.cursed = 300;
                        b.burning = 120;

                        // Dark curse particles
                        for (let i = 0; i < 15; i++) {
                            particles.push({ x: b.x + (Math.random() - 0.5) * 40, y: b.y + (Math.random() - 0.5) * 40,
                                vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                life: 35, color: '#4b0082', size: 5 });
                        }
                    }
                });
                hitEffects.push({ x: this.x, y: this.y, radius: 20, maxRadius: 250, color: '#4b0082' });
            }

            // 13. Divine Ascend - Become untargetable
            divineAscend() {
                this.ascended = true;
                this.isInvulnerable = true;

                setTimeout(() => {
                    this.ascended = false;
                    this.isInvulnerable = false;
                }, 4000);

                // Ascension particles rising
                for (let i = 0; i < 50; i++) {
                    particles.push({ x: this.x + (Math.random() - 0.5) * 60, y: this.y + 30,
                        vx: (Math.random() - 0.5) * 2, vy: -4 - Math.random() * 3,
                        life: 60, color: '#ffffff', size: 7 });
                }
            }

            // 14. Holy Fire - Burn all enemies
            holyFire() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.burning = 300; // 5 seconds of burning
                        b.takeDamage(20, this);

                        // Holy fire particles
                        for (let i = 0; i < 20; i++) {
                            particles.push({ x: b.x + (Math.random() - 0.5) * 30, y: b.y + (Math.random() - 0.5) * 30,
                                vx: (Math.random() - 0.5) * 4, vy: -3 - Math.random() * 2,
                                life: 40, color: i % 2 === 0 ? '#ffd700' : '#ffffff', size: 6 });
                        }
                    }
                });

                // Fire wave effect
                hitEffects.push({ x: this.x, y: this.y, radius: 20, maxRadius: 200, color: '#ffd700' });
            }

            // 15. Divine Miracle - Random powerful effect
            divineMiracle() {
                const roll = Math.random();

                if (roll < 0.15) {
                    // Full heal + invuln
                    this.health = this.maxHealth;
                    this.isInvulnerable = true;
                    this.powerupShield = 180;
                } else if (roll < 0.30) {
                    // Instant kill random enemy
                    const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                    if (enemies.length > 0) {
                        const target = enemies[Math.floor(Math.random() * enemies.length)];
                        target.takeDamage(9999, this);
                        hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 150, color: '#ff0000' });
                    }
                } else if (roll < 0.50) {
                    // Triple damage for duration
                    this.damageMultiplier = (this.damageMultiplier || 1) * 3;
                    this.miracleBuff = 300;
                } else if (roll < 0.70) {
                    // Heal all teammates
                    balls.forEach(b => {
                        if (this.isTeammate(b) && b.alive) {
                            b.health = b.maxHealth;
                        }
                    });
                } else {
                    // Stun + damage all enemies
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            b.stunned = 180;
                            b.takeDamage(50, this);
                        }
                    });
                }

                // Miracle sparkles
                for (let i = 0; i < 60; i++) {
                    particles.push({ x: this.x + (Math.random() - 0.5) * 100, y: this.y + (Math.random() - 0.5) * 100,
                        vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                        life: 50, color: ['#ff0000', '#ffa500', '#ffff00', '#00ff00', '#0000ff', '#800080'][i % 6], size: 7 });
                }
            }

            // 16. Divine Rapture - Pull all enemies to center and damage
            divineRapture() {
                const raptureX = this.x;
                const raptureY = this.y;

                // Create pull effect over time
                for (let wave = 0; wave < 10; wave++) {
                    setTimeout(() => {
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                // Pull toward divinity
                                const dx = raptureX - b.x;
                                const dy = raptureY - b.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    b.vx += (dx / dist) * 8;
                                    b.vy += (dy / dist) * 8;
                                }

                                // Damage while being pulled
                                b.takeDamage(10, this);
                            }
                        });

                        // Visual pull effect
                        hitEffects.push({ x: raptureX, y: raptureY, radius: 200 - wave * 15, maxRadius: 200 - wave * 15 + 20, color: '#ffd700' });
                    }, wave * 100);
                }

                // Final explosion
                setTimeout(() => {
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.sqrt((b.x - raptureX) ** 2 + (b.y - raptureY) ** 2);
                            if (dist < 100) {
                                b.takeDamage(80, this);
                                b.stunned = 90;
                            }
                        }
                    });

                    hitEffects.push({ x: raptureX, y: raptureY, radius: 10, maxRadius: 150, color: '#ffffff' });
                    for (let i = 0; i < 50; i++) {
                        const angle = (i / 50) * Math.PI * 2;
                        particles.push({ x: raptureX, y: raptureY,
                            vx: Math.cos(angle) * 12, vy: Math.sin(angle) * 12,
                            life: 40, color: '#ffd700', size: 10 });
                    }
                }, 1000);
            }

            // === ARCHMAGE ABILITIES (MYTHICAL) ===
            useArchmageAbility() {
                // Check for Grand Disintegration condition first
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 1 && this.health >= enemies[0].health + 30) {
                    this.grandDisintegration(enemies[0]);
                    return;
                }

                const abilities = this.weapon.abilities;
                this.currentAbility = abilities[this.archangelAbilityIndex];
                this.archangelAbilityIndex = (this.archangelAbilityIndex + 1) % abilities.length;

                switch(this.currentAbility) {
                    case 'magiccircle': this.castMagicCircle(); break;
                    case 'resurrect_zombie': this.resurrectZombie(); break;
                    case 'disintegrate': this.castMagicCircle(); break; // Cast circle if not in 1v1
                }
            }

            // Cast a random magic circle spell (20 possibilities!)
            castMagicCircle() {
                const spell = Math.floor(Math.random() * 20);
                const circleX = this.x;
                const circleY = this.y;

                // Visual magic circle
                this.spawnMagicCircle(circleX, circleY);

                switch(spell) {
                    case 0: this.spellFireball(circleX, circleY); break;
                    case 1: this.spellIceStorm(circleX, circleY); break;
                    case 2: this.spellLightningStrike(circleX, circleY); break;
                    case 3: this.spellMeteorShower(circleX, circleY); break;
                    case 4: this.spellArcaneMissiles(); break;
                    case 5: this.spellGravityWell(circleX, circleY); break;
                    case 6: this.spellTimeWarp(circleX, circleY); break;
                    case 7: this.spellHealingCircle(circleX, circleY); break;
                    case 8: this.spellShieldDome(); break;
                    case 9: this.spellPoisonCloud(circleX, circleY); break;
                    case 10: this.spellChainLightning(); break;
                    case 11: this.spellEarthquake(circleX, circleY); break;
                    case 12: this.spellTornado(circleX, circleY); break;
                    case 13: this.spellManaBurn(); break;
                    case 14: this.spellMirrorImage(); break;
                    case 15: this.spellTeleport(); break;
                    case 16: this.spellSummonElemental(); break;
                    case 17: this.spellCurseCircle(circleX, circleY); break;
                    case 18: this.spellBlessingCircle(circleX, circleY); break;
                    case 19: this.spellVoidRift(circleX, circleY); break;
                }
            }

            spawnMagicCircle(x, y) {
                // Create visual magic circle effect
                for (let ring = 0; ring < 3; ring++) {
                    setTimeout(() => {
                        hitEffects.push({ x: x, y: y, radius: 20 + ring * 30, maxRadius: 80 + ring * 30, color: '#9932cc' });
                    }, ring * 100);
                }
                // Rune particles
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({ x: x + Math.cos(angle) * 50, y: y + Math.sin(angle) * 50,
                        vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2,
                        life: 40, color: '#ff00ff', size: 6 });
                }
            }

            // SPELL 1: Fireball - explosive damage
            spellFireball(x, y) {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;
                const target = targets[Math.floor(Math.random() * targets.length)];

                // Launch fireball projectile
                const angle = Math.atan2(target.y - y, target.x - x);
                projectiles.push({
                    x: x, y: y, vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10,
                    radius: 20, damage: 60, owner: this, type: 'fireball', life: 100,
                    explosive: true, explosionRadius: 100
                });
            }

            // SPELL 2: Ice Storm - freeze enemies
            spellIceStorm(x, y) {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - x) ** 2 + (b.y - y) ** 2);
                        if (dist < 150) {
                            b.frozen = 180;
                            b.takeDamage(25, this);
                            for (let i = 0; i < 15; i++) {
                                particles.push({ x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                                    life: 40, color: '#00ffff', size: 6 });
                            }
                        }
                    }
                });
                hitEffects.push({ x: x, y: y, radius: 10, maxRadius: 150, color: '#00ffff' });
            }

            // SPELL 3: Lightning Strike - high damage + stun
            spellLightningStrike(x, y) {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;
                const target = targets.reduce((a, b) =>
                    Math.sqrt((a.x-x)**2+(a.y-y)**2) < Math.sqrt((b.x-x)**2+(b.y-y)**2) ? a : b);

                target.takeDamage(80, this);
                target.stunned = 90;
                // Lightning bolt effect
                for (let i = 0; i < 20; i++) {
                    particles.push({ x: target.x, y: target.y - 150 + i * 8,
                        vx: (Math.random() - 0.5) * 3, vy: 5,
                        life: 15, color: '#ffff00', size: 8 });
                }
                hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 80, color: '#ffff00' });
            }

            // SPELL 4: Meteor Shower - multiple falling projectiles
            spellMeteorShower(x, y) {
                for (let m = 0; m < 8; m++) {
                    setTimeout(() => {
                        const mx = x + (Math.random() - 0.5) * 200;
                        const my = y + (Math.random() - 0.5) * 200;
                        projectiles.push({
                            x: mx, y: my - 200, vx: 0, vy: 12,
                            radius: 15, damage: 30, owner: this, type: 'meteor', life: 60
                        });
                    }, m * 150);
                }
            }

            // SPELL 5: Arcane Missiles - homing projectiles
            spellArcaneMissiles() {
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    setTimeout(() => {
                        projectiles.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(angle) * 6, vy: Math.sin(angle) * 6,
                            radius: 8, damage: 20, owner: this, type: 'arcane_missile', life: 120,
                            homing: true, homingStrength: 0.15
                        });
                    }, i * 100);
                }
            }

            // SPELL 6: Gravity Well - pulls enemies
            spellGravityWell(x, y) {
                for (let wave = 0; wave < 15; wave++) {
                    setTimeout(() => {
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dx = x - b.x;
                                const dy = y - b.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 200 && dist > 0) {
                                    b.vx += (dx / dist) * 5;
                                    b.vy += (dy / dist) * 5;
                                    b.takeDamage(5, this);
                                }
                            }
                        });
                    }, wave * 80);
                }
                hitEffects.push({ x: x, y: y, radius: 10, maxRadius: 200, color: '#4b0082' });
            }

            // SPELL 7: Time Warp - slows enemies
            spellTimeWarp(x, y) {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - x) ** 2 + (b.y - y) ** 2);
                        if (dist < 180) {
                            b.timeWarped = 240;
                            b.vx *= 0.3;
                            b.vy *= 0.3;
                            for (let i = 0; i < 10; i++) {
                                particles.push({ x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                                    life: 50, color: '#ffa500', size: 5 });
                            }
                        }
                    }
                });
            }

            // SPELL 8: Healing Circle - heals allies
            spellHealingCircle(x, y) {
                balls.forEach(b => {
                    if ((b === this || this.isTeammate(b)) && b.alive) {
                        const dist = Math.sqrt((b.x - x) ** 2 + (b.y - y) ** 2);
                        if (dist < 150) {
                            b.health = Math.min(b.maxHealth, b.health + 80);
                            for (let i = 0; i < 15; i++) {
                                particles.push({ x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 3, vy: -2 - Math.random() * 2,
                                    life: 40, color: '#00ff00', size: 6 });
                            }
                        }
                    }
                });
                hitEffects.push({ x: x, y: y, radius: 10, maxRadius: 150, color: '#00ff00' });
            }

            // SPELL 9: Shield Dome - protects caster
            spellShieldDome() {
                this.isInvulnerable = true;
                this.powerupShield = 180;
                hitEffects.push({ x: this.x, y: this.y, radius: 30, maxRadius: 60, color: '#00ffff' });
            }

            // SPELL 10: Poison Cloud - DoT damage
            spellPoisonCloud(x, y) {
                // Create poison zone
                if (!window.floorTraps) window.floorTraps = [];
                window.floorTraps.push({
                    x: x, y: y, radius: 100, type: 'poison_cloud', owner: this,
                    life: 300, damage: 8, color: 'rgba(0, 255, 0, 0.3)'
                });
            }

            // SPELL 11: Chain Lightning - bounces between enemies
            spellChainLightning() {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;

                let current = targets[0];
                let hit = [current];
                let damage = 50;

                for (let bounce = 0; bounce < Math.min(5, targets.length); bounce++) {
                    setTimeout(() => {
                        if (current && current.alive) {
                            current.takeDamage(damage, this);
                            hitEffects.push({ x: current.x, y: current.y, radius: 5, maxRadius: 40, color: '#ffff00' });
                            // Find next target
                            const next = targets.find(t => t.alive && !hit.includes(t));
                            if (next) {
                                // Lightning arc effect
                                for (let i = 0; i < 10; i++) {
                                    const t = i / 10;
                                    particles.push({
                                        x: current.x + (next.x - current.x) * t,
                                        y: current.y + (next.y - current.y) * t,
                                        vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                                        life: 15, color: '#ffff00', size: 4 });
                                }
                                hit.push(next);
                                current = next;
                            }
                            damage *= 0.8;
                        }
                    }, bounce * 150);
                }
            }

            // SPELL 12: Earthquake - stun + damage
            spellEarthquake(x, y) {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - x) ** 2 + (b.y - y) ** 2);
                        if (dist < 200) {
                            b.takeDamage(40, this);
                            b.stunned = 120;
                            // Shake effect
                            b.vx += (Math.random() - 0.5) * 15;
                            b.vy += (Math.random() - 0.5) * 15;
                        }
                    }
                });
                for (let i = 0; i < 30; i++) {
                    particles.push({ x: x + (Math.random() - 0.5) * 200, y: y + (Math.random() - 0.5) * 200,
                        vx: (Math.random() - 0.5) * 8, vy: -Math.random() * 5,
                        life: 30, color: '#8b4513', size: 10 });
                }
            }

            // SPELL 13: Tornado - pushes enemies away
            spellTornado(x, y) {
                for (let spin = 0; spin < 20; spin++) {
                    setTimeout(() => {
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dx = b.x - x;
                                const dy = b.y - y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < 150 && dist > 0) {
                                    // Spin and push
                                    const perpX = -dy / dist;
                                    const perpY = dx / dist;
                                    b.vx += perpX * 4 + (dx / dist) * 2;
                                    b.vy += perpY * 4 + (dy / dist) * 2;
                                    b.takeDamage(3, this);
                                }
                            }
                        });
                        // Tornado particles
                        const angle = spin * 0.5;
                        for (let i = 0; i < 5; i++) {
                            particles.push({ x: x + Math.cos(angle + i) * 30, y: y + Math.sin(angle + i) * 30,
                                vx: Math.cos(angle) * 3, vy: -3,
                                life: 20, color: '#87ceeb', size: 6 });
                        }
                    }, spin * 50);
                }
            }

            // SPELL 14: Mana Burn - sets enemy cooldowns
            spellManaBurn() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.abilityCooldown = 999;
                        b.silenced = 180;
                        b.takeDamage(30, this);
                        for (let i = 0; i < 10; i++) {
                            particles.push({ x: b.x, y: b.y,
                                vx: (Math.random() - 0.5) * 4, vy: -2,
                                life: 30, color: '#0000ff', size: 5 });
                        }
                    }
                });
            }

            // SPELL 15: Mirror Image - creates decoy
            spellMirrorImage() {
                // Create visual decoy effect around caster
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const decoyX = this.x + Math.cos(angle) * 50;
                    const decoyY = this.y + Math.sin(angle) * 50;
                    // Spawn decoy particles that look like the caster
                    for (let p = 0; p < 20; p++) {
                        particles.push({ x: decoyX, y: decoyY,
                            vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                            life: 120, color: '#9932cc', size: 15 });
                    }
                }
                // Brief invulnerability
                this.isInvulnerable = true;
                this.powerupShield = 60;
            }

            // SPELL 16: Teleport - random reposition
            spellTeleport() {
                const oldX = this.x;
                const oldY = this.y;
                // Teleport to random position in arena
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 200;
                this.x = centerX + Math.cos(angle) * dist;
                this.y = centerY + Math.sin(angle) * dist;
                // Effect at old position
                for (let i = 0; i < 20; i++) {
                    particles.push({ x: oldX, y: oldY,
                        vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                        life: 30, color: '#9932cc', size: 8 });
                }
                // Effect at new position
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 50, color: '#9932cc' });
            }

            // SPELL 17: Summon Elemental - creates fighting projectile swarm
            spellSummonElemental() {
                const elements = ['fire', 'ice', 'lightning', 'earth'];
                const element = elements[Math.floor(Math.random() * elements.length)];
                const colors = { fire: '#ff4400', ice: '#00ffff', lightning: '#ffff00', earth: '#8b4513' };

                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        projectiles.push({
                            x: this.x + Math.cos(angle) * 30,
                            y: this.y + Math.sin(angle) * 30,
                            vx: Math.cos(angle) * 5, vy: Math.sin(angle) * 5,
                            radius: 10, damage: 15, owner: this, type: 'elemental', life: 180,
                            color: colors[element], homing: true, homingStrength: 0.08
                        });
                    }, i * 50);
                }
            }

            // SPELL 18: Curse Circle - debuffs enemies
            spellCurseCircle(x, y) {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - x) ** 2 + (b.y - y) ** 2);
                        if (dist < 180) {
                            b.cursed = 300;
                            b.damageMultiplier = Math.max(0.3, (b.damageMultiplier || 1) * 0.5);
                            b.burning = 120;
                            for (let i = 0; i < 15; i++) {
                                particles.push({ x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                                    life: 40, color: '#4b0082', size: 6 });
                            }
                        }
                    }
                });
                hitEffects.push({ x: x, y: y, radius: 10, maxRadius: 180, color: '#4b0082' });
            }

            // SPELL 19: Blessing Circle - buffs caster
            spellBlessingCircle(x, y) {
                this.damageMultiplier = (this.damageMultiplier || 1) + 0.5;
                this.health = Math.min(this.maxHealth, this.health + 50);
                this.blessed = 300;
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    particles.push({ x: x + Math.cos(angle) * 40, y: y + Math.sin(angle) * 40,
                        vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2,
                        life: 50, color: '#ffd700', size: 7 });
                }
            }

            // SPELL 20: Void Rift - massive damage in small area
            spellVoidRift(x, y) {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;
                const target = targets[Math.floor(Math.random() * targets.length)];

                // Delayed void explosion at target
                setTimeout(() => {
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.sqrt((b.x - target.x) ** 2 + (b.y - target.y) ** 2);
                            if (dist < 60) {
                                b.takeDamage(120, this);
                            }
                        }
                    });
                    hitEffects.push({ x: target.x, y: target.y, radius: 5, maxRadius: 60, color: '#000000' });
                    for (let i = 0; i < 30; i++) {
                        particles.push({ x: target.x, y: target.y,
                            vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
                            life: 25, color: '#4b0082', size: 8 });
                    }
                }, 500);

                // Warning indicator
                hitEffects.push({ x: target.x, y: target.y, radius: 50, maxRadius: 60, color: '#ff0000' });
            }

            // ZOMBIE RESURRECTION
            resurrectZombie() {
                // Find dead balls
                const deadBalls = balls.filter(b => !b.alive);
                if (deadBalls.length === 0) {
                    // No dead balls, cast magic circle instead
                    this.castMagicCircle();
                    return;
                }

                // Resurrect up to 3 dead balls as zombies
                const toResurrect = deadBalls.slice(0, 3);
                this.zombieCount = (this.zombieCount || 0) + toResurrect.length;

                toResurrect.forEach((deadBall, i) => {
                    setTimeout(() => {
                        // Create zombie entity
                        if (!window.zombies) window.zombies = [];
                        window.zombies.push({
                            x: deadBall.x,
                            y: deadBall.y,
                            vx: 0, vy: 0,
                            radius: 20,
                            health: 50,
                            damage: 15,
                            owner: this,
                            color: '#00ff00',
                            originalColor: deadBall.config.color,
                            life: 600 // 10 seconds
                        });

                        // Resurrection effect
                        for (let p = 0; p < 20; p++) {
                            particles.push({ x: deadBall.x, y: deadBall.y,
                                vx: (Math.random() - 0.5) * 5, vy: -3 - Math.random() * 2,
                                life: 40, color: '#00ff00', size: 6 });
                        }
                        hitEffects.push({ x: deadBall.x, y: deadBall.y, radius: 10, maxRadius: 50, color: '#00ff00' });
                    }, i * 300);
                });
            }

            // GRAND DISINTEGRATION - Ultimate when 1v1 with HP advantage
            grandDisintegration(target) {
                this.disintegrationReady = true;

                // Charge up effect
                for (let charge = 0; charge < 20; charge++) {
                    setTimeout(() => {
                        const angle = (charge / 20) * Math.PI * 2;
                        particles.push({ x: this.x + Math.cos(angle) * 80, y: this.y + Math.sin(angle) * 80,
                            vx: -Math.cos(angle) * 4, vy: -Math.sin(angle) * 4,
                            life: 30, color: '#ff0000', size: 8 });
                    }, charge * 50);
                }

                // Massive disintegration beam after charge
                setTimeout(() => {
                    this.disintegrationReady = false;

                    // OBLITERATE the target
                    target.takeDamage(500, this);
                    target.burning = 300;
                    target.stunned = 180;

                    // Massive visual effect
                    hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 200, color: '#ff0000' });
                    hitEffects.push({ x: target.x, y: target.y, radius: 20, maxRadius: 150, color: '#ff8800' });
                    hitEffects.push({ x: target.x, y: target.y, radius: 30, maxRadius: 100, color: '#ffff00' });

                    // Particle explosion
                    for (let i = 0; i < 80; i++) {
                        const angle = (i / 80) * Math.PI * 2;
                        particles.push({ x: target.x, y: target.y,
                            vx: Math.cos(angle) * (5 + Math.random() * 10),
                            vy: Math.sin(angle) * (5 + Math.random() * 10),
                            life: 60, color: ['#ff0000', '#ff8800', '#ffff00', '#ffffff'][i % 4], size: 10 });
                    }

                    // Screen shake effect (damage all nearby slightly)
                    balls.forEach(b => {
                        if (b !== target && b.alive) {
                            b.vx += (Math.random() - 0.5) * 10;
                            b.vy += (Math.random() - 0.5) * 10;
                        }
                    });
                }, 1000);
            }

            // === PARADOXICAL ABILITIES (GODLY) ===
            useParadoxicalAbility() {
                // Initialize phase if not set
                if (!this.paradoxPhase) {
                    this.paradoxPhase = 1;
                    this.lastPhase = 1;
                }

                // Calculate what phase we SHOULD be at based on damage taken
                // Phase transitions based on total damage taken, not current HP
                if (!this.phaseHealthThresholds) {
                    this.phaseHealthThresholds = {
                        phase2: this.maxHealth * 0.66,  // Transition at 66% of max HP damage taken
                        phase3: this.maxHealth * 1.32   // Transition at 132% of max HP damage taken (after phase 2 heal)
                    };
                    this.totalDamageTaken = 0;
                }

                // Determine current phase based on cumulative damage
                let newPhase = 1;
                if (this.totalDamageTaken >= this.phaseHealthThresholds.phase3) {
                    newPhase = 3;
                } else if (this.totalDamageTaken >= this.phaseHealthThresholds.phase2) {
                    newPhase = 2;
                }

                // Check for phase transition - FULL HEAL on phase up!
                if (newPhase > this.paradoxPhase) {
                    this.paradoxPhase = newPhase;
                    this.health = this.maxHealth;  // FULL HEAL!

                    // Epic phase transition effect
                    this.paradoxPhaseTransition(newPhase);

                    console.log(`PARADOXICAL PHASE ${newPhase}! Full heal triggered!`);
                }

                // Check for ultimate condition (Phase 3 + less than 15% HP + enemies exist)
                const hpPercent = this.health / this.maxHealth;
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (this.paradoxPhase === 3 && hpPercent < 0.15 && enemies.length > 0 && !this.ultimateUsed) {
                    this.paradoxCollapse();
                    return;
                }

                // Cast phase-appropriate ability
                this.castParadoxAbility();
            }

            paradoxPhaseTransition(phase) {
                // Massive visual effect for phase transition
                const colors = {
                    2: ['#ff00ff', '#8800ff'],
                    3: ['#ffff00', '#ff8800']
                };
                const phaseColors = colors[phase] || ['#00ffff', '#0088ff'];

                // Expanding ring effect
                for (let ring = 0; ring < 3; ring++) {
                    setTimeout(() => {
                        for (let i = 0; i < 40; i++) {
                            const angle = (i / 40) * Math.PI * 2;
                            particles.push({
                                x: this.x,
                                y: this.y,
                                vx: Math.cos(angle) * (8 + ring * 3),
                                vy: Math.sin(angle) * (8 + ring * 3),
                                life: 60,
                                color: phaseColors[i % 2],
                                size: 10 - ring * 2
                            });
                        }
                    }, ring * 150);
                }

                // Screen flash effect
                const flash = document.createElement('div');
                flash.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: ${phaseColors[0]}; opacity: 0.5; z-index: 9999;
                    pointer-events: none; animation: flashFade 0.5s ease-out forwards;
                `;
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 500);

                // Phase announcement
                const announce = document.createElement('div');
                announce.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    font-size: 60px; font-weight: bold; color: ${phaseColors[0]};
                    text-shadow: 0 0 20px ${phaseColors[1]}, 0 0 40px ${phaseColors[0]};
                    z-index: 10000; pointer-events: none;
                    animation: phaseAnnounce 1.5s ease-out forwards;
                `;
                const phaseNames = { 2: 'FRACTAL MASTER', 3: 'PARADOX INCARNATE' };
                announce.innerHTML = `PHASE ${phase}<br><span style="font-size: 30px;">${phaseNames[phase]}</span>`;
                document.body.appendChild(announce);
                setTimeout(() => announce.remove(), 1500);
            }

            castParadoxAbility() {
                const phase = this.paradoxPhase;
                let abilityIndex;

                if (phase === 1) {
                    // Phase 1: Reality Warper (5 abilities)
                    abilityIndex = Math.floor(Math.random() * 5);
                    switch(abilityIndex) {
                        case 0: this.timeLoop(); break;
                        case 1: this.infiniteRegression(); break;
                        case 2: this.schrodingersStrike(); break;
                        case 3: this.bootstrapParadox(); break;
                        case 4: this.grandfatherParadox(); break;
                    }
                } else if (phase === 2) {
                    // Phase 2: Fractal Master (5 abilities + can use phase 1)
                    abilityIndex = Math.floor(Math.random() * 10);
                    if (abilityIndex < 5) {
                        switch(abilityIndex) {
                            case 0: this.fractalStorm(); break;
                            case 1: this.mandelbrotMaze(); break;
                            case 2: this.zenosParadox(); break;
                            case 3: this.liarsParadox(); break;
                            case 4: this.twinParadox(); break;
                        }
                    } else {
                        this.castParadoxAbility1(abilityIndex - 5);
                    }
                } else {
                    // Phase 3: Paradox Incarnate (5 abilities + all previous)
                    abilityIndex = Math.floor(Math.random() * 15);
                    if (abilityIndex < 5) {
                        switch(abilityIndex) {
                            case 0: this.omnipotenceParadox(); break;
                            case 1: this.fermiParadox(); break;
                            case 2: this.recursionBlast(); break;
                            case 3: this.mobiusStrike(); break;
                            case 4: this.singularity(); break;
                        }
                    } else if (abilityIndex < 10) {
                        this.castParadoxAbility2(abilityIndex - 5);
                    } else {
                        this.castParadoxAbility1(abilityIndex - 10);
                    }
                }
            }

            castParadoxAbility1(index) {
                switch(index) {
                    case 0: this.timeLoop(); break;
                    case 1: this.infiniteRegression(); break;
                    case 2: this.schrodingersStrike(); break;
                    case 3: this.bootstrapParadox(); break;
                    case 4: this.grandfatherParadox(); break;
                }
            }

            castParadoxAbility2(index) {
                switch(index) {
                    case 0: this.fractalStorm(); break;
                    case 1: this.mandelbrotMaze(); break;
                    case 2: this.zenosParadox(); break;
                    case 3: this.liarsParadox(); break;
                    case 4: this.twinParadox(); break;
                }
            }

            // Visual effect for paradox abilities
            paradoxVisualEffect(color1, color2) {
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 40,
                        y: this.y + Math.sin(angle) * 40,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 50,
                        color: i % 2 === 0 ? color1 : color2,
                        size: 6
                    });
                }
            }

            // === PHASE 1: REALITY WARPER ===

            // 1. Time Loop - Trap enemy in repeating damage
            timeLoop() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;
                const target = enemies[Math.floor(Math.random() * enemies.length)];

                target.timeLooped = 180;
                const loopDamage = 15;

                for (let loop = 0; loop < 6; loop++) {
                    setTimeout(() => {
                        if (target.alive) {
                            target.takeDamage(loopDamage, this);
                            // Rewind effect
                            hitEffects.push({ x: target.x, y: target.y, radius: 5, maxRadius: 40, color: '#00ffff' });
                            particles.push({ x: target.x, y: target.y, vx: 0, vy: 0, life: 20, color: '#00ffff', size: 15 });
                        }
                    }, loop * 300);
                }

                this.paradoxVisualEffect('#00ffff', '#0088ff');
            }

            // 2. Infinite Regression - Damage that echoes multiple times
            infiniteRegression() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;

                enemies.forEach(enemy => {
                    let damage = 40;
                    for (let echo = 0; echo < 8; echo++) {
                        setTimeout(() => {
                            if (enemy.alive) {
                                enemy.takeDamage(damage, this);
                                // Shrinking echo effect
                                const size = 50 - echo * 5;
                                hitEffects.push({ x: enemy.x, y: enemy.y, radius: size/2, maxRadius: size, color: '#ff00ff' });
                            }
                        }, echo * 150);
                        damage *= 0.7; // Each echo is weaker
                    }
                });

                this.paradoxVisualEffect('#ff00ff', '#8800ff');
            }

            // 3. SchrÃ¶dinger's Strike - 50% massive damage or heal enemy
            schrodingersStrike() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;
                const target = enemies[Math.floor(Math.random() * enemies.length)];

                // Superposition effect
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        x: target.x + (Math.random() - 0.5) * 60,
                        y: target.y + (Math.random() - 0.5) * 60,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 40,
                        color: Math.random() > 0.5 ? '#ff0000' : '#00ff00',
                        size: 8
                    });
                }

                setTimeout(() => {
                    if (Math.random() < 0.5) {
                        // COLLAPSE TO DAMAGE
                        target.takeDamage(150, this);
                        hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 100, color: '#ff0000' });
                    } else {
                        // COLLAPSE TO HEAL (backfire!)
                        target.health = Math.min(target.maxHealth, target.health + 50);
                        hitEffects.push({ x: target.x, y: target.y, radius: 10, maxRadius: 100, color: '#00ff00' });
                    }
                }, 500);
            }

            // 4. Bootstrap Paradox - Steal future damage from enemy
            bootstrapParadox() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;
                const target = enemies[Math.floor(Math.random() * enemies.length)];

                // Steal 20% of enemy's current health as damage to them, heal to self
                const stolenHP = target.health * 0.2;
                target.takeDamage(stolenHP, this);
                this.health = Math.min(this.maxHealth, this.health + stolenHP);

                // Time theft visual
                for (let i = 0; i < 15; i++) {
                    const t = i / 15;
                    particles.push({
                        x: target.x + (this.x - target.x) * t,
                        y: target.y + (this.y - target.y) * t,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 30,
                        color: '#ffff00',
                        size: 6
                    });
                }

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 60, color: '#00ff00' });
            }

            // 5. Grandfather Paradox - Erase enemy's recent healing
            grandfatherParadox() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        // Set their HP to 70% of current
                        const erased = b.health * 0.3;
                        b.health *= 0.7;
                        b.stunned = 60;

                        // Erasure effect
                        for (let i = 0; i < 20; i++) {
                            particles.push({
                                x: b.x + (Math.random() - 0.5) * 40,
                                y: b.y + (Math.random() - 0.5) * 40,
                                vx: (Math.random() - 0.5) * 5,
                                vy: -2,
                                life: 40,
                                color: '#ffffff',
                                size: 5
                            });
                        }
                    }
                });

                hitEffects.push({ x: this.x, y: this.y, radius: 20, maxRadius: 200, color: '#ffffff' });
            }

            // === PHASE 2: FRACTAL MASTER ===

            // 6. Fractal Storm - Recursive projectile pattern
            fractalStorm() {
                const spawnFractal = (x, y, angle, depth, delay) => {
                    if (depth <= 0) return;

                    setTimeout(() => {
                        projectiles.push({
                            x: x, y: y,
                            vx: Math.cos(angle) * 8,
                            vy: Math.sin(angle) * 8,
                            radius: 6 + depth * 2,
                            damage: 10 + depth * 5,
                            owner: this,
                            type: 'fractal',
                            life: 60,
                            color: depth === 3 ? '#ff00ff' : depth === 2 ? '#00ffff' : '#ffff00'
                        });

                        // Spawn children
                        if (depth > 1) {
                            spawnFractal(x, y, angle - 0.5, depth - 1, 100);
                            spawnFractal(x, y, angle + 0.5, depth - 1, 100);
                        }
                    }, delay);
                };

                // Spawn 3 main branches
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2 + this.angle;
                    spawnFractal(this.x, this.y, angle, 3, i * 100);
                }

                this.paradoxVisualEffect('#ff00ff', '#00ffff');
            }

            // 7. Mandelbrot Maze - Trap enemies in fractal prison
            mandelbrotMaze() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;

                enemies.forEach(enemy => {
                    enemy.mandelbrotTrapped = 180;
                    enemy.stunned = 120;

                    // Create fractal cage around enemy
                    for (let ring = 0; ring < 3; ring++) {
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const dist = 30 + ring * 15;
                            particles.push({
                                x: enemy.x + Math.cos(angle) * dist,
                                y: enemy.y + Math.sin(angle) * dist,
                                vx: 0, vy: 0,
                                life: 120,
                                color: ring === 0 ? '#ff00ff' : ring === 1 ? '#00ffff' : '#ffff00',
                                size: 8
                            });
                        }
                    }
                });
            }

            // 8. Zeno's Paradox - Enemy can never reach you
            zenosParadox() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                enemies.forEach(enemy => {
                    // Push enemy away continuously
                    for (let push = 0; push < 20; push++) {
                        setTimeout(() => {
                            if (enemy.alive) {
                                const dx = enemy.x - this.x;
                                const dy = enemy.y - this.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0 && dist < 200) {
                                    enemy.vx += (dx / dist) * 3;
                                    enemy.vy += (dy / dist) * 3;
                                }
                            }
                        }, push * 50);
                    }
                    enemy.takeDamage(20, this);
                });

                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#00ffff' });
            }

            // 9. Liar's Paradox - Confuse enemies (reverse their movement)
            liarsParadox() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.confused = 240;
                        b.vx = -b.vx * 1.5;
                        b.vy = -b.vy * 1.5;

                        // Confusion particles
                        for (let i = 0; i < 15; i++) {
                            particles.push({
                                x: b.x, y: b.y - 20,
                                vx: (Math.random() - 0.5) * 3,
                                vy: -2,
                                life: 60,
                                color: '#ffff00',
                                size: 10
                            });
                        }
                    }
                });
            }

            // 10. Twin Paradox - Create time-dilated clone
            twinParadox() {
                // Create a phantom clone that attacks
                if (!window.phantomClones) window.phantomClones = [];

                window.phantomClones.push({
                    x: this.x + (Math.random() - 0.5) * 100,
                    y: this.y + (Math.random() - 0.5) * 100,
                    owner: this,
                    life: 300,
                    attackTimer: 0
                });

                this.paradoxVisualEffect('#00ffff', '#ffffff');
            }

            // === PHASE 3: PARADOX INCARNATE ===

            // 11. Omnipotence Paradox - Briefly become unstoppable
            omnipotenceParadox() {
                this.isInvulnerable = true;
                this.powerupShield = 180;
                this.damageMultiplier = (this.damageMultiplier || 1) * 2;

                // Massive power aura
                for (let wave = 0; wave < 5; wave++) {
                    setTimeout(() => {
                        hitEffects.push({ x: this.x, y: this.y, radius: wave * 30, maxRadius: wave * 30 + 50, color: '#ffff00' });
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2;
                            particles.push({
                                x: this.x + Math.cos(angle) * 50,
                                y: this.y + Math.sin(angle) * 50,
                                vx: Math.cos(angle) * 5,
                                vy: Math.sin(angle) * 5,
                                life: 40,
                                color: '#ffff00',
                                size: 10
                            });
                        }
                    }, wave * 100);
                }

                // Reset multiplier after duration
                setTimeout(() => {
                    this.damageMultiplier = Math.max(1, (this.damageMultiplier || 2) / 2);
                }, 3000);
            }

            // 12. Fermi Paradox - Make enemies "disappear" temporarily
            fermiParadox() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.fermiHidden = 180;
                        b.stunned = 180;
                        b.takeDamage(50, this);

                        // Disappearance effect
                        for (let i = 0; i < 30; i++) {
                            particles.push({
                                x: b.x + (Math.random() - 0.5) * 40,
                                y: b.y + (Math.random() - 0.5) * 40,
                                vx: (Math.random() - 0.5) * 8,
                                vy: (Math.random() - 0.5) * 8,
                                life: 60,
                                color: '#000000',
                                size: 12
                            });
                        }
                    }
                });

                hitEffects.push({ x: this.x, y: this.y, radius: 20, maxRadius: 300, color: '#000000' });
            }

            // 13. Recursion Blast - Damage that multiplies
            recursionBlast() {
                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;

                let damage = 10;
                for (let iteration = 0; iteration < 10; iteration++) {
                    setTimeout(() => {
                        enemies.forEach(enemy => {
                            if (enemy.alive) {
                                enemy.takeDamage(damage, this);
                                particles.push({
                                    x: enemy.x, y: enemy.y,
                                    vx: (Math.random() - 0.5) * 5,
                                    vy: (Math.random() - 0.5) * 5,
                                    life: 20,
                                    color: '#ff00ff',
                                    size: 5 + iteration
                                });
                            }
                        });
                        damage *= 1.3; // Each hit is stronger
                    }, iteration * 100);
                }
            }

            // 14. MÃ¶bius Strike - Attack that loops back
            mobiusStrike() {
                // Fire projectile that returns
                const angle = this.angle;
                projectiles.push({
                    x: this.x, y: this.y,
                    vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10,
                    radius: 15, damage: 60, owner: this, type: 'mobius', life: 120,
                    returning: false, startX: this.x, startY: this.y
                });

                // Fire opposite direction too
                projectiles.push({
                    x: this.x, y: this.y,
                    vx: Math.cos(angle + Math.PI) * 10, vy: Math.sin(angle + Math.PI) * 10,
                    radius: 15, damage: 60, owner: this, type: 'mobius', life: 120,
                    returning: false, startX: this.x, startY: this.y
                });

                this.paradoxVisualEffect('#00ffff', '#ff00ff');
            }

            // 15. Singularity - Pull everything to a point
            singularity() {
                const singularityX = this.x;
                const singularityY = this.y;

                // Create black hole effect
                for (let pulse = 0; pulse < 30; pulse++) {
                    setTimeout(() => {
                        balls.forEach(b => {
                            if (b !== this && b.alive) {
                                const dx = singularityX - b.x;
                                const dy = singularityY - b.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 0) {
                                    const pull = 150 / (dist + 10);
                                    b.vx += (dx / dist) * pull;
                                    b.vy += (dy / dist) * pull;
                                    if (dist < 50) {
                                        b.takeDamage(5, this);
                                    }
                                }
                            }
                        });

                        // Visual effect
                        for (let i = 0; i < 10; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 100 + Math.random() * 100;
                            particles.push({
                                x: singularityX + Math.cos(angle) * dist,
                                y: singularityY + Math.sin(angle) * dist,
                                vx: -Math.cos(angle) * 5,
                                vy: -Math.sin(angle) * 5,
                                life: 30,
                                color: '#000000',
                                size: 4
                            });
                        }
                    }, pulse * 50);
                }

                hitEffects.push({ x: singularityX, y: singularityY, radius: 5, maxRadius: 30, color: '#000000' });
            }

            // === ULTIMATE: PARADOX COLLAPSE ===
            // === NEW WEAPON ABILITIES ===

            // BOW - Arrow Volley
            useBowAbility() {
                const spread = [-0.4, -0.2, 0, 0.2, 0.4];
                const target = this.findNearestEnemy();
                if (!target) return;

                const baseAngle = Math.atan2(target.y - this.y, target.x - this.x);

                spread.forEach((offset, i) => {
                    setTimeout(() => {
                        const angle = baseAngle + offset;
                        projectiles.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(angle) * 12,
                            vy: Math.sin(angle) * 12,
                            damage: 8, owner: this,
                            type: 'arrow', life: 60,
                            color: '#8b4513'
                        });
                    }, i * 50);
                });
            }

            // LONGSWORD - Sweeping Strike
            useLongswordAbility() {
                const range = 80;
                const damage = 20;

                // Hit all enemies in range
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < range) {
                            b.takeDamage(damage, this);
                            // Knockback
                            const angle = Math.atan2(b.y - this.y, b.x - this.x);
                            b.vx += Math.cos(angle) * 8;
                            b.vy += Math.sin(angle) * 8;
                        }
                    }
                });

                // Visual sweep arc
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({
                        x: this.x + Math.cos(angle) * 60,
                        y: this.y + Math.sin(angle) * 60,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2,
                        life: 20, color: '#c0c0c0', size: 4
                    });
                }
            }

            // CHAINSAW - Rev Up
            useChainsawAbility() {
                this.chainsawActive = 150; // 2.5 seconds

                // Rapid damage tick
                const sawInterval = setInterval(() => {
                    if (!this.chainsawActive || this.chainsawActive <= 0 || !this.alive) {
                        clearInterval(sawInterval);
                        return;
                    }

                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.hypot(b.x - this.x, b.y - this.y);
                            if (dist < 50) {
                                b.takeDamage(5, this);
                                b.bleeding = 120; // Bleed for 2 seconds
                                // Sparks
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 15, color: '#ff4500', size: 3
                                });
                            }
                        }
                    });
                }, 100);
            }

            // CROSSBOW - Power Shot
            useCrossbowAbility() {
                const target = this.findNearestEnemy();
                if (!target) return;

                const angle = Math.atan2(target.y - this.y, target.x - this.x);

                projectiles.push({
                    x: this.x, y: this.y,
                    vx: Math.cos(angle) * 18,
                    vy: Math.sin(angle) * 18,
                    damage: 35, owner: this,
                    type: 'bolt', life: 80,
                    piercing: true,
                    color: '#654321'
                });

                // Recoil
                this.vx -= Math.cos(angle) * 3;
                this.vy -= Math.sin(angle) * 3;
            }

            // FLAIL - Whirlwind
            useFlailAbility() {
                this.whirlwindActive = 120; // 2 seconds
                const originalSpeed = Math.hypot(this.vx, this.vy);

                const spinInterval = setInterval(() => {
                    if (!this.whirlwindActive || this.whirlwindActive <= 0 || !this.alive) {
                        clearInterval(spinInterval);
                        return;
                    }

                    // Damage nearby enemies
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.hypot(b.x - this.x, b.y - this.y);
                            if (dist < 70) {
                                b.takeDamage(4, this);
                                // Push away
                                const angle = Math.atan2(b.y - this.y, b.x - this.x);
                                b.vx += Math.cos(angle) * 3;
                                b.vy += Math.sin(angle) * 3;
                            }
                        }
                    });

                    // Spin particles
                    const time = Date.now() / 50;
                    for (let i = 0; i < 4; i++) {
                        const angle = time + (i / 4) * Math.PI * 2;
                        particles.push({
                            x: this.x + Math.cos(angle) * 50,
                            y: this.y + Math.sin(angle) * 50,
                            vx: 0, vy: 0,
                            life: 10, color: '#808080', size: 5
                        });
                    }
                }, 50);
            }

            // PICKAXE - Shatter
            usePickaxeAbility() {
                const target = this.findNearestEnemy();
                if (!target) return;

                const dist = Math.hypot(target.x - this.x, target.y - this.y);
                if (dist > 60) return; // Must be close

                target.takeDamage(25, this);
                target.stunned = 90; // 1.5 second stun

                // Shatter particles
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: target.x, y: target.y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 30, color: '#4169e1', size: 4
                    });
                }

                // Ground crack effect
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    particles.push({
                        x: target.x + Math.cos(angle) * 20,
                        y: target.y + Math.sin(angle) * 20,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2,
                        life: 40, color: '#333', size: 3
                    });
                }
            }

            // WHIP - Lash & Pull
            useWhipAbility() {
                const range = 120;
                let target = null;
                let closestDist = range;

                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = b;
                        }
                    }
                });

                if (!target) return;

                // Damage and pull
                target.takeDamage(12, this);
                const angle = Math.atan2(this.y - target.y, this.x - target.x);
                target.vx = Math.cos(angle) * 15;
                target.vy = Math.sin(angle) * 15;

                // Whip trail
                for (let i = 0; i < 10; i++) {
                    const t = i / 10;
                    particles.push({
                        x: this.x + (target.x - this.x) * t,
                        y: this.y + (target.y - this.y) * t,
                        vx: 0, vy: 0,
                        life: 20 - i, color: '#8b0000', size: 3
                    });
                }
            }

            // SLINGSHOT - Rock Barrage
            useSlingshotAbility() {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        projectiles.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(angle) * 10,
                            vy: Math.sin(angle) * 10,
                            damage: 10, owner: this,
                            type: 'rock', life: 120,
                            bouncy: true,
                            color: '#808080'
                        });
                    }, i * 150);
                }
            }

            // BOOMERANG - Curved Throw
            useBoomerangAbility() {
                const target = this.findNearestEnemy();
                const angle = target ? Math.atan2(target.y - this.y, target.x - this.x) : Math.random() * Math.PI * 2;

                projectiles.push({
                    x: this.x, y: this.y,
                    vx: Math.cos(angle) * 10,
                    vy: Math.sin(angle) * 10,
                    damage: 18, owner: this,
                    type: 'boomerang', life: 120,
                    returning: false,
                    startX: this.x, startY: this.y,
                    color: '#daa520'
                });
            }

            // TORCH - Ignite
            useTorchAbility() {
                const range = 80;
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < range) {
                            b.burning = 180; // 3 seconds of burn
                            b.burnOwner = this;

                            // Fire burst
                            for (let i = 0; i < 10; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 4,
                                    vy: -Math.random() * 4,
                                    life: 30, color: i % 2 ? '#ff6600' : '#ffff00', size: 5
                                });
                            }
                        }
                    }
                });
            }

            // THE ETERNAL - Form-based ability (GODLY)
            useEternalAbility() {
                const form = this.eternalForm || 1;

                switch(form) {
                    case 1: // SEED - Weak pulse
                        particles.push({
                            x: this.x, y: this.y, vx: 0, vy: 0,
                            life: 20, color: '#888', size: 30, type: 'ring'
                        });
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dist = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dist < 80) {
                                    b.takeDamage(3, this);
                                }
                            }
                        });
                        break;

                    case 2: // SPARK - Chain lightning
                        let targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                        let lastPos = {x: this.x, y: this.y};
                        targets.sort((a,b) => Math.hypot(a.x-this.x, a.y-this.y) - Math.hypot(b.x-this.x, b.y-this.y));
                        targets.slice(0, 4).forEach(target => {
                            const dist = Math.hypot(target.x - lastPos.x, target.y - lastPos.y);
                            if (dist < 300) {
                                for (let i = 0; i < 10; i++) {
                                    particles.push({
                                        x: lastPos.x + (target.x - lastPos.x) * i / 10,
                                        y: lastPos.y + (target.y - lastPos.y) * i / 10 + (Math.random()-0.5) * 20,
                                        vx: 0, vy: 0, life: 15, color: '#00ffff', size: 4
                                    });
                                }
                                target.takeDamage(12, this);
                                target.stunned = 30;
                                lastPos = {x: target.x, y: target.y};
                            }
                        });
                        break;

                    case 3: // FLAME - Fire nova
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                            for (let r = 0; r < 150; r += 20) {
                                particles.push({
                                    x: this.x + Math.cos(angle) * r,
                                    y: this.y + Math.sin(angle) * r,
                                    vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
                                    life: 30, color: r < 75 ? '#ffff00' : '#ff4400', size: 8
                                });
                            }
                        }
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dist = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dist < 180) {
                                    b.takeDamage(25, this);
                                    b.burning = 180;
                                }
                            }
                        });
                        break;

                    case 4: // NOVA - Gravity well
                        balls.forEach(b => {
                            if (b !== this && b.alive) {
                                const dx = this.x - b.x;
                                const dy = this.y - b.y;
                                const dist = Math.hypot(dx, dy);
                                if (dist < 250 && dist > 30) {
                                    const force = 8 / dist;
                                    b.vx += dx * force;
                                    b.vy += dy * force;
                                    if (!this.isTeammate(b)) {
                                        b.takeDamage(15, this);
                                    }
                                }
                            }
                        });
                        for (let i = 0; i < 30; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = 50 + Math.random() * 200;
                            particles.push({
                                x: this.x + Math.cos(angle) * dist,
                                y: this.y + Math.sin(angle) * dist,
                                vx: -Math.cos(angle) * 5, vy: -Math.sin(angle) * 5,
                                life: 40, color: '#aa00ff', size: 5
                            });
                        }
                        break;

                    case 5: // ETERNAL - MEGA LASER BARRAGE
                        this.firingEternalLaser = true;
                        this.laserAngle = 0;
                        this.laserDuration = 180;
                        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                            projectiles.push({
                                x: this.x, y: this.y,
                                vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15,
                                damage: 40, owner: this, size: 12,
                                color: '#ffd700', trail: true, piercing: true,
                                life: 120
                            });
                        }
                        break;
                }
            }

            // LIGHT YAGAMI - Death Note (SECRET)
            useLightYagamiAbility() {
                if (this.writingDeathNote) return; // Already writing

                const enemies = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (enemies.length === 0) return;

                // Select random target
                this.deathNoteTarget = enemies[Math.floor(Math.random() * enemies.length)];
                this.writingDeathNote = true;
                this.deathNoteCountdown = 300; // 5 seconds

                // Mark target
                this.deathNoteTarget.markedForDeath = true;

                console.log('Light Yagami is writing...', this.deathNoteTarget.config?.name);
            }

            // Dodge ability - called in update
            lightYagamiDodge() {
                if (this.weapon?.id !== 'lightyagami') return;
                if (this.dodgeCooldown > 0) {
                    this.dodgeCooldown--;
                    return;
                }

                // Check for incoming projectiles or nearby enemies
                let shouldDodge = false;
                let dodgeAngle = 0;

                projectiles.forEach(p => {
                    if (p.owner !== this) {
                        const dist = Math.hypot(p.x - this.x, p.y - this.y);
                        if (dist < 60) {
                            shouldDodge = true;
                            dodgeAngle = Math.atan2(this.y - p.y, this.x - p.x);
                        }
                    }
                });

                // Also dodge nearby attacking enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < 50) {
                            shouldDodge = true;
                            dodgeAngle = Math.atan2(this.y - b.y, this.x - b.x);
                        }
                    }
                });

                if (shouldDodge) {
                    // Quick dodge
                    this.vx += Math.cos(dodgeAngle) * 15;
                    this.vy += Math.sin(dodgeAngle) * 15;
                    this.dodgeCooldown = 30; // 0.5 second cooldown

                    // Dodge effect
                    for (let i = 0; i < 8; i++) {
                        particles.push({
                            x: this.x, y: this.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            life: 15, color: '#8b0000', size: 3
                        });
                    }
                }
            }

            paradoxCollapse() {
                this.ultimateUsed = true;
                this.ultimateActive = true;

                // REALITY BREAKS
                // Phase 1: Warning
                hitEffects.push({ x: centerX, y: centerY, radius: 10, maxRadius: arenaRadius, color: '#ff0000' });

                // Phase 2: All enemies take massive damage over time
                for (let wave = 0; wave < 20; wave++) {
                    setTimeout(() => {
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                b.takeDamage(25, this);
                                b.stunned = 30;

                                // Reality tear effect
                                for (let i = 0; i < 5; i++) {
                                    particles.push({
                                        x: b.x + (Math.random() - 0.5) * 50,
                                        y: b.y + (Math.random() - 0.5) * 50,
                                        vx: (Math.random() - 0.5) * 10,
                                        vy: (Math.random() - 0.5) * 10,
                                        life: 30,
                                        color: ['#ff0000', '#00ffff', '#ff00ff', '#ffff00'][Math.floor(Math.random() * 4)],
                                        size: 8
                                    });
                                }
                            }
                        });

                        // Screen-wide effect
                        hitEffects.push({
                            x: centerX, y: centerY,
                            radius: Math.random() * arenaRadius,
                            maxRadius: Math.random() * arenaRadius + 50,
                            color: ['#ff0000', '#00ffff', '#ff00ff'][wave % 3]
                        });
                    }, wave * 100);
                }

                // Phase 3: Final collapse - heal self to full
                setTimeout(() => {
                    this.health = this.maxHealth;
                    this.isInvulnerable = true;
                    this.powerupShield = 120;
                    this.ultimateActive = false;

                    // Rebirth effect
                    for (let i = 0; i < 60; i++) {
                        const angle = (i / 60) * Math.PI * 2;
                        particles.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(angle) * 15,
                            vy: Math.sin(angle) * 15,
                            life: 60,
                            color: '#ffffff',
                            size: 10
                        });
                    }

                    hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 200, color: '#ffffff' });
                }, 2000);
            }

            rejected() {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length > 0) {
                    let nearest = targets.reduce((a, b) => Math.sqrt((a.x-this.x)**2+(a.y-this.y)**2) < Math.sqrt((b.x-this.x)**2+(b.y-this.y)**2) ? a : b);
                    nearest.takeDamage(35, this);
                    for (let i = 0; i < 15; i++) { particles.push({ x: nearest.x, y: nearest.y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 30, color: '#ff0000', size: 6 }); }
                }
            }

            ghosted() {
                this.isInvulnerable = true;
                for (let i = 0; i < 10; i++) { particles.push({ x: this.x + (Math.random() - 0.5) * 30, y: this.y + (Math.random() - 0.5) * 30, vx: 0, vy: -1, life: 40, color: '#999999', size: 8 }); }
            }

            overqualified() {
                this.damageMultiplier = 2.5;
                this.health = Math.min(this.maxHealth, this.health + 30);
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 80, color: '#ffd700' });
            }

            needExperience() {
                const bonusDamage = Math.floor((this.maxHealth - this.health) * 0.5);
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 150) { b.takeDamage(15 + bonusDamage, this); }
                    }
                });
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 4, dist = i * 3;
                    particles.push({ x: this.x + Math.cos(angle) * dist, y: this.y + Math.sin(angle) * dist, vx: Math.cos(angle) * 2, vy: Math.sin(angle) * 2, life: 30, color: '#ff6600', size: 4 });
                }
            }

            // DIO Abilities
            timeStop() {
                // Freeze all other balls in place
                balls.forEach(b => {
                    if (b !== this && b.alive) {
                        b.frozen = 90; // Freeze for duration
                        b.stunned = 90;
                        // Store velocities to restore later
                        if (!b.storedVx) {
                            b.storedVx = b.vx;
                            b.storedVy = b.vy;
                        }
                        b.vx = 0;
                        b.vy = 0;
                        // Time stop particles
                        for (let i = 0; i < 5; i++) {
                            particles.push({ x: b.x + (Math.random() - 0.5) * 40, y: b.y + (Math.random() - 0.5) * 40,
                                vx: 0, vy: 0, life: 60, color: '#ffff00', size: 8 });
                        }
                    }
                });
                // ZA WARUDO effect
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: arenaRadius, color: '#ffd700' });
            }

            throwKnives() {
                // Throw knives in all directions
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    projectiles.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8,
                        radius: 6, damage: 15, owner: this, type: 'knife', life: 60
                    });
                }
                // Knife particles
                for (let i = 0; i < 20; i++) {
                    particles.push({ x: this.x, y: this.y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                        life: 20, color: '#c0c0c0', size: 4 });
                }
            }

            roadRoller() {
                // Massive damage to nearest enemy
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length > 0) {
                    let nearest = targets.reduce((a, b) =>
                        Math.sqrt((a.x-this.x)**2+(a.y-this.y)**2) < Math.sqrt((b.x-this.x)**2+(b.y-this.y)**2) ? a : b);
                    // Jump to target
                    this.x = nearest.x;
                    this.y = nearest.y - 40;
                    // Massive damage
                    nearest.takeDamage(60, this);
                    nearest.stunned = 60;
                    // WRYYY particles
                    for (let i = 0; i < 30; i++) {
                        particles.push({ x: nearest.x, y: nearest.y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12,
                            life: 40, color: i % 2 === 0 ? '#ffcc00' : '#ff6600', size: 8 });
                    }
                    hitEffects.push({ x: nearest.x, y: nearest.y, radius: 10, maxRadius: 120, color: '#ffcc00' });
                }
            }

            mudaMuda() {
                // Rapid hits to all nearby enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 100) {
                            // Multiple rapid hits
                            for (let i = 0; i < 7; i++) {
                                setTimeout(() => {
                                    if (b.alive) {
                                        b.takeDamage(8, this);
                                        particles.push({ x: b.x + (Math.random() - 0.5) * 30, y: b.y + (Math.random() - 0.5) * 30,
                                            vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                                            life: 15, color: '#ffff00', size: 6 });
                                    }
                                }, i * 80);
                            }
                        }
                    }
                });
            }

            // Blackhole Abilities
            singularity() {
                // Pull all enemies toward the black hole
                balls.forEach(b => {
                    if (b !== this && b.alive) {
                        const dx = this.x - b.x;
                        const dy = this.y - b.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 30 && dist < 300) {
                            const force = 200 / dist; // Stronger when closer
                            b.vx += (dx / dist) * force * 0.15;
                            b.vy += (dy / dist) * force * 0.15;
                        }
                    }
                });
                // Pull particles
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 80 + Math.random() * 40;
                    particles.push({ x: this.x + Math.cos(angle) * dist, y: this.y + Math.sin(angle) * dist,
                        vx: -Math.cos(angle) * 3, vy: -Math.sin(angle) * 3,
                        life: 30, color: '#ff00ff', size: 4 });
                }
            }

            eventHorizon() {
                // Trap enemies in a ring, they can't escape
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dx = this.x - b.x;
                        const dy = this.y - b.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 150) {
                            // Slow them down dramatically
                            b.vx *= 0.5;
                            b.vy *= 0.5;
                            // Pull them in slightly
                            b.vx += (dx / dist) * 0.5;
                            b.vy += (dy / dist) * 0.5;
                            // Continuous damage
                            if (Math.random() < 0.1) b.takeDamage(5, this);
                        }
                    }
                });
            }

            hawkingRadiation() {
                // Damage over time to all enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 200) {
                            b.takeDamage(3, this);
                            b.burning = 30;
                            // Radiation particles
                            particles.push({ x: b.x, y: b.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                                life: 20, color: '#00ffff', size: 3 });
                        }
                    }
                });
                // Outward radiation burst
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y, vx: Math.cos(angle) * 5, vy: Math.sin(angle) * 5,
                        life: 40, color: '#00ffff', size: 5 });
                }
            }

            collapse() {
                // Massive burst damage to all enemies
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 180) {
                            const damage = Math.floor(50 * (1 - dist / 180)); // More damage when closer
                            b.takeDamage(damage, this);
                            // Knock them back
                            const dx = b.x - this.x;
                            const dy = b.y - this.y;
                            const knockback = 8;
                            b.vx += (dx / dist) * knockback;
                            b.vy += (dy / dist) * knockback;
                        }
                    }
                });
                // Implosion then explosion effect
                hitEffects.push({ x: this.x, y: this.y, radius: 180, maxRadius: 10, color: '#8800ff' });
                setTimeout(() => {
                    hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 180, color: '#ffffff' });
                }, 200);
                // Massive particles
                for (let i = 0; i < 40; i++) {
                    const angle = (i / 40) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y, vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8,
                        life: 50, color: i % 2 === 0 ? '#8800ff' : '#ffffff', size: 6 });
                }
            }

            shootFireball() {
                const tip = this.getWeaponTip();
                projectiles.push({ x: tip.x, y: tip.y, vx: Math.cos(this.angle) * 6, vy: Math.sin(this.angle) * 6,
                    radius: 12, damage: 25, owner: this, type: 'fireball', life: 120 });
            }

            chainLightning() {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;
                targets.sort((a, b) => {
                    const distA = Math.sqrt((a.x - this.x) ** 2 + (a.y - this.y) ** 2);
                    const distB = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                    return distA - distB;
                });
                let currentPos = { x: this.x, y: this.y };
                for (let i = 0; i < Math.min(3, targets.length); i++) {
                    const target = targets[i];
                    createLightningBolt(currentPos.x, currentPos.y, target.x, target.y);
                    target.takeDamage(15, this);
                    target.stunned = 30;
                    currentPos = { x: target.x, y: target.y };
                }
            }

            solarFlare() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        b.takeDamage(20, this);
                        b.stunned = 45;
                    }
                });
                hitEffects.push({ x: centerX, y: centerY, radius: 10, maxRadius: arenaRadius, color: '#ffff00' });
            }

            shadowStep() {
                const targets = balls.filter(b => b !== this && b.alive && !this.isTeammate(b));
                if (targets.length === 0) return;
                let nearest = targets[0], nearestDist = Infinity;
                targets.forEach(t => {
                    const dist = Math.sqrt((t.x - this.x) ** 2 + (t.y - this.y) ** 2);
                    if (dist < nearestDist) { nearestDist = dist; nearest = t; }
                });
                const angle = Math.atan2(this.y - nearest.y, this.x - nearest.x);
                for (let i = 0; i < 10; i++) {
                    particles.push({ x: this.x, y: this.y, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                        life: 20, color: '#8844ff', size: 5 });
                }
                this.x = nearest.x + Math.cos(angle) * (nearest.radius + this.radius + 10);
                this.y = nearest.y + Math.sin(angle) * (nearest.radius + this.radius + 10);
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                this.damageMultiplier = 2;
            }

            charge() {
                const angle = this.angle;
                this.vx = Math.cos(angle) * 12;
                this.vy = Math.sin(angle) * 12;
                this.damageMultiplier = 2.5;
            }

            groundSlam() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 150) {
                            b.takeDamage(25, this);
                            b.stunned = 60;
                            const angle = Math.atan2(b.y - this.y, b.x - this.x);
                            b.vx += Math.cos(angle) * 3;
                            b.vy += Math.sin(angle) * 3;
                        }
                    }
                });
                hitEffects.push({ x: this.x, y: this.y, radius: 10, maxRadius: 150, color: '#ffcc00' });
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    particles.push({ x: this.x, y: this.y, vx: Math.cos(angle) * 5, vy: Math.sin(angle) * 5,
                        life: 25, color: '#aa8844', size: 6 });
                }
            }

            freezeNearby() {
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.sqrt((b.x - this.x) ** 2 + (b.y - this.y) ** 2);
                        if (dist < 120) {
                            b.frozen = 90;
                            for (let i = 0; i < 8; i++) {
                                particles.push({ x: b.x + (Math.random() - 0.5) * 30, y: b.y + (Math.random() - 0.5) * 30,
                                    vx: (Math.random() - 0.5) * 2, vy: -Math.random() * 2, life: 30, color: '#88ddff', size: 4 });
                            }
                        }
                    }
                });
            }

            isTeammate(other) {
                if (!settings.teamMode) return false;
                return this.team !== 0 && this.team === other.team;
            }

            findNearestEnemy() {
                let nearest = null;
                let nearestDist = Infinity;
                balls.forEach(b => {
                    if (b !== this && b.alive && !this.isTeammate(b)) {
                        const dist = Math.hypot(b.x - this.x, b.y - this.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = b;
                        }
                    }
                });
                return nearest;
            }

            getWeaponTip() {
                const len = this.weapon.length || 40;
                return { x: this.x + Math.cos(this.angle) * (this.radius + len), y: this.y + Math.sin(this.angle) * (this.radius + len) };
            }

            update() {
                if (!this.alive) return;

                // Status effects

                // Light Yagami dodge
                if (this.weapon && this.weapon.id === 'lightyagami') {
                    if (!this.dodgeCooldown) this.dodgeCooldown = 0;
                    if (this.dodgeCooldown > 0) this.dodgeCooldown--;

                    // Check for incoming threats
                    let shouldDodge = false;
                    let dodgeAngle = 0;

                    projectiles.forEach(p => {
                        if (p.owner !== this) {
                            const dist = Math.hypot(p.x - this.x, p.y - this.y);
                            if (dist < 80) {
                                shouldDodge = true;
                                dodgeAngle = Math.atan2(this.y - p.y, this.x - p.x);
                            }
                        }
                    });

                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dist = Math.hypot(b.x - this.x, b.y - this.y);
                            if (dist < 60) {
                                shouldDodge = true;
                                dodgeAngle = Math.atan2(this.y - b.y, this.x - b.x);
                            }
                        }
                    });

                    if (shouldDodge && this.dodgeCooldown <= 0) {
                        this.vx += Math.cos(dodgeAngle) * 12;
                        this.vy += Math.sin(dodgeAngle) * 12;
                        this.dodgeCooldown = 45;
                        for (let i = 0; i < 6; i++) {
                            particles.push({
                                x: this.x, y: this.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 15, color: '#8b0000', size: 3
                            });
                        }
                    }
                }

                // Death Note countdown
                if (this.writingDeathNote && this.deathNoteCountdown > 0) {
                    this.deathNoteCountdown--;

                    // Writing particles
                    if (Math.random() < 0.2) {
                        particles.push({
                            x: this.x + 25, y: this.y,
                            vx: (Math.random() - 0.5) * 2,
                            vy: -Math.random() * 2,
                            life: 20, color: '#ff0000', size: 2
                        });
                    }

                    if (this.deathNoteCountdown <= 0) {
                        // DEATH NOTE COMPLETE - INSTAKILL
                        if (this.deathNoteTarget && this.deathNoteTarget.alive) {
                            const target = this.deathNoteTarget;

                            // Screen flash
                            const flash = document.createElement('div');
                            flash.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#ff0000;opacity:0.7;z-index:9999;pointer-events:none;';
                            document.body.appendChild(flash);
                            setTimeout(() => flash.remove(), 400);

                            // Death text
                            const deathText = document.createElement('div');
                            deathText.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:72px;font-weight:bold;color:#ff0000;text-shadow:0 0 30px #000;z-index:10000;font-family:Times New Roman,serif;pointer-events:none;';
                            deathText.textContent = target.config ? target.config.name : 'DEAD';
                            document.body.appendChild(deathText);
                            setTimeout(() => {
                                deathText.style.transition = 'all 1s';
                                deathText.style.opacity = '0';
                                deathText.style.transform = 'translate(-50%,-50%) scale(2)';
                                setTimeout(() => deathText.remove(), 1000);
                            }, 1500);

                            // Death particles
                            for (let i = 0; i < 40; i++) {
                                const angle = (i / 40) * Math.PI * 2;
                                particles.push({
                                    x: target.x, y: target.y,
                                    vx: Math.cos(angle) * (4 + Math.random() * 4),
                                    vy: Math.sin(angle) * (4 + Math.random() * 4),
                                    life: 50, color: i % 2 ? '#ff0000' : '#000', size: 5
                                });
                            }

                            // KILL
                            target.health = -9999;
                            target.alive = false;
                            console.log('DEATH NOTE: ' + (target.config ? target.config.name : 'Target') + ' has been eliminated!');
                        }

                        this.writingDeathNote = false;
                        this.deathNoteTarget = null;
                    }
                }

                // Regeneration from skills
                if (this.skillBonuses && this.skillBonuses.regen > 0) {
                    if (!this.regenTick) this.regenTick = 0;
                    this.regenTick++;
                    if (this.regenTick >= 60) { // Every second
                        this.health = Math.min(this.maxHealth, this.health + this.skillBonuses.regen);
                        this.regenTick = 0;
                        // Heal particle
                        particles.push({
                            x: this.x, y: this.y - 20,
                            vx: 0, vy: -1,
                            life: 20, color: '#00ff00', size: 3
                        });
                    }
                }

                // ETERNAL FORM 5 - CONSTANT DEATH LASERS
                if (this.weapon && this.weapon.id === 'eternal' && this.eternalForm === 5) {
                    if (!this.eternalLaserAngle) this.eternalLaserAngle = 0;
                    this.eternalLaserAngle += 0.15; // Rapid spin

                    // Fire 8 direction lasers every 3 frames
                    if (!this.laserTick) this.laserTick = 0;
                    this.laserTick++;

                    if (this.laserTick >= 3) {
                        this.laserTick = 0;

                        // 8 directional lasers
                        for (let i = 0; i < 8; i++) {
                            const angle = this.eternalLaserAngle + (i * Math.PI / 4);
                            projectiles.push({
                                x: this.x,
                                y: this.y,
                                vx: Math.cos(angle) * 20,
                                vy: Math.sin(angle) * 20,
                                damage: 30,
                                owner: this,
                                radius: 8,
                                type: 'eternal_laser',
                                life: 50
                            });
                        }

                        // Visual laser beam effects
                        for (let i = 0; i < 8; i++) {
                            const angle = this.eternalLaserAngle + (i * Math.PI / 4);
                            for (let r = 20; r < 150; r += 25) {
                                particles.push({
                                    x: this.x + Math.cos(angle) * r,
                                    y: this.y + Math.sin(angle) * r,
                                    vx: Math.cos(angle) * 3,
                                    vy: Math.sin(angle) * 3,
                                    life: 8,
                                    color: r < 75 ? '#fff' : '#ffd700',
                                    size: 6
                                });
                            }
                        }
                    }
                }

                // ETERNAL FORM 6 - TRANSCENDENCE - LASER NUKES (only vs Simon!)
                if (this.weapon && this.weapon.id === 'eternal' && this.eternalForm === 6 && this.transcended) {
                    // Transcend invuln timer
                    if (this.transcendInvulnTimer && this.transcendInvulnTimer > 0) {
                        this.transcendInvulnTimer--;
                        if (this.transcendInvulnTimer <= 0) this.isInvulnerable = false;
                    }

                    // Drop laser nukes all over the map!
                    if (!this.nukeTick) this.nukeTick = 0;
                    this.nukeTick++;

                    if (this.nukeTick >= 20) { // Every 20 frames drop nukes
                        this.nukeTick = 0;

                        // Drop 5 laser nukes at random positions
                        for (let i = 0; i < 5; i++) {
                            const nukeX = 100 + Math.random() * (canvas.width - 200);
                            const nukeY = 100 + Math.random() * (canvas.height - 200);

                            // Warning indicator
                            for (let w = 0; w < 10; w++) {
                                const angle = (w / 10) * Math.PI * 2;
                                particles.push({
                                    x: nukeX + Math.cos(angle) * 40,
                                    y: nukeY + Math.sin(angle) * 40,
                                    vx: -Math.cos(angle) * 2,
                                    vy: -Math.sin(angle) * 2,
                                    life: 20, color: '#ff0000', size: 8
                                });
                            }

                            // Delayed nuke explosion
                            setTimeout(() => {
                                // Damage all enemies in blast radius
                                balls.forEach(b => {
                                    if (b !== this && b.alive && !this.isTeammate(b)) {
                                        const dist = Math.hypot(b.x - nukeX, b.y - nukeY);
                                        if (dist < 120) {
                                            b.takeDamage(200, this);
                                            b.stunned = 30;
                                            // Knockback
                                            const angle = Math.atan2(b.y - nukeY, b.x - nukeX);
                                            b.vx += Math.cos(angle) * 15;
                                            b.vy += Math.sin(angle) * 15;
                                        }
                                    }
                                });

                                // Nuke explosion effect
                                hitEffects.push({ x: nukeX, y: nukeY, radius: 10, maxRadius: 150, color: '#ffffff' });
                                hitEffects.push({ x: nukeX, y: nukeY, radius: 10, maxRadius: 120, color: '#ffd700' });
                                hitEffects.push({ x: nukeX, y: nukeY, radius: 10, maxRadius: 90, color: '#ff6600' });

                                // Explosion particles
                                for (let p = 0; p < 40; p++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 5 + Math.random() * 15;
                                    particles.push({
                                        x: nukeX, y: nukeY,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        life: 50,
                                        color: ['#ffffff', '#ffd700', '#ff6600', '#ff0000'][Math.floor(Math.random() * 4)],
                                        size: 12
                                    });
                                }
                            }, 300); // 0.3 second delay for warning
                        }
                    }

                    // Constant divine aura particles
                    if (Math.random() < 0.5) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: this.x + Math.cos(angle) * 50,
                            y: this.y + Math.sin(angle) * 50,
                            vx: Math.cos(angle + Math.PI/2) * 2,
                            vy: Math.sin(angle + Math.PI/2) * 2,
                            life: 40, color: Math.random() < 0.5 ? '#ffffff' : '#ffd700', size: 10
                        });
                    }
                }

                // ETERNAL FORM 5 - Continuous laser barrage (ability)
                if (this.firingEternalLaser && this.laserDuration > 0) {
                    this.laserDuration--;
                    this.laserAngle += 0.15;

                    // Fire sweeping lasers
                    if (this.laserDuration % 3 === 0) {
                        for (let i = 0; i < 3; i++) {
                            const angle = this.laserAngle + i * (Math.PI * 2 / 3);
                            projectiles.push({
                                x: this.x, y: this.y,
                                vx: Math.cos(angle) * 20,
                                vy: Math.sin(angle) * 20,
                                damage: 25, owner: this, size: 8,
                                color: '#ffd700', trail: true,
                                life: 60
                            });
                        }
                        // Laser visual effect
                        for (let i = 0; i < 3; i++) {
                            const angle = this.laserAngle + i * (Math.PI * 2 / 3);
                            for (let r = 0; r < 200; r += 30) {
                                particles.push({
                                    x: this.x + Math.cos(angle) * r,
                                    y: this.y + Math.sin(angle) * r,
                                    vx: Math.cos(angle) * 2,
                                    vy: Math.sin(angle) * 2,
                                    life: 10, color: '#ffd700', size: 6
                                });
                            }
                        }
                    }

                    if (this.laserDuration <= 0) {
                        this.firingEternalLaser = false;
                    }
                }

                if (this.burning > 0) {
                    this.burning--;
                    if (this.burning % 10 === 0) this.takeDamage(2, null);
                    if (Math.random() < 0.3) {
                        particles.push({ x: this.x + (Math.random() - 0.5) * 20, y: this.y - 10,
                            vx: (Math.random() - 0.5) * 2, vy: -2 - Math.random() * 2, life: 20, color: '#ff4400', size: 4 });
                    }
                }

                if (this.frozen > 0) {
                    if (!this.isSoulbound) this.frozen--;
                    else this.frozen = 0;
                }

                if (this.stunned > 0) {
                    if (!this.isSoulbound) this.stunned--;
                    else this.stunned = 0;
                }

                // Kirk MOG cooldown (10 second ability)
                if (this.mogCooldown && this.mogCooldown > 0) this.mogCooldown--;

                // Looksmaxxing timers
                if (this.mewingTimer && this.mewingTimer > 0) {
                    this.mewingTimer--;
                    if (this.mewingTimer <= 0) {
                        this.mewingActive = false;
                        this.isInvulnerable = false;
                    }
                }
                if (this.moggingTimer && this.moggingTimer > 0) {
                    this.moggingTimer--;
                    if (this.moggingTimer <= 0) this.moggingActive = false;
                }

                // Simon ability timers (GODLY)
                if (this.weapon && this.weapon.id === 'simon') {
                    // Passive vampirism - heal 35% of damage dealt
                    if (this.weapon.vampirism && this.lastDamageDealt) {
                        this.health = Math.min(this.maxHealth, this.health + this.lastDamageDealt * this.weapon.vampirism);
                        this.lastDamageDealt = 0;
                    }

                    // Constant spiral particles when alive
                    if (this.alive && Math.random() < 0.3) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: this.x + Math.cos(angle) * 30,
                            y: this.y + Math.sin(angle) * 30,
                            vx: Math.cos(angle + Math.PI/2) * 2,
                            vy: Math.sin(angle + Math.PI/2) * 2,
                            life: 30, color: Math.random() < 0.5 ? '#00ff00' : '#00ffff', size: 6
                        });
                    }
                }

                // Simon iframe timer
                if (this.simonIframeTimer && this.simonIframeTimer > 0) {
                    this.simonIframeTimer--;
                    if (this.simonIframeTimer <= 0) {
                        // Don't remove invuln if other timers are active
                        if (!this.tengenToppaTimer && !this.combineTimer && !this.lagannChargeTimer) {
                            this.isInvulnerable = false;
                        }
                    }
                }

                // Tengen Toppa timer - MASSIVE power mode
                if (this.tengenToppaTimer && this.tengenToppaTimer > 0) {
                    this.tengenToppaTimer--;
                    // Grow larger while active
                    if (this.weapon && this.weapon.id === 'simon') {
                        this.radius = 20 * this.weapon.size * 1.8; // 80% bigger
                    }
                    // Constant damage aura
                    if (this.tengenToppaTimer % 10 === 0) {
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dist = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dist < 250) {
                                    b.takeDamage(25, this);
                                }
                            }
                        });
                    }
                    if (this.tengenToppaTimer <= 0) {
                        this.tengenSizeBoost = false;
                        this.damageMultiplier = 1;
                        this.isInvulnerable = false;
                        if (this.weapon && this.weapon.id === 'simon') {
                            this.radius = 20 * this.weapon.size;
                        }
                    }
                }

                // Lagann charge timer
                if (this.lagannChargeTimer && this.lagannChargeTimer > 0) {
                    this.lagannChargeTimer--;
                    // Keep moving fast and damaging
                    if (this.lagannChargeTimer % 5 === 0) {
                        balls.forEach(b => {
                            if (b !== this && b.alive && !this.isTeammate(b)) {
                                const dist = Math.hypot(b.x - this.x, b.y - this.y);
                                if (dist < 100) {
                                    b.takeDamage(40, this);
                                    // Vampirism
                                    this.health = Math.min(this.maxHealth, this.health + 15);
                                }
                            }
                        });
                    }
                    if (this.lagannChargeTimer <= 0) {
                        if (!this.tengenToppaTimer && !this.simonIframeTimer) {
                            this.isInvulnerable = false;
                        }
                    }
                }

                if (this.spiralPowerTimer && this.spiralPowerTimer > 0) {
                    this.spiralPowerTimer--;
                    // Speed boost while spiral power active
                    const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                    if (speed > 0 && speed < 18) {
                        this.vx *= 1.08;
                        this.vy *= 1.08;
                    }
                    if (this.spiralPowerTimer <= 0) {
                        this.spiralSpeedBoost = false;
                        this.damageMultiplier = 1;
                    }
                }
                if (this.invulnTimer && this.invulnTimer > 0) {
                    this.invulnTimer--;
                    if (this.invulnTimer <= 0) this.isInvulnerable = false;
                }
                if (this.combineTimer && this.combineTimer > 0) {
                    this.combineTimer--;
                    if (this.combineTimer <= 0) {
                        this.isInvulnerable = false;
                    }
                }
                if (this.mogged && this.mogged > 0) {
                    this.mogged--;
                    // Mogged debuff - reduced damage
                    if (this.damageMultiplier > 0.5) this.damageMultiplier = 0.5;
                }

                // Kirk emote timer
                if (this.emoteTimer && this.emoteTimer > 0) {
                    this.emoteTimer--;
                    if (this.emoteTimer <= 0) this.isInvulnerable = false;
                }

                // Movement
                if (this.frozen === 0 && this.stunned === 0) {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.angle += this.rotationSpeed;
                }

                // Apply friction
                if (this.weapon.id !== 'unarmed') {
                    this.vx *= 0.995;
                    this.vy *= 0.995;
                }

                // Cash trail for jackpot winners
                if (this.cashTrailActive && this.jackpotActive) {
                    if (Math.random() < 0.3) {
                        // Spawn damaging cash projectile behind
                        projectiles.push({
                            x: this.x, y: this.y,
                            vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                            radius: 10, damage: 15, owner: this, type: 'cash', life: 90
                        });
                    }
                }

                // Check for American Ball air support trigger at low HP
                if (this.weapon && this.weapon.id === 'american') {
                    this.checkAirSupportTrigger();
                }

                // Speed limits for ALL balls - never stop moving!
                const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                const maxSpeed = this.weapon.id === 'unarmed' ? 10 : 8;
                const minSpeed = 4;
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                } else if (speed < minSpeed) {
                    // Never let balls stop - boost back to minimum speed
                    if (speed > 0.01) {
                        this.vx = (this.vx / speed) * minSpeed;
                        this.vy = (this.vy / speed) * minSpeed;
                    } else {
                        // If nearly stopped, give random direction
                        const angle = Math.random() * Math.PI * 2;
                        this.vx = Math.cos(angle) * minSpeed;
                        this.vy = Math.sin(angle) * minSpeed;
                    }
                }

                // Wall collision
                const distFromCenter = Math.sqrt((this.x - centerX) ** 2 + (this.y - centerY) ** 2);
                if (distFromCenter + this.radius > arenaRadius) {
                    const angle = Math.atan2(this.y - centerY, this.x - centerX);
                    this.x = centerX + Math.cos(angle) * (arenaRadius - this.radius);
                    this.y = centerY + Math.sin(angle) * (arenaRadius - this.radius);

                    const normalX = Math.cos(angle);
                    const normalY = Math.sin(angle);
                    const dot = this.vx * normalX + this.vy * normalY;
                    this.vx -= 2 * dot * normalX;
                    this.vy -= 2 * dot * normalY;

                    if (this.weapon.id === 'unarmed') {
                        this.unarmedSpeed *= 1.08;
                        if (this.unarmedSpeed > 10) this.unarmedSpeed = 10;
                        const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                        if (speed > 0) {
                            this.vx = (this.vx / speed) * this.unarmedSpeed;
                            this.vy = (this.vy / speed) * this.unarmedSpeed;
                        }
                    }
                }

                // Ball collision
                balls.forEach(other => {
                    if (other === this || !other.alive) return;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = this.radius + other.radius;

                    if (dist < minDist && dist > 0) {
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const overlap = minDist - dist;
                        this.x -= nx * overlap / 2;
                        this.y -= ny * overlap / 2;
                        other.x += nx * overlap / 2;
                        other.y += ny * overlap / 2;

                        const dvx = this.vx - other.vx;
                        const dvy = this.vy - other.vy;
                        const dvn = dvx * nx + dvy * ny;

                        if (dvn > 0) {
                            this.vx -= dvn * nx;
                            this.vy -= dvn * ny;
                            other.vx += dvn * nx;
                            other.vy += dvn * ny;
                        }

                        if (this.weapon.id === 'unarmed') {
                            this.unarmedSpeed *= 1.05;
                            if (this.unarmedSpeed > 10) this.unarmedSpeed = 10;
                        }
                    }
                });

                // Weapon hit detection
                if (this.hitCooldown > 0) this.hitCooldown--;

                if (this.hitCooldown === 0 && this.weapon.length > 0) {
                    const tip = this.getWeaponTip();
                    balls.forEach(other => {
                        if (other === this || !other.alive || this.isTeammate(other)) return;
                        const dx = tip.x - other.x;
                        const dy = tip.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < other.radius + 5) {
                            let damage = this.weapon.damage * this.damageMultiplier;
                            other.takeDamage(damage, this);
                            this.hitCooldown = 30;

                            if (this.weapon.id === 'scythe' && this.abilityActive) {
                                this.health = Math.min(this.maxHealth, this.health + damage * 0.5);
                            }

                            for (let i = 0; i < 8; i++) {
                                particles.push({ x: tip.x, y: tip.y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                                    life: 20, color: other.config.color, size: 4 });
                            }
                        }
                    });
                }

                // Unarmed collision damage
                if (this.weapon.id === 'unarmed') {
                    balls.forEach(other => {
                        if (other === this || !other.alive || this.isTeammate(other)) return;
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < this.radius + other.radius + 5 && this.hitCooldown === 0) {
                            const damage = Math.floor(this.unarmedSpeed * 4);
                            if (damage > 0) {
                                other.takeDamage(damage, this);
                                this.hitCooldown = 20;
                                for (let i = 0; i < 10; i++) {
                                    particles.push({ x: (this.x + other.x) / 2, y: (this.y + other.y) / 2,
                                        vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                                        life: 25, color: '#ff4400', size: 5 });
                                }
                            }
                        }
                    });
                }

                // Ability cooldown and effects
                if (this.abilityCooldown > 0) this.abilityCooldown--;
                if (this.abilityTimer > 0) {
                    this.abilityTimer--;
                    if (this.abilityTimer === 0) {
                        this.abilityActive = false;
                        this.damageMultiplier = 1;
                        this.rotationSpeed = this.baseRotationSpeed;
                        this.isInvulnerable = false;
                        this.isSoulbound = false;
                        this.currentAbility = null;
                    }
                }

                // Auto ability
                if (this.abilityCooldown === 0 && this.weapon.abilityCooldown > 0 && Math.random() < 0.02) {
                    this.useAbility();
                }

                // Gravity well effect
                if (this.abilityActive && this.weapon.id === 'voidorb') {
                    balls.forEach(b => {
                        if (b !== this && b.alive && !this.isTeammate(b)) {
                            const dx = this.x - b.x;
                            const dy = this.y - b.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 200 && dist > 0) {
                                const force = 0.5 * (1 - dist / 200);
                                b.vx += (dx / dist) * force;
                                b.vy += (dy / dist) * force;
                            }
                        }
                    });
                }

                // Regen effect
                if (this.abilityActive && this.weapon.id === 'healstaff') {
                    if (this.abilityTimer % 10 === 0) {
                        this.health = Math.min(this.maxHealth, this.health + 3);
                        particles.push({ x: this.x + (Math.random() - 0.5) * 20, y: this.y + 10,
                            vx: 0, vy: -2, life: 30, color: '#44ff44', size: 4 });
                    }
                }
            }

            takeDamage(amount, attacker) {
                if (this.isInvulnerable) return;
                if (this.weapon.id === 'sword' && this.abilityActive) return; // Parry

                // GODLY Paradoxical takes 50% reduced damage
                if (this.weapon && this.weapon.id === 'paradoxical') {
                    const originalAmount = amount;
                    amount = amount * 0.5;

                    // Track total damage for phase transitions
                    if (!this.totalDamageTaken) this.totalDamageTaken = 0;
                    this.totalDamageTaken += amount;

                    // Visual indicator of damage reduction
                    particles.push({
                        x: this.x, y: this.y - 30,
                        vx: 0, vy: -1, life: 40,
                        color: '#00ffff', size: 3,
                        text: '-50%'
                    });
                }

                // Apply defense from skill tree
                if (this.skillBonuses && this.skillBonuses.defense > 0) {
                    amount = amount * (1 - this.skillBonuses.defense);
                }

                this.health -= amount;

                // Lifesteal for attacker
                if (attacker && attacker.skillBonuses && attacker.skillBonuses.lifesteal > 0) {
                    const healAmount = amount * attacker.skillBonuses.lifesteal;
                    attacker.health = Math.min(attacker.maxHealth, attacker.health + healAmount);
                }

                // SIMON VAMPIRISM - Heals 35% of all damage dealt
                if (attacker && attacker.weapon && attacker.weapon.vampirism) {
                    const vampHeal = amount * attacker.weapon.vampirism;
                    attacker.health = Math.min(attacker.maxHealth, attacker.health + vampHeal);
                    // Green heal particle
                    if (Math.random() < 0.3) {
                        particles.push({
                            x: attacker.x, y: attacker.y - 20,
                            vx: (Math.random() - 0.5) * 2, vy: -2,
                            life: 30, color: '#00ff00', size: 8
                        });
                    }
                }

                const knockbackAngle = attacker ? Math.atan2(this.y - attacker.y, this.x - attacker.x) : Math.random() * Math.PI * 2;
                this.vx += Math.cos(knockbackAngle) * 1.5;
                this.vy += Math.sin(knockbackAngle) * 1.5;

                if (this.health <= 0) {
                    // THE ETERNAL - Resurrection check
                    if (this.weapon && this.weapon.id === 'eternal') {
                        const form = this.eternalForm || 1;
                        // Check if Simon is on the field - unlocks hidden 6th form!
                        const simonExists = balls.some(b => b.weapon && b.weapon.id === 'simon' && b.alive);
                        const maxForm = simonExists ? 6 : 5;

                        if (form < maxForm) {
                            // RESURRECT!
                            this.eternalForm = form + 1;
                            this.health = this.maxHealth * (1 + form * 0.5);
                            this.maxHealth = this.health;

                            // Power boost per form
                            this.weapon = {
                                ...this.weapon,
                                damage: 5 + form * 15,
                                speed: 0.5 + form * 0.15,
                                size: 0.8 + form * 0.25
                            };
                            this.radius = 20 * this.weapon.size;

                            // HIDDEN FORM 6 - TRANSCENDENCE (only vs Simon!)
                            if (this.eternalForm === 6) {
                                this.transcended = true;
                                this.weapon.damage = 100;
                                this.weapon.size = 2.5;
                                this.radius = 20 * this.weapon.size;
                                this.damageMultiplier = 10;
                                this.maxHealth *= 3;
                                this.health = this.maxHealth;
                                this.shield = 3000;
                                this.isInvulnerable = true;
                                this.transcendInvulnTimer = 300; // 5 sec invuln on transform

                                // DISABLE ALL OTHER BALLS' ABILITIES
                                balls.forEach(b => {
                                    if (b !== this && b.alive) {
                                        b.abilitiesSealed = true;
                                        b.abilityTimer = 999999; // Block ability use
                                    }
                                });

                                // Trigger the TRANSCENDENCE cutscene
                                if (typeof triggerTranscendenceCutscene === 'function') {
                                    triggerTranscendenceCutscene();
                                }

                                // Epic transcendence effect
                                for (let ring = 0; ring < 8; ring++) {
                                    setTimeout(() => {
                                        for (let i = 0; i < 32; i++) {
                                            const angle = (i / 32) * Math.PI * 2;
                                            particles.push({
                                                x: this.x + Math.cos(angle) * (50 + ring * 30),
                                                y: this.y + Math.sin(angle) * (50 + ring * 30),
                                                vx: Math.cos(angle) * 8,
                                                vy: Math.sin(angle) * 8,
                                                life: 80,
                                                color: ['#ffffff', '#ffd700', '#ff0000', '#ff6600'][ring % 4],
                                                size: 15
                                            });
                                        }
                                        hitEffects.push({ x: this.x, y: this.y, radius: ring * 40, maxRadius: 400, color: '#ffffff' });
                                    }, ring * 100);
                                }
                            }

                            // Trigger transformation cutscene
                            if (typeof triggerEternalTransformation === 'function') {
                                triggerEternalTransformation(this, form + 1);
                            }

                            // Explosion of particles for resurrection
                            for (let i = 0; i < 50; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 3 + Math.random() * 7;
                                particles.push({
                                    x: this.x, y: this.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    life: 60, color: this.eternalForm === 6 ? '#ffffff' : '#ffd700', size: 8
                                });
                            }
                            return; // Don't die!
                        }
                    }

                    this.health = 0;
                    this.alive = false;
                    // Credit kill to the attacker
                    if (attacker && attacker.kills !== undefined) {
                        attacker.kills++;
                    }
                    for (let i = 0; i < 30; i++) {
                        particles.push({ x: this.x, y: this.y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                            life: 40, color: this.config.color, size: 6 });
                    }
                }
            }

            draw() {
                if (!this.alive) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Team indicator
                if (settings.teamMode && this.team !== 0) {
                    ctx.strokeStyle = this.team === 1 ? '#ff4444' : '#4444ff';
                    ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius + 8, 0, Math.PI * 2); ctx.stroke();
                }

                // Frozen effect
                if (this.frozen > 0) {
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2); ctx.fill();
                }

                // Ball body
                const gradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, this.radius);
                gradient.addColorStop(0, this.config.color);
                gradient.addColorStop(1, this.config.darkColor);
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();

                // Shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath(); ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2); ctx.fill();

                // Weapon
                ctx.save();
                ctx.rotate(this.angle);
                ctx.translate(this.radius, 0);
                this.weapon.draw(ctx, this.weapon, this);
                ctx.restore();

                ctx.restore();

                // Health bar
                const barWidth = 50;
                const barHeight = 6;
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 15, barWidth, barHeight);
                ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#ff9800' : '#f44336';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.radius - 15, barWidth * healthPercent, barHeight);
            }
        }

        function createLightningBolt(x1, y1, x2, y2) {
            const segments = [];
            const steps = 8;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + (x2 - x1) * t + (i > 0 && i < steps ? (Math.random() - 0.5) * 30 : 0);
                const y = y1 + (y2 - y1) * t + (i > 0 && i < steps ? (Math.random() - 0.5) * 30 : 0);
                segments.push({ x, y });
            }
            lightningBolts.push({ segments, life: 15 });
        }

        function createDivineLightning(x1, y1, x2, y2) {
            const segments = [];
            const steps = 10;
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + (x2 - x1) * t + (i > 0 && i < steps ? (Math.random() - 0.5) * 20 : 0);
                const y = y1 + (y2 - y1) * t;
                segments.push({ x, y });
            }
            divineLightning.push({ segments, life: 20 });
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                // Homing logic for arcane missiles and elementals
                if (p.homing && p.owner) {
                    const enemies = balls.filter(b => b.alive && b !== p.owner && !p.owner.isTeammate(b));
                    if (enemies.length > 0) {
                        const target = enemies.reduce((a, b) =>
                            Math.sqrt((a.x-p.x)**2+(a.y-p.y)**2) < Math.sqrt((b.x-p.x)**2+(b.y-p.y)**2) ? a : b);
                        const dx = target.x - p.x;
                        const dy = target.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            const strength = p.homingStrength || 0.1;
                            p.vx += (dx / dist) * strength;
                            p.vy += (dy / dist) * strength;
                            // Cap speed
                            const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                            if (speed > 12) {
                                p.vx = (p.vx / speed) * 12;
                                p.vy = (p.vy / speed) * 12;
                            }
                        }
                    }
                }

                p.x += p.vx;
                p.y += p.vy;
                p.life--;

                // Trail particles
                if (p.type === 'fireball') {
                    particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                        life: 15, color: Math.random() > 0.5 ? '#ff4400' : '#ffaa00', size: 4 });
                } else if (p.type === 'whiteflame') {
                    particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                        life: 15, color: Math.random() > 0.5 ? '#ffffff' : '#e0ffff', size: 4 });
                } else if (p.type === 'hollowpurple') {
                    particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3,
                        life: 20, color: Math.random() > 0.5 ? '#9932cc' : '#4b0082', size: 6 });
                }

                // Hit detection
                balls.forEach(b => {
                    if (b === p.owner || !b.alive || (p.owner && p.owner.isTeammate(b))) return;
                    const dx = p.x - b.x;
                    const dy = p.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < b.radius + p.radius) {
                        b.takeDamage(p.damage, p.owner);
                        if (p.type === 'fireball' || p.type === 'whiteflame') b.burning = 60;
                        p.life = 0;
                        for (let j = 0; j < 10; j++) {
                            particles.push({ x: p.x, y: p.y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
                                life: 20, color: p.type === 'whiteflame' ? '#e0ffff' : '#ff4400', size: 5 });
                        }
                    }
                });

                // Arena boundary
                const distFromCenter = Math.sqrt((p.x - centerX) ** 2 + (p.y - centerY) ** 2);
                if (distFromCenter > arenaRadius || p.life <= 0) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function drawProjectiles() {
            projectiles.forEach(p => {
                if (p.type === 'fireball') {
                    ctx.fillStyle = '#ff4400';
                    ctx.shadowColor = '#ff4400'; ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.radius * 0.6, 0, Math.PI * 2); ctx.fill();
                } else if (p.type === 'whiteflame') {
                    ctx.fillStyle = '#e0ffff';
                    ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.radius * 0.5, 0, Math.PI * 2); ctx.fill();
                } else if (p.type === 'knife') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.vy, p.vx) + Math.PI / 2);
                    ctx.fillStyle = '#c0c0c0';
                    ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(3, 6);
                    ctx.lineTo(0, 4);
                    ctx.lineTo(-3, 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(-2, 4, 4, 6);
                    ctx.restore();
                } else if (p.type === 'money') {
                    ctx.fillStyle = '#00aa00';
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', p.x, p.y);
                } else if (p.type === 'pollution') {
                    ctx.fillStyle = '#3d3d3d';
                    ctx.shadowColor = '#1a1a1a';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#5a5a5a';
                    ctx.beginPath();
                    ctx.arc(p.x - 3, p.y - 3, p.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'chip') {
                    // Casino chip
                    const chipColors = ['#ff0000', '#00aa00', '#0000ff', '#ffd700', '#ff00ff'];
                    ctx.fillStyle = chipColors[Math.floor(p.x + p.y) % chipColors.length];
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'bullet') {
                    // Bullet projectile
                    ctx.fillStyle = '#ffcc00';
                    ctx.shadowColor = '#ff8800';
                    ctx.shadowBlur = 8;
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    ctx.beginPath();
                    ctx.ellipse(0, 0, p.radius * 1.5, p.radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else if (p.type === 'eternal_laser') {
                    // THE ETERNAL golden laser beam
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    // Outer glow
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, p.radius * 2, p.radius * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Inner white core
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, p.radius, p.radius * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else if (p.type === 'dog') {
                    // DOGPILL - Loyal dog
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    // Body
                    ctx.fillStyle = '#8b4513';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, p.radius, p.radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Head
                    ctx.beginPath();
                    ctx.arc(p.radius * 0.7, 0, p.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    // Ears
                    ctx.beginPath();
                    ctx.ellipse(p.radius * 0.9, -p.radius * 0.4, 4, 8, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    // Eye
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(p.radius * 0.9, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Tail
                    ctx.strokeStyle = '#8b4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-p.radius * 0.8, 0);
                    ctx.quadraticCurveTo(-p.radius * 1.2, -p.radius * 0.5, -p.radius * 0.9, -p.radius * 0.7);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.type === 'drill' || p.type === 'heaven_drill') {
                    // SIMON - Spiral Drill
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.vy, p.vx) + Math.PI / 2);
                    const time = Date.now() / 100;

                    // Spiral glow
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 25;

                    // Drill cone
                    const drillGrad = ctx.createLinearGradient(0, -p.radius * 2, 0, p.radius);
                    drillGrad.addColorStop(0, '#00ff00');
                    drillGrad.addColorStop(0.3, '#88ff88');
                    drillGrad.addColorStop(0.6, '#00aa00');
                    drillGrad.addColorStop(1, '#004400');
                    ctx.fillStyle = drillGrad;

                    ctx.beginPath();
                    ctx.moveTo(0, -p.radius * 2);
                    ctx.lineTo(-p.radius * 0.8, p.radius * 0.5);
                    ctx.lineTo(p.radius * 0.8, p.radius * 0.5);
                    ctx.closePath();
                    ctx.fill();

                    // Spiral grooves (rotating)
                    ctx.strokeStyle = '#003300';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 5; i++) {
                        const y = -p.radius * 1.5 + i * p.radius * 0.5;
                        const width = p.radius * 0.6 * (1 - i * 0.15);
                        ctx.beginPath();
                        ctx.moveTo(-width, y + Math.sin(time + i) * 3);
                        ctx.lineTo(width, y - Math.sin(time + i) * 3);
                        ctx.stroke();
                    }

                    ctx.shadowBlur = 0;
                    ctx.restore();

                    // Trailing spiral particles
                    if (Math.random() < 0.5) {
                        const angle = Math.random() * Math.PI * 2;
                        particles.push({
                            x: p.x + Math.cos(angle) * 10,
                            y: p.y + Math.sin(angle) * 10,
                            vx: -p.vx * 0.1 + (Math.random() - 0.5) * 3,
                            vy: -p.vy * 0.1 + (Math.random() - 0.5) * 3,
                            life: 15, color: '#00ff00', size: 5
                        });
                    }
                } else if (p.type === 'grenade') {
                    // Grenade projectile
                    ctx.fillStyle = '#556b2f';
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Grenade details
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(p.x - 3, p.y - p.radius - 4, 6, 4);
                } else if (p.type === 'fireball') {
                    // Fireball
                    ctx.fillStyle = '#ff4400';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'meteor') {
                    // Meteor
                    ctx.fillStyle = '#8b4513';
                    ctx.shadowColor = '#ff4400';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Fire trail
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y - p.radius, p.radius * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'arcane_missile') {
                    // Arcane missile
                    ctx.fillStyle = '#9932cc';
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'elemental') {
                    // Elemental projectile
                    ctx.fillStyle = p.color || '#00ffff';
                    ctx.shadowColor = p.color || '#00ffff';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'card') {
                    // Playing card
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#000000';
                    ctx.shadowBlur = 5;
                    ctx.fillRect(-6, -8, 12, 16);
                    ctx.fillStyle = Math.random() > 0.5 ? '#ff0000' : '#000000';
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('A', 0, 4);
                    ctx.restore();
                } else if (p.type === 'cash') {
                    // Cash trail projectile
                    ctx.fillStyle = '#00ff00';
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 10;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', p.x, p.y);
                }
                ctx.shadowBlur = 0;
            });
        }

        function drawLightning() {
            lightningBolts.forEach(bolt => {
                ctx.strokeStyle = `rgba(255, 255, 0, ${bolt.life / 15})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);
                bolt.segments.forEach(s => ctx.lineTo(s.x, s.y));
                ctx.stroke();
                ctx.shadowBlur = 0;
            });

            divineLightning.forEach(bolt => {
                ctx.strokeStyle = `rgba(255, 215, 0, ${bolt.life / 20})`;
                ctx.lineWidth = 5;
                ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.moveTo(bolt.segments[0].x, bolt.segments[0].y);
                bolt.segments.forEach(s => ctx.lineTo(s.x, s.y));
                ctx.stroke();
                ctx.shadowBlur = 0;
            });
        }

        function placePowerup(type, x, y) {
            const powerupConfig = {
                heal: { radius: 100, duration: 400, color: '#00ff00', effect: 'heal' },
                damage: { radius: 90, duration: 350, color: '#ff4444', effect: 'damage' },
                speed: { radius: 95, duration: 300, color: '#00bfff', effect: 'speed' },
                shield: { radius: 85, duration: 280, color: '#ffd700', effect: 'shield' },
                freeze: { radius: 110, duration: 250, color: '#88ffff', effect: 'freeze' }
            };

            const config = powerupConfig[type];
            powerups.push({
                x: x,
                y: y,
                type: type,
                radius: config.radius,
                duration: config.duration,
                maxDuration: config.duration,
                color: config.color,
                effect: config.effect,
                pulsePhase: 0
            });

            // Spawn particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    life: 30,
                    color: config.color,
                    size: 6
                });
            }
        }

        function updatePowerups() {
            // Update cooldowns
            for (let type in powerupCooldowns) {
                if (powerupCooldowns[type] > 0) {
                    powerupCooldowns[type]--;
                }
            }

            // Update cooldown display
            document.querySelectorAll('.powerup-btn').forEach(btn => {
                const type = btn.dataset.type;
                const cooldown = powerupCooldowns[type];
                let overlay = btn.querySelector('.cooldown-overlay');

                if (cooldown > 0) {
                    if (!overlay) {
                        overlay = document.createElement('div');
                        overlay.className = 'cooldown-overlay';
                        btn.appendChild(overlay);
                    }
                    overlay.textContent = Math.ceil(cooldown / 60) + 's';
                    btn.style.opacity = '0.5';
                } else {
                    if (overlay) overlay.remove();
                    btn.style.opacity = '1';
                }
            });

            // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.duration--;
                p.pulsePhase += 0.1;

                // Apply effects to balls in range
                balls.forEach(ball => {
                    if (!ball.alive) return;
                    const dx = ball.x - p.x;
                    const dy = ball.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < p.radius + ball.radius) {
                        switch (p.effect) {
                            case 'heal':
                                if (ball.health < ball.maxHealth) {
                                    ball.health = Math.min(ball.maxHealth, ball.health + 0.5);
                                    if (Math.random() < 0.1) {
                                        particles.push({
                                            x: ball.x + (Math.random() - 0.5) * 20,
                                            y: ball.y + (Math.random() - 0.5) * 20,
                                            vx: 0, vy: -2,
                                            life: 20, color: '#00ff00', size: 4
                                        });
                                    }
                                }
                                break;
                            case 'damage':
                                ball.damageMultiplier = 2;
                                ball.powerupDamageBuff = 60;
                                break;
                            case 'speed':
                                const speed = Math.sqrt(ball.vx ** 2 + ball.vy ** 2);
                                if (speed > 0 && speed < 10) {
                                    ball.vx *= 1.02;
                                    ball.vy *= 1.02;
                                }
                                break;
                            case 'shield':
                                ball.isInvulnerable = true;
                                ball.powerupShield = 90;
                                if (Math.random() < 0.15) {
                                    particles.push({
                                        x: ball.x + (Math.random() - 0.5) * 30,
                                        y: ball.y + (Math.random() - 0.5) * 30,
                                        vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                                        life: 15, color: '#ffd700', size: 5
                                    });
                                }
                                break;
                            case 'freeze':
                                // Freeze is a trap - affects enemies
                                ball.frozen = 60;
                                ball.stunned = 60;
                                break;
                        }
                    }
                });

                // Handle temporary buffs expiring
                balls.forEach(ball => {
                    if (ball.powerupDamageBuff) {
                        ball.powerupDamageBuff--;
                        if (ball.powerupDamageBuff <= 0) {
                            ball.damageMultiplier = 1;
                        }
                    }
                    if (ball.powerupShield) {
                        ball.powerupShield--;
                        if (ball.powerupShield <= 0) {
                            ball.isInvulnerable = false;
                        }
                    }
                });

                if (p.duration <= 0) {
                    powerups.splice(i, 1);
                }
            }
        }

        function drawPowerups() {
            const time = Date.now() / 1000;

            powerups.forEach(p => {
                const alpha = Math.min(1, p.duration / 60);
                const pulse = 1 + Math.sin(p.pulsePhase) * 0.1;

                // Outer glow
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * pulse);
                gradient.addColorStop(0, p.color + '40');
                gradient.addColorStop(0.5, p.color + '20');
                gradient.addColorStop(1, p.color + '00');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Inner circle
                ctx.strokeStyle = p.color;
                ctx.globalAlpha = alpha * 0.8;
                ctx.lineWidth = 3;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius * 0.7 * pulse, 0, Math.PI * 2);
                ctx.stroke();

                // Rotating symbols
                ctx.globalAlpha = alpha;
                for (let i = 0; i < 4; i++) {
                    const angle = time * 2 + (i / 4) * Math.PI * 2;
                    const dist = p.radius * 0.5;
                    const sx = p.x + Math.cos(angle) * dist;
                    const sy = p.y + Math.sin(angle) * dist;

                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Center icon
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = p.color;
                const icons = { heal: '+', damage: 'X', speed: '>>', shield: 'O', freeze: '*' };
                ctx.fillText(icons[p.type] || '?', p.x, p.y);

                // Duration bar
                const barWidth = 40;
                const barHeight = 4;
                const fillWidth = (p.duration / p.maxDuration) * barWidth;
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(p.x - barWidth/2, p.y + p.radius * 0.3, barWidth, barHeight);
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - barWidth/2, p.y + p.radius * 0.3, fillWidth, barHeight);

                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            });
        }

        function drawFloorTraps() {
            if (!window.floorTraps) return;
            const time = Date.now() / 1000;
            window.floorTraps.forEach(trap => {
                if (trap.type === 'chakram') {
                    ctx.save();
                    ctx.translate(trap.x, trap.y);
                    ctx.rotate(trap.rotation + time * 3);

                    // Outer ring
                    ctx.strokeStyle = `rgba(255, 102, 0, ${trap.life / 300})`;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 10;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, trap.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner blades
                    ctx.fillStyle = `rgba(255, 140, 0, ${trap.life / 300})`;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle - 0.2) * trap.radius, Math.sin(angle - 0.2) * trap.radius);
                        ctx.lineTo(Math.cos(angle) * (trap.radius * 0.6), Math.sin(angle) * (trap.radius * 0.6));
                        ctx.lineTo(Math.cos(angle + 0.2) * trap.radius, Math.sin(angle + 0.2) * trap.radius);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Center
                    ctx.fillStyle = `rgba(255, 200, 0, ${trap.life / 300})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                    ctx.shadowBlur = 0;
                } else if (trap.type === 'factory') {
                    ctx.save();
                    ctx.translate(trap.x, trap.y);
                    const alpha = trap.type === 'factory' ? 1 : trap.life / 400;

                    // Factory building
                    ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`;
                    ctx.fillRect(-20, -15, 40, 30);

                    // Chimney
                    ctx.fillRect(-5, -35, 10, 20);

                    // Smoke
                    ctx.fillStyle = `rgba(60, 60, 60, ${alpha * 0.7})`;
                    const smokeTime = Date.now() / 1000;
                    for (let i = 0; i < 3; i++) {
                        const sy = -40 - (smokeTime * 20 + i * 15) % 40;
                        const sx = Math.sin(smokeTime + i) * 8;
                        ctx.beginPath();
                        ctx.arc(sx, sy, 8 + i * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Pollution zone indicator
                    ctx.strokeStyle = `rgba(100, 50, 0, ${alpha * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, trap.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                }
            });
        }

        function updateFloorTraps() {
            if (!window.floorTraps) return;
            for (let i = window.floorTraps.length - 1; i >= 0; i--) {
                const trap = window.floorTraps[i];
                trap.life--;
                trap.rotation += 0.05;

                // Factories emit projectiles constantly
                // Poison cloud damage
                if (trap.type === 'poison_cloud') {
                    balls.forEach(b => {
                        if (b.alive && b !== trap.owner && !trap.owner?.isTeammate(b)) {
                            const dist = Math.sqrt((b.x - trap.x) ** 2 + (b.y - trap.y) ** 2);
                            if (dist < trap.radius) {
                                b.takeDamage(trap.damage * 0.05, trap.owner); // Tick damage
                                if (Math.random() < 0.1) {
                                    particles.push({ x: b.x, y: b.y,
                                        vx: (Math.random() - 0.5) * 2, vy: -1,
                                        life: 20, color: '#00ff00', size: 4 });
                                }
                            }
                        }
                    });
                }

                if (trap.type === 'factory') {
                    trap.shootTimer = (trap.shootTimer || 0) + 1;
                    if (trap.shootTimer >= 45) { // Shoot every 45 frames
                        trap.shootTimer = 0;
                        // Shoot pollution projectile at random angle
                        const angle = Math.random() * Math.PI * 2;
                        projectiles.push({
                            x: trap.x, y: trap.y - 30,
                            vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4 - 2,
                            radius: 10, damage: 12, owner: trap.owner, type: 'pollution', life: 120
                        });
                        // Smoke effect
                        for (let s = 0; s < 5; s++) {
                            particles.push({ x: trap.x, y: trap.y - 35,
                                vx: (Math.random() - 0.5) * 3, vy: -Math.random() * 2,
                                life: 30, color: '#444444', size: 8 });
                        }
                    }
                    // Factories don't get removed, skip collision removal
                    balls.forEach(b => {
                        if (b !== trap.owner && b.alive && (!trap.owner || !trap.owner.isTeammate(b))) {
                            const dx = b.x - trap.x;
                            const dy = b.y - trap.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < trap.radius + b.radius) {
                                b.takeDamage(trap.damage * 0.1, trap.owner); // Pollution damage over time
                                b.burning = 30;
                            }
                        }
                    });
                    return; // Don't remove factories
                }

                // Check collision with balls (for non-factory traps)
                balls.forEach(b => {
                    if (b !== trap.owner && b.alive && (!trap.owner || !trap.owner.isTeammate(b))) {
                        const dx = b.x - trap.x;
                        const dy = b.y - trap.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < trap.radius + b.radius) {
                            b.takeDamage(trap.damage, trap.owner);
                            // Remove trap after hit
                            window.floorTraps.splice(i, 1);
                            // Hit particles
                            for (let j = 0; j < 12; j++) {
                                particles.push({ x: trap.x, y: trap.y,
                                    vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                                    life: 25, color: '#ff6600', size: 5 });
                            }
                            hitEffects.push({ x: trap.x, y: trap.y, radius: 5, maxRadius: 40, color: '#ff8800' });
                            return;
                        }
                    }
                });

                if (trap.life <= 0) {
                    window.floorTraps.splice(i, 1);
                }
            }
        }

        function updateEffects() {
            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                // Homing logic for arcane missiles and elementals
                if (p.homing && p.owner) {
                    const enemies = balls.filter(b => b.alive && b !== p.owner && !p.owner.isTeammate(b));
                    if (enemies.length > 0) {
                        const target = enemies.reduce((a, b) =>
                            Math.sqrt((a.x-p.x)**2+(a.y-p.y)**2) < Math.sqrt((b.x-p.x)**2+(b.y-p.y)**2) ? a : b);
                        const dx = target.x - p.x;
                        const dy = target.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            const strength = p.homingStrength || 0.1;
                            p.vx += (dx / dist) * strength;
                            p.vy += (dy / dist) * strength;
                            // Cap speed
                            const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                            if (speed > 12) {
                                p.vx = (p.vx / speed) * 12;
                                p.vy = (p.vy / speed) * 12;
                            }
                        }
                    }
                }

                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // Hit effects
            for (let i = hitEffects.length - 1; i >= 0; i--) {
                const e = hitEffects[i];
                e.radius += (e.maxRadius - e.radius) * 0.2;
                if (e.radius > e.maxRadius * 0.95) hitEffects.splice(i, 1);
            }

            // Lightning
            for (let i = lightningBolts.length - 1; i >= 0; i--) {
                lightningBolts[i].life--;
                if (lightningBolts[i].life <= 0) lightningBolts.splice(i, 1);
            }

            for (let i = divineLightning.length - 1; i >= 0; i--) {
                divineLightning[i].life--;
                if (divineLightning[i].life <= 0) divineLightning.splice(i, 1);
            }
        }

        function drawEffects() {
            // Hit effects
            hitEffects.forEach(e => {
                ctx.strokeStyle = e.color;
                ctx.lineWidth = 3;
                ctx.globalAlpha = 1 - (e.radius / e.maxRadius);
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.stroke();
                ctx.globalAlpha = 1;
            });

            // Particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 40;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (p.life / 40), 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        function checkWinner() {
            const alive = balls.filter(b => b.alive);

            // Debug log
            if (alive.length <= 1) {
                console.log('Round ending, alive balls:', alive.length);
            }

            if (settings.teamMode) {
                const teams = {};
                alive.forEach(b => {
                    if (!teams[b.team]) teams[b.team] = [];
                    teams[b.team].push(b);
                });
                const aliveTeams = Object.keys(teams).filter(t => teams[t].length > 0);
                if (aliveTeams.length <= 1) {
                    if (aliveTeams.length === 1) {
                        const winningTeam = aliveTeams[0];
                        teams[winningTeam].forEach(b => scores[b.configIndex]++);
                    }
                    endRound(alive);
                }
            } else {
                if (alive.length <= 1) {
                    if (alive.length === 1) {
                        scores[alive[0].configIndex]++;
                    }
                    endRound(alive);
                }
            }
        }

        function endRound(alive) {
            console.log('endRound called with', alive.length, 'alive balls');

            try {
                updateScoreDisplay();
            } catch (e) {
                console.error('Error updating score display:', e);
            }

            // Award currency to all balls based on performance
            try {
                balls.forEach(ball => {
                    if (ball.configIndex !== undefined) {
                        const isWinner = alive.includes(ball);
                        const stats = {
                            kills: ball.kills || 0,
                            damageDealt: ball.totalDamageDealt || 0,
                            hpPercent: ball.alive ? (ball.health / ball.maxHealth) : 0,
                            lowestHp: ball.lowestHpPercent || 1
                        };

                        // Award to all player balls
                        if (typeof awardRoundCurrency === 'function') {
                            const reward = awardRoundCurrency(ball, isWinner, stats);
                            console.log(`Ball ${ball.configIndex} earned ${reward.total}$`);
                        }
                    }
                });
                updateCurrencyDisplay();
            } catch (e) {
                console.error('Error awarding currency:', e);
            }

            if (currentRound < settings.rounds) {
                currentRound++;
                document.getElementById('roundDisplay').textContent = `Round ${currentRound} / ${settings.rounds}`;
                setTimeout(startRound, 1500);
            } else {
                console.log('All rounds complete, showing winner');
                gameRunning = false;
                document.getElementById('startButton').disabled = false;

                try {
                    let maxScore = 0;
                    let winners = [];
                    ballConfigs.forEach((config, i) => {
                        if (scores[i] > maxScore) {
                            maxScore = scores[i];
                            winners = [config.name];
                        } else if (scores[i] === maxScore && scores[i] > 0) {
                            winners.push(config.name);
                        }
                    });

                    const winnerDisplay = document.getElementById('winnerDisplay');
                    if (winners.length > 0) {
                        winnerDisplay.textContent = `Winner: ${winners.join(' & ')}!`;

                        // Resolve betting - find winner's config index
                        const winnerConfig = ballConfigs.findIndex(c => c.name === winners[0]);
                        if (winnerConfig >= 0 && typeof resolveBet === 'function') {
                            setTimeout(() => resolveBet(winnerConfig), 500);
                        }
                    } else {
                        winnerDisplay.textContent = 'Draw!';
                        // Refund bet on draw
                        if (currentBet && currentBet.active) {
                            gameData.currency += currentBet.amount;
                            saveGameData();
                            updateCurrencyDisplay();
                            currentBet = { ballIndex: null, amount: 0, odds: 0, active: false };
                        }
                    }
                    winnerDisplay.style.display = 'block';
                    console.log('Winner displayed:', winners);

                    // Reset scores
                    ballConfigs.forEach((_, i) => scores[i] = 0);

                    // Unlock betting for next game
                    setTimeout(() => {
                        document.getElementById('placeBetBtn').disabled = false;
                        document.getElementById('clearBetBtn').disabled = false;
                        document.getElementById('betBallSelect').disabled = false;
                        document.getElementById('betAmount').disabled = false;
                        if (typeof updateBetUI === 'function') updateBetUI();
                    }, 1000);
                } catch (e) {
                    console.error('Error showing winner:', e);
                    document.getElementById('startButton').disabled = false;
                }
            }
        }

        function gameLoop() {
            // Clear
            ctx.fillStyle = '#f5e6c8';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Arena
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, arenaRadius, 0, Math.PI * 2);
            ctx.clip();

            // Arena floor
            const floorGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, arenaRadius);
            floorGradient.addColorStop(0, '#f5e6c8');
            floorGradient.addColorStop(1, '#d4c4a8');
            ctx.fillStyle = floorGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid pattern
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            for (let i = -arenaRadius; i <= arenaRadius; i += 40) {
                ctx.beginPath();
                ctx.moveTo(centerX + i, centerY - arenaRadius);
                ctx.lineTo(centerX + i, centerY + arenaRadius);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX - arenaRadius, centerY + i);
                ctx.lineTo(centerX + arenaRadius, centerY + i);
                ctx.stroke();
            }

            // Update and draw
            balls.forEach(b => b.update());
            updateProjectiles();
            updateEffects();
            updateFloorTraps();
            updatePowerups();

            drawPowerups();
            drawFloorTraps();
            drawEffects();
            drawProjectiles();
            drawLightning();
            balls.forEach(b => b.draw());

            ctx.restore();

            // Arena border
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(centerX, centerY, arenaRadius, 0, Math.PI * 2);
            ctx.stroke();

            if (gameRunning) {
                checkWinner();
                requestAnimationFrame(gameLoop);
            }
        }

        // Initialize
        initUI();

        // Initial draw
        ctx.fillStyle = '#f5e6c8';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.arc(centerX, centerY, arenaRadius, 0, Math.PI * 2);
        ctx.stroke();
    </script>
</body>
</html>

